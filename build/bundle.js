/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2563:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Admin = void 0;

var add_user_1 = __webpack_require__(8115);

var execute_operation_1 = __webpack_require__(7887);

var list_databases_1 = __webpack_require__(8529);

var remove_user_1 = __webpack_require__(2560);

var run_command_1 = __webpack_require__(5367);

var validate_collection_1 = __webpack_require__(8716);
/**
 * The **Admin** class is an internal class that allows convenient access to
 * the admin functionality and commands for MongoDB.
 *
 * **ADMIN Cannot directly be instantiated**
 * @public
 *
 * @example
 * ```js
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 *
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) {
 *   // Use the admin database for the operation
 *   const adminDb = client.db(dbName).admin();
 *
 *   // List all the available databases
 *   adminDb.listDatabases(function(err, dbs) {
 *     expect(err).to.not.exist;
 *     test.ok(dbs.databases.length > 0);
 *     client.close();
 *   });
 * });
 * ```
 */


var Admin = /*#__PURE__*/function () {
  /**
   * Create a new Admin instance
   * @internal
   */
  function Admin(db) {
    _classCallCheck(this, Admin);

    this.s = {
      db: db
    };
  }

  _createClass(Admin, [{
    key: "command",
    value: function command(_command, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = Object.assign({
        dbName: 'admin'
      }, options);
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new run_command_1.RunCommandOperation(this.s.db, _command, options), callback);
    }
  }, {
    key: "buildInfo",
    value: function buildInfo(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return this.command({
        buildinfo: 1
      }, options, callback);
    }
  }, {
    key: "serverInfo",
    value: function serverInfo(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return this.command({
        buildinfo: 1
      }, options, callback);
    }
  }, {
    key: "serverStatus",
    value: function serverStatus(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return this.command({
        serverStatus: 1
      }, options, callback);
    }
  }, {
    key: "ping",
    value: function ping(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return this.command({
        ping: 1
      }, options, callback);
    }
  }, {
    key: "addUser",
    value: function addUser(username, password, options, callback) {
      if (typeof password === 'function') {
        callback = password, password = undefined, options = {};
      } else if (typeof password !== 'string') {
        if (typeof options === 'function') {
          callback = options, options = password, password = undefined;
        } else {
          options = password, callback = undefined, password = undefined;
        }
      } else {
        if (typeof options === 'function') callback = options, options = {};
      }

      options = Object.assign({
        dbName: 'admin'
      }, options);
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new add_user_1.AddUserOperation(this.s.db, username, password, options), callback);
    }
  }, {
    key: "removeUser",
    value: function removeUser(username, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = Object.assign({
        dbName: 'admin'
      }, options);
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new remove_user_1.RemoveUserOperation(this.s.db, username, options), callback);
    }
  }, {
    key: "validateCollection",
    value: function validateCollection(collectionName, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options), callback);
    }
  }, {
    key: "listDatabases",
    value: function listDatabases(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new list_databases_1.ListDatabasesOperation(this.s.db, options), callback);
    }
  }, {
    key: "replSetGetStatus",
    value: function replSetGetStatus(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return this.command({
        replSetGetStatus: 1
      }, options, callback);
    }
  }]);

  return Admin;
}();

exports.Admin = Admin;

/***/ }),

/***/ 53:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.resolveBSONOptions = exports.pluckBSONSerializeOptions = exports.BSON = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Map = exports.Long = exports.Int32 = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONSymbol = exports.BSONRegExp = exports.Binary = exports.calculateObjectSize = exports.serialize = exports.deserialize = void 0;
/** @internal */
// eslint-disable-next-line @typescript-eslint/no-var-requires

var BSON = __webpack_require__(8054);

exports.BSON = BSON;

try {
  // Ensure you always wrap an optional require in the try block NODE-3199
  exports.BSON = BSON = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'bson-ext'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
} catch (_unused) {} // eslint-disable-line

/** @internal */


exports.deserialize = BSON.deserialize;
/** @internal */

exports.serialize = BSON.serialize;
/** @internal */

exports.calculateObjectSize = BSON.calculateObjectSize;

var bson_1 = __webpack_require__(8054);

Object.defineProperty(exports, "Binary", ({
  enumerable: true,
  get: function get() {
    return bson_1.Binary;
  }
}));
Object.defineProperty(exports, "BSONRegExp", ({
  enumerable: true,
  get: function get() {
    return bson_1.BSONRegExp;
  }
}));
Object.defineProperty(exports, "BSONSymbol", ({
  enumerable: true,
  get: function get() {
    return bson_1.BSONSymbol;
  }
}));
Object.defineProperty(exports, "Code", ({
  enumerable: true,
  get: function get() {
    return bson_1.Code;
  }
}));
Object.defineProperty(exports, "DBRef", ({
  enumerable: true,
  get: function get() {
    return bson_1.DBRef;
  }
}));
Object.defineProperty(exports, "Decimal128", ({
  enumerable: true,
  get: function get() {
    return bson_1.Decimal128;
  }
}));
Object.defineProperty(exports, "Double", ({
  enumerable: true,
  get: function get() {
    return bson_1.Double;
  }
}));
Object.defineProperty(exports, "Int32", ({
  enumerable: true,
  get: function get() {
    return bson_1.Int32;
  }
}));
Object.defineProperty(exports, "Long", ({
  enumerable: true,
  get: function get() {
    return bson_1.Long;
  }
}));
Object.defineProperty(exports, "Map", ({
  enumerable: true,
  get: function get() {
    return bson_1.Map;
  }
}));
Object.defineProperty(exports, "MaxKey", ({
  enumerable: true,
  get: function get() {
    return bson_1.MaxKey;
  }
}));
Object.defineProperty(exports, "MinKey", ({
  enumerable: true,
  get: function get() {
    return bson_1.MinKey;
  }
}));
Object.defineProperty(exports, "ObjectId", ({
  enumerable: true,
  get: function get() {
    return bson_1.ObjectId;
  }
}));
Object.defineProperty(exports, "Timestamp", ({
  enumerable: true,
  get: function get() {
    return bson_1.Timestamp;
  }
}));

function pluckBSONSerializeOptions(options) {
  var fieldsAsRaw = options.fieldsAsRaw,
      promoteValues = options.promoteValues,
      promoteBuffers = options.promoteBuffers,
      promoteLongs = options.promoteLongs,
      serializeFunctions = options.serializeFunctions,
      ignoreUndefined = options.ignoreUndefined,
      bsonRegExp = options.bsonRegExp,
      raw = options.raw,
      enableUtf8Validation = options.enableUtf8Validation;
  return {
    fieldsAsRaw: fieldsAsRaw,
    promoteValues: promoteValues,
    promoteBuffers: promoteBuffers,
    promoteLongs: promoteLongs,
    serializeFunctions: serializeFunctions,
    ignoreUndefined: ignoreUndefined,
    bsonRegExp: bsonRegExp,
    raw: raw,
    enableUtf8Validation: enableUtf8Validation
  };
}

exports.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
/**
 * Merge the given BSONSerializeOptions, preferring options over the parent's options, and
 * substituting defaults for values not set.
 *
 * @internal
 */

function resolveBSONOptions(options, parent) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;

  var parentOptions = parent === null || parent === void 0 ? void 0 : parent.bsonOptions;
  return {
    raw: (_b = (_a = options === null || options === void 0 ? void 0 : options.raw) !== null && _a !== void 0 ? _a : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.raw) !== null && _b !== void 0 ? _b : false,
    promoteLongs: (_d = (_c = options === null || options === void 0 ? void 0 : options.promoteLongs) !== null && _c !== void 0 ? _c : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.promoteLongs) !== null && _d !== void 0 ? _d : true,
    promoteValues: (_f = (_e = options === null || options === void 0 ? void 0 : options.promoteValues) !== null && _e !== void 0 ? _e : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.promoteValues) !== null && _f !== void 0 ? _f : true,
    promoteBuffers: (_h = (_g = options === null || options === void 0 ? void 0 : options.promoteBuffers) !== null && _g !== void 0 ? _g : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.promoteBuffers) !== null && _h !== void 0 ? _h : false,
    ignoreUndefined: (_k = (_j = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _j !== void 0 ? _j : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.ignoreUndefined) !== null && _k !== void 0 ? _k : false,
    bsonRegExp: (_m = (_l = options === null || options === void 0 ? void 0 : options.bsonRegExp) !== null && _l !== void 0 ? _l : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.bsonRegExp) !== null && _m !== void 0 ? _m : false,
    serializeFunctions: (_p = (_o = options === null || options === void 0 ? void 0 : options.serializeFunctions) !== null && _o !== void 0 ? _o : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.serializeFunctions) !== null && _p !== void 0 ? _p : false,
    fieldsAsRaw: (_r = (_q = options === null || options === void 0 ? void 0 : options.fieldsAsRaw) !== null && _q !== void 0 ? _q : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.fieldsAsRaw) !== null && _r !== void 0 ? _r : {},
    enableUtf8Validation: (_t = (_s = options === null || options === void 0 ? void 0 : options.enableUtf8Validation) !== null && _s !== void 0 ? _s : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.enableUtf8Validation) !== null && _t !== void 0 ? _t : true
  };
}

exports.resolveBSONOptions = resolveBSONOptions;

/***/ }),

/***/ 1447:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BulkOperationBase = exports.FindOperators = exports.MongoBulkWriteError = exports.mergeBatchResults = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = void 0;

var bson_1 = __webpack_require__(53);

var error_1 = __webpack_require__(9271);

var delete_1 = __webpack_require__(7857);

var execute_operation_1 = __webpack_require__(7887);

var insert_1 = __webpack_require__(2330);

var operation_1 = __webpack_require__(6778);

var update_1 = __webpack_require__(6262);

var promise_provider_1 = __webpack_require__(8912);

var utils_1 = __webpack_require__(4356);

var write_concern_1 = __webpack_require__(1473);
/** @internal */


var kServerError = Symbol('serverError');
/** @public */

exports.BatchType = Object.freeze({
  INSERT: 1,
  UPDATE: 2,
  DELETE: 3
});
/**
 * Keeps the state of a unordered batch so we can rewrite the results
 * correctly after command execution
 *
 * @public
 */

var Batch = /*#__PURE__*/_createClass(function Batch(batchType, originalZeroIndex) {
  _classCallCheck(this, Batch);

  this.originalZeroIndex = originalZeroIndex;
  this.currentIndex = 0;
  this.originalIndexes = [];
  this.batchType = batchType;
  this.operations = [];
  this.size = 0;
  this.sizeBytes = 0;
});

exports.Batch = Batch;
/**
 * @public
 * The result of a bulk write.
 */

var BulkWriteResult = /*#__PURE__*/function () {
  /**
   * Create a new BulkWriteResult instance
   * @internal
   */
  function BulkWriteResult(bulkResult) {
    _classCallCheck(this, BulkWriteResult);

    this.result = bulkResult;
  }
  /** Number of documents inserted. */


  _createClass(BulkWriteResult, [{
    key: "insertedCount",
    get: function get() {
      var _a;

      return (_a = this.result.nInserted) !== null && _a !== void 0 ? _a : 0;
    }
    /** Number of documents matched for update. */

  }, {
    key: "matchedCount",
    get: function get() {
      var _a;

      return (_a = this.result.nMatched) !== null && _a !== void 0 ? _a : 0;
    }
    /** Number of documents modified. */

  }, {
    key: "modifiedCount",
    get: function get() {
      var _a;

      return (_a = this.result.nModified) !== null && _a !== void 0 ? _a : 0;
    }
    /** Number of documents deleted. */

  }, {
    key: "deletedCount",
    get: function get() {
      var _a;

      return (_a = this.result.nRemoved) !== null && _a !== void 0 ? _a : 0;
    }
    /** Number of documents upserted. */

  }, {
    key: "upsertedCount",
    get: function get() {
      var _a;

      return (_a = this.result.upserted.length) !== null && _a !== void 0 ? _a : 0;
    }
    /** Upserted document generated Id's, hash key is the index of the originating operation */

  }, {
    key: "upsertedIds",
    get: function get() {
      var _a;

      var upserted = {};

      var _iterator = _createForOfIteratorHelper((_a = this.result.upserted) !== null && _a !== void 0 ? _a : []),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var doc = _step.value;
          upserted[doc.index] = doc._id;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return upserted;
    }
    /** Inserted document generated Id's, hash key is the index of the originating operation */

  }, {
    key: "insertedIds",
    get: function get() {
      var _a;

      var inserted = {};

      var _iterator2 = _createForOfIteratorHelper((_a = this.result.insertedIds) !== null && _a !== void 0 ? _a : []),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var doc = _step2.value;
          inserted[doc.index] = doc._id;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return inserted;
    }
    /** Evaluates to true if the bulk operation correctly executes */

  }, {
    key: "ok",
    get: function get() {
      return this.result.ok;
    }
    /** The number of inserted documents */

  }, {
    key: "nInserted",
    get: function get() {
      return this.result.nInserted;
    }
    /** Number of upserted documents */

  }, {
    key: "nUpserted",
    get: function get() {
      return this.result.nUpserted;
    }
    /** Number of matched documents */

  }, {
    key: "nMatched",
    get: function get() {
      return this.result.nMatched;
    }
    /** Number of documents updated physically on disk */

  }, {
    key: "nModified",
    get: function get() {
      return this.result.nModified;
    }
    /** Number of removed documents */

  }, {
    key: "nRemoved",
    get: function get() {
      return this.result.nRemoved;
    }
    /** Returns an array of all inserted ids */

  }, {
    key: "getInsertedIds",
    value: function getInsertedIds() {
      return this.result.insertedIds;
    }
    /** Returns an array of all upserted ids */

  }, {
    key: "getUpsertedIds",
    value: function getUpsertedIds() {
      return this.result.upserted;
    }
    /** Returns the upserted id at the given index */

  }, {
    key: "getUpsertedIdAt",
    value: function getUpsertedIdAt(index) {
      return this.result.upserted[index];
    }
    /** Returns raw internal result */

  }, {
    key: "getRawResponse",
    value: function getRawResponse() {
      return this.result;
    }
    /** Returns true if the bulk operation contains a write error */

  }, {
    key: "hasWriteErrors",
    value: function hasWriteErrors() {
      return this.result.writeErrors.length > 0;
    }
    /** Returns the number of write errors off the bulk operation */

  }, {
    key: "getWriteErrorCount",
    value: function getWriteErrorCount() {
      return this.result.writeErrors.length;
    }
    /** Returns a specific write error object */

  }, {
    key: "getWriteErrorAt",
    value: function getWriteErrorAt(index) {
      return index < this.result.writeErrors.length ? this.result.writeErrors[index] : undefined;
    }
    /** Retrieve all write errors */

  }, {
    key: "getWriteErrors",
    value: function getWriteErrors() {
      return this.result.writeErrors;
    }
    /** Retrieve lastOp if available */

  }, {
    key: "getLastOp",
    value: function getLastOp() {
      return this.result.opTime;
    }
    /** Retrieve the write concern error if one exists */

  }, {
    key: "getWriteConcernError",
    value: function getWriteConcernError() {
      if (this.result.writeConcernErrors.length === 0) {
        return;
      } else if (this.result.writeConcernErrors.length === 1) {
        // Return the error
        return this.result.writeConcernErrors[0];
      } else {
        // Combine the errors
        var errmsg = '';

        for (var i = 0; i < this.result.writeConcernErrors.length; i++) {
          var err = this.result.writeConcernErrors[i];
          errmsg = errmsg + err.errmsg; // TODO: Something better

          if (i === 0) errmsg = errmsg + ' and ';
        }

        return new WriteConcernError({
          errmsg: errmsg,
          code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed
        });
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.result;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "BulkWriteResult(".concat(this.toJSON(), ")");
    }
  }, {
    key: "isOk",
    value: function isOk() {
      return this.result.ok === 1;
    }
  }]);

  return BulkWriteResult;
}();

exports.BulkWriteResult = BulkWriteResult;
/**
 * An error representing a failure by the server to apply the requested write concern to the bulk operation.
 * @public
 * @category Error
 */

var WriteConcernError = /*#__PURE__*/function () {
  function WriteConcernError(error) {
    _classCallCheck(this, WriteConcernError);

    this[kServerError] = error;
  }
  /** Write concern error code. */


  _createClass(WriteConcernError, [{
    key: "code",
    get: function get() {
      return this[kServerError].code;
    }
    /** Write concern error message. */

  }, {
    key: "errmsg",
    get: function get() {
      return this[kServerError].errmsg;
    }
    /** Write concern error info. */

  }, {
    key: "errInfo",
    get: function get() {
      return this[kServerError].errInfo;
    }
    /** @deprecated The `err` prop that contained a MongoServerError has been deprecated. */

  }, {
    key: "err",
    get: function get() {
      return this[kServerError];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this[kServerError];
    }
  }, {
    key: "toString",
    value: function toString() {
      return "WriteConcernError(".concat(this.errmsg, ")");
    }
  }]);

  return WriteConcernError;
}();

exports.WriteConcernError = WriteConcernError;
/**
 * An error that occurred during a BulkWrite on the server.
 * @public
 * @category Error
 */

var WriteError = /*#__PURE__*/function () {
  function WriteError(err) {
    _classCallCheck(this, WriteError);

    this.err = err;
  }
  /** WriteError code. */


  _createClass(WriteError, [{
    key: "code",
    get: function get() {
      return this.err.code;
    }
    /** WriteError original bulk operation index. */

  }, {
    key: "index",
    get: function get() {
      return this.err.index;
    }
    /** WriteError message. */

  }, {
    key: "errmsg",
    get: function get() {
      return this.err.errmsg;
    }
    /** WriteError details. */

  }, {
    key: "errInfo",
    get: function get() {
      return this.err.errInfo;
    }
    /** Returns the underlying operation that caused the error */

  }, {
    key: "getOperation",
    value: function getOperation() {
      return this.err.op;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        code: this.err.code,
        index: this.err.index,
        errmsg: this.err.errmsg,
        op: this.err.op
      };
    }
  }, {
    key: "toString",
    value: function toString() {
      return "WriteError(".concat(JSON.stringify(this.toJSON()), ")");
    }
  }]);

  return WriteError;
}();

exports.WriteError = WriteError;
/** Converts the number to a Long or returns it. */

function longOrConvert(value) {
  // TODO(NODE-2674): Preserve int64 sent from MongoDB
  return typeof value === 'number' ? bson_1.Long.fromNumber(value) : value;
}
/** Merges results into shared data structure */


function mergeBatchResults(batch, bulkResult, err, result) {
  // If we have an error set the result to be the err object
  if (err) {
    result = err;
  } else if (result && result.result) {
    result = result.result;
  }

  if (result == null) {
    return;
  } // Do we have a top level error stop processing and return


  if (result.ok === 0 && bulkResult.ok === 1) {
    bulkResult.ok = 0;
    var writeError = {
      index: 0,
      code: result.code || 0,
      errmsg: result.message,
      errInfo: result.errInfo,
      op: batch.operations[0]
    };
    bulkResult.writeErrors.push(new WriteError(writeError));
    return;
  } else if (result.ok === 0 && bulkResult.ok === 0) {
    return;
  } // The server write command specification states that lastOp is an optional
  // mongod only field that has a type of timestamp. Across various scarce specs
  // where opTime is mentioned, it is an "opaque" object that can have a "ts" and
  // "t" field with Timestamp and Long as their types respectively.
  // The "lastOp" field of the bulk write result is never mentioned in the driver
  // specifications or the bulk write spec, so we should probably just keep its
  // value consistent since it seems to vary.
  // See: https://github.com/mongodb/specifications/blob/master/source/driver-bulk-update.rst#results-object


  if (result.opTime || result.lastOp) {
    var opTime = result.lastOp || result.opTime; // If the opTime is a Timestamp, convert it to a consistent format to be
    // able to compare easily. Converting to the object from a timestamp is
    // much more straightforward than the other direction.

    if (opTime._bsontype === 'Timestamp') {
      opTime = {
        ts: opTime,
        t: bson_1.Long.ZERO
      };
    } // If there's no lastOp, just set it.


    if (!bulkResult.opTime) {
      bulkResult.opTime = opTime;
    } else {
      // First compare the ts values and set if the opTimeTS value is greater.
      var lastOpTS = longOrConvert(bulkResult.opTime.ts);
      var opTimeTS = longOrConvert(opTime.ts);

      if (opTimeTS.greaterThan(lastOpTS)) {
        bulkResult.opTime = opTime;
      } else if (opTimeTS.equals(lastOpTS)) {
        // If the ts values are equal, then compare using the t values.
        var lastOpT = longOrConvert(bulkResult.opTime.t);
        var opTimeT = longOrConvert(opTime.t);

        if (opTimeT.greaterThan(lastOpT)) {
          bulkResult.opTime = opTime;
        }
      }
    }
  } // If we have an insert Batch type


  if (isInsertBatch(batch) && result.n) {
    bulkResult.nInserted = bulkResult.nInserted + result.n;
  } // If we have an insert Batch type


  if (isDeleteBatch(batch) && result.n) {
    bulkResult.nRemoved = bulkResult.nRemoved + result.n;
  }

  var nUpserted = 0; // We have an array of upserted values, we need to rewrite the indexes

  if (Array.isArray(result.upserted)) {
    nUpserted = result.upserted.length;

    for (var i = 0; i < result.upserted.length; i++) {
      bulkResult.upserted.push({
        index: result.upserted[i].index + batch.originalZeroIndex,
        _id: result.upserted[i]._id
      });
    }
  } else if (result.upserted) {
    nUpserted = 1;
    bulkResult.upserted.push({
      index: batch.originalZeroIndex,
      _id: result.upserted
    });
  } // If we have an update Batch type


  if (isUpdateBatch(batch) && result.n) {
    var nModified = result.nModified;
    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);

    if (typeof nModified === 'number') {
      bulkResult.nModified = bulkResult.nModified + nModified;
    } else {
      bulkResult.nModified = 0;
    }
  }

  if (Array.isArray(result.writeErrors)) {
    for (var _i = 0; _i < result.writeErrors.length; _i++) {
      var _writeError = {
        index: batch.originalIndexes[result.writeErrors[_i].index],
        code: result.writeErrors[_i].code,
        errmsg: result.writeErrors[_i].errmsg,
        errInfo: result.writeErrors[_i].errInfo,
        op: batch.operations[result.writeErrors[_i].index]
      };
      bulkResult.writeErrors.push(new WriteError(_writeError));
    }
  }

  if (result.writeConcernError) {
    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
  }
}

exports.mergeBatchResults = mergeBatchResults;

function executeCommands(bulkOperation, options, callback) {
  if (bulkOperation.s.batches.length === 0) {
    return callback(undefined, new BulkWriteResult(bulkOperation.s.bulkResult));
  }

  var batch = bulkOperation.s.batches.shift();

  function resultHandler(err, result) {
    // Error is a driver related error not a bulk op error, return early
    if (err && 'message' in err && !(err instanceof error_1.MongoWriteConcernError)) {
      return callback(new MongoBulkWriteError(err, new BulkWriteResult(bulkOperation.s.bulkResult)));
    }

    if (err instanceof error_1.MongoWriteConcernError) {
      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
    } // Merge the results together


    var writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
    var mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);

    if (mergeResult != null) {
      return callback(undefined, writeResult);
    }

    if (bulkOperation.handleWriteError(callback, writeResult)) return; // Execute the next command in line

    executeCommands(bulkOperation, options, callback);
  }

  var finalOptions = (0, utils_1.resolveOptions)(bulkOperation, _objectSpread(_objectSpread({}, options), {}, {
    ordered: bulkOperation.isOrdered
  }));

  if (finalOptions.bypassDocumentValidation !== true) {
    delete finalOptions.bypassDocumentValidation;
  } // Set an operationIf if provided


  if (bulkOperation.operationId) {
    resultHandler.operationId = bulkOperation.operationId;
  } // Is the bypassDocumentValidation options specific


  if (bulkOperation.s.bypassDocumentValidation === true) {
    finalOptions.bypassDocumentValidation = true;
  } // Is the checkKeys option disabled


  if (bulkOperation.s.checkKeys === false) {
    finalOptions.checkKeys = false;
  }

  if (finalOptions.retryWrites) {
    if (isUpdateBatch(batch)) {
      finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some(function (op) {
        return op.multi;
      });
    }

    if (isDeleteBatch(batch)) {
      finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some(function (op) {
        return op.limit === 0;
      });
    }
  }

  try {
    if (isInsertBatch(batch)) {
      (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.s.db.s.client, new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
    } else if (isUpdateBatch(batch)) {
      (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.s.db.s.client, new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
    } else if (isDeleteBatch(batch)) {
      (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.s.db.s.client, new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
    }
  } catch (err) {
    // Force top level error
    err.ok = 0; // Merge top level error and return

    mergeBatchResults(batch, bulkOperation.s.bulkResult, err, undefined);
    callback();
  }
}

function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
  var _a, _b;

  mergeBatchResults(batch, bulkResult, undefined, err.result);
  callback(new MongoBulkWriteError({
    message: (_a = err.result) === null || _a === void 0 ? void 0 : _a.writeConcernError.errmsg,
    code: (_b = err.result) === null || _b === void 0 ? void 0 : _b.writeConcernError.result
  }, new BulkWriteResult(bulkResult)));
}
/**
 * An error indicating an unsuccessful Bulk Write
 * @public
 * @category Error
 */


var MongoBulkWriteError = /*#__PURE__*/function (_error_1$MongoServerE) {
  _inherits(MongoBulkWriteError, _error_1$MongoServerE);

  var _super = _createSuper(MongoBulkWriteError);

  /** Creates a new MongoBulkWriteError */
  function MongoBulkWriteError(error, result) {
    var _this;

    _classCallCheck(this, MongoBulkWriteError);

    var _a;

    _this = _super.call(this, error);
    _this.writeErrors = [];
    if (error instanceof WriteConcernError) _this.err = error;else if (!(error instanceof Error)) {
      _this.message = error.message;
      _this.code = error.code;
      _this.writeErrors = (_a = error.writeErrors) !== null && _a !== void 0 ? _a : [];
    }
    _this.result = result;
    Object.assign(_assertThisInitialized(_this), error);
    return _this;
  }

  _createClass(MongoBulkWriteError, [{
    key: "name",
    get: function get() {
      return 'MongoBulkWriteError';
    }
    /** Number of documents inserted. */

  }, {
    key: "insertedCount",
    get: function get() {
      return this.result.insertedCount;
    }
    /** Number of documents matched for update. */

  }, {
    key: "matchedCount",
    get: function get() {
      return this.result.matchedCount;
    }
    /** Number of documents modified. */

  }, {
    key: "modifiedCount",
    get: function get() {
      return this.result.modifiedCount;
    }
    /** Number of documents deleted. */

  }, {
    key: "deletedCount",
    get: function get() {
      return this.result.deletedCount;
    }
    /** Number of documents upserted. */

  }, {
    key: "upsertedCount",
    get: function get() {
      return this.result.upsertedCount;
    }
    /** Inserted document generated Id's, hash key is the index of the originating operation */

  }, {
    key: "insertedIds",
    get: function get() {
      return this.result.insertedIds;
    }
    /** Upserted document generated Id's, hash key is the index of the originating operation */

  }, {
    key: "upsertedIds",
    get: function get() {
      return this.result.upsertedIds;
    }
  }]);

  return MongoBulkWriteError;
}(error_1.MongoServerError);

exports.MongoBulkWriteError = MongoBulkWriteError;
/**
 * A builder object that is returned from {@link BulkOperationBase#find}.
 * Is used to build a write operation that involves a query filter.
 *
 * @public
 */

var FindOperators = /*#__PURE__*/function () {
  /**
   * Creates a new FindOperators object.
   * @internal
   */
  function FindOperators(bulkOperation) {
    _classCallCheck(this, FindOperators);

    this.bulkOperation = bulkOperation;
  }
  /** Add a multiple update operation to the bulk operation */


  _createClass(FindOperators, [{
    key: "update",
    value: function update(updateDocument) {
      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, _objectSpread(_objectSpread({}, currentOp), {}, {
        multi: true
      })));
    }
    /** Add a single update operation to the bulk operation */

  }, {
    key: "updateOne",
    value: function updateOne(updateDocument) {
      if (!(0, utils_1.hasAtomicOperators)(updateDocument)) {
        throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
      }

      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, _objectSpread(_objectSpread({}, currentOp), {}, {
        multi: false
      })));
    }
    /** Add a replace one operation to the bulk operation */

  }, {
    key: "replaceOne",
    value: function replaceOne(replacement) {
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');
      }

      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, _objectSpread(_objectSpread({}, currentOp), {}, {
        multi: false
      })));
    }
    /** Add a delete one operation to the bulk operation */

  }, {
    key: "deleteOne",
    value: function deleteOne() {
      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, _objectSpread(_objectSpread({}, currentOp), {}, {
        limit: 1
      })));
    }
    /** Add a delete many operation to the bulk operation */

  }, {
    key: "delete",
    value: function _delete() {
      var currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, _objectSpread(_objectSpread({}, currentOp), {}, {
        limit: 0
      })));
    }
    /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */

  }, {
    key: "upsert",
    value: function upsert() {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }

      this.bulkOperation.s.currentOp.upsert = true;
      return this;
    }
    /** Specifies the collation for the query condition. */

  }, {
    key: "collation",
    value: function collation(_collation) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }

      this.bulkOperation.s.currentOp.collation = _collation;
      return this;
    }
    /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */

  }, {
    key: "arrayFilters",
    value: function arrayFilters(_arrayFilters) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }

      this.bulkOperation.s.currentOp.arrayFilters = _arrayFilters;
      return this;
    }
  }]);

  return FindOperators;
}();

exports.FindOperators = FindOperators;
/**
 * TODO(NODE-4063)
 * BulkWrites merge complexity is implemented in executeCommands
 * This provides a vehicle to treat bulkOperations like any other operation (hence "shim")
 * We would like this logic to simply live inside the BulkWriteOperation class
 * @internal
 */

var BulkWriteShimOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(BulkWriteShimOperation, _operation_1$Abstract);

  var _super2 = _createSuper(BulkWriteShimOperation);

  function BulkWriteShimOperation(bulkOperation, options) {
    var _this2;

    _classCallCheck(this, BulkWriteShimOperation);

    _this2 = _super2.call(this, options);
    _this2.bulkOperation = bulkOperation;
    return _this2;
  }

  _createClass(BulkWriteShimOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      if (this.options.session == null) {
        // An implicit session could have been created by 'executeOperation'
        // So if we stick it on finalOptions here, each bulk operation
        // will use this same session, it'll be passed in the same way
        // an explicit session would be
        this.options.session = session;
      }

      return executeCommands(this.bulkOperation, this.options, callback);
    }
  }]);

  return BulkWriteShimOperation;
}(operation_1.AbstractOperation);
/** @public */


var BulkOperationBase = /*#__PURE__*/function () {
  /**
   * Create a new OrderedBulkOperation or UnorderedBulkOperation instance
   * @internal
   */
  function BulkOperationBase(collection, options, isOrdered) {
    _classCallCheck(this, BulkOperationBase);

    // determine whether bulkOperation is ordered or unordered
    this.isOrdered = isOrdered;
    var topology = (0, utils_1.getTopology)(collection);
    options = options == null ? {} : options; // TODO Bring from driver information in hello
    // Get the namespace for the write operations

    var namespace = collection.s.namespace; // Used to mark operation as executed

    var executed = false; // Current item

    var currentOp = undefined; // Set max byte size

    var hello = topology.lastHello(); // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents
    // over 2mb are still allowed

    var usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
    var maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
    var maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
    var maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1000; // Calculates the largest possible size of an Array key, represented as a BSON string
    // element. This calculation:
    //     1 byte for BSON type
    //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))
    //   + 1 bytes for null terminator

    var maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2; // Final options for retryable writes

    var finalOptions = Object.assign({}, options);
    finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db); // Final results

    var bulkResult = {
      ok: 1,
      writeErrors: [],
      writeConcernErrors: [],
      insertedIds: [],
      nInserted: 0,
      nUpserted: 0,
      nMatched: 0,
      nModified: 0,
      nRemoved: 0,
      upserted: []
    }; // Internal state

    this.s = {
      // Final result
      bulkResult: bulkResult,
      // Current batch state
      currentBatch: undefined,
      currentIndex: 0,
      // ordered specific
      currentBatchSize: 0,
      currentBatchSizeBytes: 0,
      // unordered specific
      currentInsertBatch: undefined,
      currentUpdateBatch: undefined,
      currentRemoveBatch: undefined,
      batches: [],
      // Write concern
      writeConcern: write_concern_1.WriteConcern.fromOptions(options),
      // Max batch size options
      maxBsonObjectSize: maxBsonObjectSize,
      maxBatchSizeBytes: maxBatchSizeBytes,
      maxWriteBatchSize: maxWriteBatchSize,
      maxKeySize: maxKeySize,
      // Namespace
      namespace: namespace,
      // Topology
      topology: topology,
      // Options
      options: finalOptions,
      // BSON options
      bsonOptions: (0, bson_1.resolveBSONOptions)(options),
      // Current operation
      currentOp: currentOp,
      // Executed
      executed: executed,
      // Collection
      collection: collection,
      // Fundamental error
      err: undefined,
      // check keys
      checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : false
    }; // bypass Validation

    if (options.bypassDocumentValidation === true) {
      this.s.bypassDocumentValidation = true;
    }
  }
  /**
   * Add a single insert document to the bulk operation
   *
   * @example
   * ```js
   * const bulkOp = collection.initializeOrderedBulkOp();
   *
   * // Adds three inserts to the bulkOp.
   * bulkOp
   *   .insert({ a: 1 })
   *   .insert({ b: 2 })
   *   .insert({ c: 3 });
   * await bulkOp.execute();
   * ```
   */


  _createClass(BulkOperationBase, [{
    key: "insert",
    value: function insert(document) {
      if (document._id == null && !shouldForceServerObjectId(this)) {
        document._id = new bson_1.ObjectId();
      }

      return this.addToOperationsList(exports.BatchType.INSERT, document);
    }
    /**
     * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.
     * Returns a builder object used to complete the definition of the operation.
     *
     * @example
     * ```js
     * const bulkOp = collection.initializeOrderedBulkOp();
     *
     * // Add an updateOne to the bulkOp
     * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });
     *
     * // Add an updateMany to the bulkOp
     * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });
     *
     * // Add an upsert
     * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });
     *
     * // Add a deletion
     * bulkOp.find({ g: 7 }).deleteOne();
     *
     * // Add a multi deletion
     * bulkOp.find({ h: 8 }).delete();
     *
     * // Add a replaceOne
     * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});
     *
     * // Update using a pipeline (requires Mongodb 4.2 or higher)
     * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([
     *   { $set: { total: { $sum: [ '$y', '$z' ] } } }
     * ]);
     *
     * // All of the ops will now be executed
     * await bulkOp.execute();
     * ```
     */

  }, {
    key: "find",
    value: function find(selector) {
      if (!selector) {
        throw new error_1.MongoInvalidArgumentError('Bulk find operation must specify a selector');
      } // Save a current selector


      this.s.currentOp = {
        selector: selector
      };
      return new FindOperators(this);
    }
    /** Specifies a raw operation to perform in the bulk write. */

  }, {
    key: "raw",
    value: function raw(op) {
      if (op == null || _typeof(op) !== 'object') {
        throw new error_1.MongoInvalidArgumentError('Operation must be an object with an operation key');
      }

      if ('insertOne' in op) {
        var forceServerObjectId = shouldForceServerObjectId(this);

        if (op.insertOne && op.insertOne.document == null) {
          // NOTE: provided for legacy support, but this is a malformed operation
          if (forceServerObjectId !== true && op.insertOne._id == null) {
            op.insertOne._id = new bson_1.ObjectId();
          }

          return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne);
        }

        if (forceServerObjectId !== true && op.insertOne.document._id == null) {
          op.insertOne.document._id = new bson_1.ObjectId();
        }

        return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne.document);
      }

      if ('replaceOne' in op || 'updateOne' in op || 'updateMany' in op) {
        if ('replaceOne' in op) {
          if ('q' in op.replaceOne) {
            throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
          }

          var updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, _objectSpread(_objectSpread({}, op.replaceOne), {}, {
            multi: false
          }));

          if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');
          }

          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }

        if ('updateOne' in op) {
          if ('q' in op.updateOne) {
            throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
          }

          var _updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, _objectSpread(_objectSpread({}, op.updateOne), {}, {
            multi: false
          }));

          if (!(0, utils_1.hasAtomicOperators)(_updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
          }

          return this.addToOperationsList(exports.BatchType.UPDATE, _updateStatement);
        }

        if ('updateMany' in op) {
          if ('q' in op.updateMany) {
            throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
          }

          var _updateStatement2 = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, _objectSpread(_objectSpread({}, op.updateMany), {}, {
            multi: true
          }));

          if (!(0, utils_1.hasAtomicOperators)(_updateStatement2.u)) {
            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
          }

          return this.addToOperationsList(exports.BatchType.UPDATE, _updateStatement2);
        }
      }

      if ('deleteOne' in op) {
        if ('q' in op.deleteOne) {
          throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
        }

        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, _objectSpread(_objectSpread({}, op.deleteOne), {}, {
          limit: 1
        })));
      }

      if ('deleteMany' in op) {
        if ('q' in op.deleteMany) {
          throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
        }

        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, _objectSpread(_objectSpread({}, op.deleteMany), {}, {
          limit: 0
        })));
      } // otherwise an unknown operation was provided


      throw new error_1.MongoInvalidArgumentError('bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany');
    }
  }, {
    key: "bsonOptions",
    get: function get() {
      return this.s.bsonOptions;
    }
  }, {
    key: "writeConcern",
    get: function get() {
      return this.s.writeConcern;
    }
  }, {
    key: "batches",
    get: function get() {
      var batches = _toConsumableArray(this.s.batches);

      if (this.isOrdered) {
        if (this.s.currentBatch) batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch) batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch) batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch) batches.push(this.s.currentRemoveBatch);
      }

      return batches;
    }
  }, {
    key: "execute",
    value: function execute(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};

      if (this.s.executed) {
        return handleEarlyError(new error_1.MongoBatchReExecutionError(), callback);
      }

      var writeConcern = write_concern_1.WriteConcern.fromOptions(options);

      if (writeConcern) {
        this.s.writeConcern = writeConcern;
      } // If we have current batch


      if (this.isOrdered) {
        if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);
      } // If we have no operations in the bulk raise an error


      if (this.s.batches.length === 0) {
        var emptyBatchError = new error_1.MongoInvalidArgumentError('Invalid BulkOperation, Batch cannot be empty');
        return handleEarlyError(emptyBatchError, callback);
      }

      this.s.executed = true;

      var finalOptions = _objectSpread(_objectSpread({}, this.s.options), options);

      var operation = new BulkWriteShimOperation(this, finalOptions);
      return (0, execute_operation_1.executeOperation)(this.s.collection.s.db.s.client, operation, callback);
    }
    /**
     * Handles the write error before executing commands
     * @internal
     */

  }, {
    key: "handleWriteError",
    value: function handleWriteError(callback, writeResult) {
      if (this.s.bulkResult.writeErrors.length > 0) {
        var msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : 'write operation failed';
        callback(new MongoBulkWriteError({
          message: msg,
          code: this.s.bulkResult.writeErrors[0].code,
          writeErrors: this.s.bulkResult.writeErrors
        }, writeResult));
        return true;
      }

      var writeConcernError = writeResult.getWriteConcernError();

      if (writeConcernError) {
        callback(new MongoBulkWriteError(writeConcernError, writeResult));
        return true;
      }

      return false;
    }
  }]);

  return BulkOperationBase;
}();

exports.BulkOperationBase = BulkOperationBase;
Object.defineProperty(BulkOperationBase.prototype, 'length', {
  enumerable: true,
  get: function get() {
    return this.s.currentIndex;
  }
});
/** helper function to assist with promiseOrCallback behavior */

function handleEarlyError(err, callback) {
  var Promise = promise_provider_1.PromiseProvider.get();

  if (typeof callback === 'function') {
    callback(err);
    return;
  }

  return Promise.reject(err);
}

function shouldForceServerObjectId(bulkOperation) {
  var _a, _b;

  if (typeof bulkOperation.s.options.forceServerObjectId === 'boolean') {
    return bulkOperation.s.options.forceServerObjectId;
  }

  if (typeof ((_a = bulkOperation.s.collection.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId) === 'boolean') {
    return (_b = bulkOperation.s.collection.s.db.options) === null || _b === void 0 ? void 0 : _b.forceServerObjectId;
  }

  return false;
}

function isInsertBatch(batch) {
  return batch.batchType === exports.BatchType.INSERT;
}

function isUpdateBatch(batch) {
  return batch.batchType === exports.BatchType.UPDATE;
}

function isDeleteBatch(batch) {
  return batch.batchType === exports.BatchType.DELETE;
}

function buildCurrentOp(bulkOp) {
  var currentOp = bulkOp.s.currentOp;
  bulkOp.s.currentOp = undefined;
  if (!currentOp) currentOp = {};
  return currentOp;
}

/***/ }),

/***/ 1409:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OrderedBulkOperation = void 0;

var BSON = __webpack_require__(53);

var error_1 = __webpack_require__(9271);

var common_1 = __webpack_require__(1447);
/** @public */


var OrderedBulkOperation = /*#__PURE__*/function (_common_1$BulkOperati) {
  _inherits(OrderedBulkOperation, _common_1$BulkOperati);

  var _super = _createSuper(OrderedBulkOperation);

  function OrderedBulkOperation(collection, options) {
    _classCallCheck(this, OrderedBulkOperation);

    return _super.call(this, collection, options, true);
  }

  _createClass(OrderedBulkOperation, [{
    key: "addToOperationsList",
    value: function addToOperationsList(batchType, document) {
      // Get the bsonSize
      var bsonSize = BSON.calculateObjectSize(document, {
        checkKeys: false,
        // Since we don't know what the user selected for BSON options here,
        // err on the safe side, and check the size with ignoreUndefined: false.
        ignoreUndefined: false
      }); // Throw error if the doc is bigger than the max BSON size

      if (bsonSize >= this.s.maxBsonObjectSize) // TODO(NODE-3483): Change this to MongoBSONError
        throw new error_1.MongoInvalidArgumentError("Document is larger than the maximum size ".concat(this.s.maxBsonObjectSize)); // Create a new batch object if we don't have a current one

      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }

      var maxKeySize = this.s.maxKeySize; // Check if we need to create a new batch

      if ( // New batch if we exceed the max batch op size
      this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
      // since we can't sent an empty batch
      this.s.currentBatchSize > 0 && this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
      this.s.currentBatch.batchType !== batchType) {
        // Save the batch to the execution stack
        this.s.batches.push(this.s.currentBatch); // Create a new batch

        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex); // Reset the current size trackers

        this.s.currentBatchSize = 0;
        this.s.currentBatchSizeBytes = 0;
      }

      if (batchType === common_1.BatchType.INSERT) {
        this.s.bulkResult.insertedIds.push({
          index: this.s.currentIndex,
          _id: document._id
        });
      } // We have an array of documents


      if (Array.isArray(document)) {
        throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');
      }

      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentBatch.operations.push(document);
      this.s.currentBatchSize += 1;
      this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      this.s.currentIndex += 1;
      return this;
    }
  }]);

  return OrderedBulkOperation;
}(common_1.BulkOperationBase);

exports.OrderedBulkOperation = OrderedBulkOperation;

/***/ }),

/***/ 1878:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UnorderedBulkOperation = void 0;

var BSON = __webpack_require__(53);

var error_1 = __webpack_require__(9271);

var common_1 = __webpack_require__(1447);
/** @public */


var UnorderedBulkOperation = /*#__PURE__*/function (_common_1$BulkOperati) {
  _inherits(UnorderedBulkOperation, _common_1$BulkOperati);

  var _super = _createSuper(UnorderedBulkOperation);

  function UnorderedBulkOperation(collection, options) {
    _classCallCheck(this, UnorderedBulkOperation);

    return _super.call(this, collection, options, false);
  }

  _createClass(UnorderedBulkOperation, [{
    key: "handleWriteError",
    value: function handleWriteError(callback, writeResult) {
      if (this.s.batches.length) {
        return false;
      }

      return _get(_getPrototypeOf(UnorderedBulkOperation.prototype), "handleWriteError", this).call(this, callback, writeResult);
    }
  }, {
    key: "addToOperationsList",
    value: function addToOperationsList(batchType, document) {
      // Get the bsonSize
      var bsonSize = BSON.calculateObjectSize(document, {
        checkKeys: false,
        // Since we don't know what the user selected for BSON options here,
        // err on the safe side, and check the size with ignoreUndefined: false.
        ignoreUndefined: false
      }); // Throw error if the doc is bigger than the max BSON size

      if (bsonSize >= this.s.maxBsonObjectSize) {
        // TODO(NODE-3483): Change this to MongoBSONError
        throw new error_1.MongoInvalidArgumentError("Document is larger than the maximum size ".concat(this.s.maxBsonObjectSize));
      } // Holds the current batch


      this.s.currentBatch = undefined; // Get the right type of batch

      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentBatch = this.s.currentInsertBatch;
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentBatch = this.s.currentUpdateBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentBatch = this.s.currentRemoveBatch;
      }

      var maxKeySize = this.s.maxKeySize; // Create a new batch object if we don't have a current one

      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      } // Check if we need to create a new batch


      if ( // New batch if we exceed the max batch op size
      this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
      // since we can't sent an empty batch
      this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
      this.s.currentBatch.batchType !== batchType) {
        // Save the batch to the execution stack
        this.s.batches.push(this.s.currentBatch); // Create a new batch

        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      } // We have an array of documents


      if (Array.isArray(document)) {
        throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');
      }

      this.s.currentBatch.operations.push(document);
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentIndex = this.s.currentIndex + 1; // Save back the current Batch to the right type

      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentInsertBatch = this.s.currentBatch;
        this.s.bulkResult.insertedIds.push({
          index: this.s.bulkResult.insertedIds.length,
          _id: document._id
        });
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentUpdateBatch = this.s.currentBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentRemoveBatch = this.s.currentBatch;
      } // Update current batch size


      this.s.currentBatch.size += 1;
      this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return this;
    }
  }]);

  return UnorderedBulkOperation;
}(common_1.BulkOperationBase);

exports.UnorderedBulkOperation = UnorderedBulkOperation;

/***/ }),

/***/ 4672:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ChangeStream = void 0;

var util_1 = __webpack_require__(3837);

var collection_1 = __webpack_require__(9730);

var constants_1 = __webpack_require__(1254);

var change_stream_cursor_1 = __webpack_require__(1564);

var db_1 = __webpack_require__(9828);

var error_1 = __webpack_require__(9271);

var mongo_client_1 = __webpack_require__(9635);

var mongo_types_1 = __webpack_require__(3738);

var utils_1 = __webpack_require__(4356);
/** @internal */


var kCursorStream = Symbol('cursorStream');
/** @internal */

var kClosed = Symbol('closed');
/** @internal */

var kMode = Symbol('mode');
var CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument', 'fullDocumentBeforeChange', 'showExpandedEvents'];
var CHANGE_DOMAIN_TYPES = {
  COLLECTION: Symbol('Collection'),
  DATABASE: Symbol('Database'),
  CLUSTER: Symbol('Cluster')
};
var CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
var NO_RESUME_TOKEN_ERROR = 'A change stream document has been received that lacks a resume token (_id).';
var CHANGESTREAM_CLOSED_ERROR = 'ChangeStream is closed';
/**
 * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.
 * @public
 */

var ChangeStream = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(ChangeStream, _mongo_types_1$TypedE);

  var _super = _createSuper(ChangeStream);

  /**
   * @internal
   *
   * @param parent - The parent object that created this change stream
   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents
   */
  function ChangeStream(parent) {
    var _this;

    var pipeline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ChangeStream);

    _this = _super.call(this);
    /**
     * @internal
     *
     * TODO(NODE-4320): promisify selectServer and refactor this code to be async
     *
     * we promisify _processErrorIteratorModeCallback until we have a promisifed version of selectServer.
     */
    // eslint-disable-next-line @typescript-eslint/unbound-method

    _this._processErrorIteratorMode = (0, util_1.promisify)(_this._processErrorIteratorModeCallback);
    _this.pipeline = pipeline;
    _this.options = options;

    if (parent instanceof collection_1.Collection) {
      _this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
    } else if (parent instanceof db_1.Db) {
      _this.type = CHANGE_DOMAIN_TYPES.DATABASE;
    } else if (parent instanceof mongo_client_1.MongoClient) {
      _this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
    } else {
      throw new error_1.MongoChangeStreamError('Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient');
    }

    _this.parent = parent;
    _this.namespace = parent.s.namespace;

    if (!_this.options.readPreference && parent.readPreference) {
      _this.options.readPreference = parent.readPreference;
    } // Create contained Change Stream cursor


    _this.cursor = _this._createChangeStreamCursor(options);
    _this[kClosed] = false;
    _this[kMode] = false; // Listen for any `change` listeners being added to ChangeStream

    _this.on('newListener', function (eventName) {
      if (eventName === 'change' && _this.cursor && _this.listenerCount('change') === 0) {
        _this._streamEvents(_this.cursor);
      }
    });

    _this.on('removeListener', function (eventName) {
      var _a;

      if (eventName === 'change' && _this.listenerCount('change') === 0 && _this.cursor) {
        (_a = _this[kCursorStream]) === null || _a === void 0 ? void 0 : _a.removeAllListeners('data');
      }
    });

    return _this;
  }
  /** @internal */


  _createClass(ChangeStream, [{
    key: "cursorStream",
    get: function get() {
      return this[kCursorStream];
    }
    /** The cached resume token that is used to resume after the most recently returned change. */

  }, {
    key: "resumeToken",
    get: function get() {
      var _a;

      return (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.resumeToken;
    }
  }, {
    key: "hasNext",
    value: function hasNext(callback) {
      var _this2 = this;

      this._setIsIterator(); // TOOD(NODE-4319): Add eslint rule preventing accidental variable shadowing
      // Shadowing is intentional here.  We want to override the `callback` variable
      // from the outer scope so that the inner scope doesn't accidentally call the wrong callback.


      return (0, utils_1.maybePromise)(callback, function (callback) {
        _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var hasNext, _hasNext;

          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return _this2.cursor.hasNext();

                case 3:
                  hasNext = _context.sent;
                  return _context.abrupt("return", hasNext);

                case 7:
                  _context.prev = 7;
                  _context.t0 = _context["catch"](0);
                  _context.prev = 9;
                  _context.next = 12;
                  return _this2._processErrorIteratorMode(_context.t0);

                case 12:
                  _context.next = 14;
                  return _this2.cursor.hasNext();

                case 14:
                  _hasNext = _context.sent;
                  return _context.abrupt("return", _hasNext);

                case 18:
                  _context.prev = 18;
                  _context.t1 = _context["catch"](9);
                  _context.next = 22;
                  return _this2.close()["catch"](function (err) {
                    return err;
                  });

                case 22:
                  throw _context.t1;

                case 23:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 7], [9, 18]]);
        }))().then(function (hasNext) {
          return callback(undefined, hasNext);
        }, function (error) {
          return callback(error);
        });
      });
    }
  }, {
    key: "next",
    value: function next(callback) {
      var _this3 = this;

      this._setIsIterator(); // TOOD(NODE-4319): Add eslint rule preventing accidental variable shadowing
      // Shadowing is intentional here.  We want to override the `callback` variable
      // from the outer scope so that the inner scope doesn't accidentally call the wrong callback.


      return (0, utils_1.maybePromise)(callback, function (callback) {
        _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var change, processedChange, _change, _processedChange;

          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  _context2.next = 3;
                  return _this3.cursor.next();

                case 3:
                  change = _context2.sent;
                  processedChange = _this3._processChange(change !== null && change !== void 0 ? change : null);
                  return _context2.abrupt("return", processedChange);

                case 8:
                  _context2.prev = 8;
                  _context2.t0 = _context2["catch"](0);
                  _context2.prev = 10;
                  _context2.next = 13;
                  return _this3._processErrorIteratorMode(_context2.t0);

                case 13:
                  _context2.next = 15;
                  return _this3.cursor.next();

                case 15:
                  _change = _context2.sent;
                  _processedChange = _this3._processChange(_change !== null && _change !== void 0 ? _change : null);
                  return _context2.abrupt("return", _processedChange);

                case 20:
                  _context2.prev = 20;
                  _context2.t1 = _context2["catch"](10);
                  _context2.next = 24;
                  return _this3.close()["catch"](function (err) {
                    return err;
                  });

                case 24:
                  throw _context2.t1;

                case 25:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[0, 8], [10, 20]]);
        }))().then(function (change) {
          return callback(undefined, change);
        }, function (error) {
          return callback(error);
        });
      });
    }
  }, {
    key: "tryNext",
    value: function tryNext(callback) {
      var _this4 = this;

      this._setIsIterator(); // TOOD(NODE-4319): Add eslint rule preventing accidental variable shadowing
      // Shadowing is intentional here.  We want to override the `callback` variable
      // from the outer scope so that the inner scope doesn't accidentally call the wrong callback.


      return (0, utils_1.maybePromise)(callback, function (callback) {
        _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          var change, _change2;

          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.prev = 0;
                  _context3.next = 3;
                  return _this4.cursor.tryNext();

                case 3:
                  change = _context3.sent;
                  return _context3.abrupt("return", change !== null && change !== void 0 ? change : null);

                case 7:
                  _context3.prev = 7;
                  _context3.t0 = _context3["catch"](0);
                  _context3.prev = 9;
                  _context3.next = 12;
                  return _this4._processErrorIteratorMode(_context3.t0);

                case 12:
                  _context3.next = 14;
                  return _this4.cursor.tryNext();

                case 14:
                  _change2 = _context3.sent;
                  return _context3.abrupt("return", _change2 !== null && _change2 !== void 0 ? _change2 : null);

                case 18:
                  _context3.prev = 18;
                  _context3.t1 = _context3["catch"](9);
                  _context3.next = 22;
                  return _this4.close()["catch"](function (err) {
                    return err;
                  });

                case 22:
                  throw _context3.t1;

                case 23:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, null, [[0, 7], [9, 18]]);
        }))().then(function (change) {
          return callback(undefined, change);
        }, function (error) {
          return callback(error);
        });
      });
    }
    /** Is the cursor closed */

  }, {
    key: "closed",
    get: function get() {
      return this[kClosed] || this.cursor.closed;
    }
  }, {
    key: "close",
    value: function close(callback) {
      var _this5 = this;

      this[kClosed] = true;
      return (0, utils_1.maybePromise)(callback, function (cb) {
        var cursor = _this5.cursor;
        return cursor.close(function (err) {
          _this5._endStream();

          return cb(err);
        });
      });
    }
    /**
     * Return a modified Readable stream including a possible transform method.
     *
     * NOTE: When using a Stream to process change stream events, the stream will
     * NOT automatically resume in the case a resumable error is encountered.
     *
     * @throws MongoChangeStreamError if the underlying cursor or the change stream is closed
     */

  }, {
    key: "stream",
    value: function stream(options) {
      if (this.closed) {
        throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
      }

      this.streamOptions = options;
      return this.cursor.stream(options);
    }
    /** @internal */

  }, {
    key: "_setIsEmitter",
    value: function _setIsEmitter() {
      if (this[kMode] === 'iterator') {
        // TODO(NODE-3485): Replace with MongoChangeStreamModeError
        throw new error_1.MongoAPIError('ChangeStream cannot be used as an EventEmitter after being used as an iterator');
      }

      this[kMode] = 'emitter';
    }
    /** @internal */

  }, {
    key: "_setIsIterator",
    value: function _setIsIterator() {
      if (this[kMode] === 'emitter') {
        // TODO(NODE-3485): Replace with MongoChangeStreamModeError
        throw new error_1.MongoAPIError('ChangeStream cannot be used as an iterator after being used as an EventEmitter');
      }

      this[kMode] = 'iterator';
    }
    /**
     * Create a new change stream cursor based on self's configuration
     * @internal
     */

  }, {
    key: "_createChangeStreamCursor",
    value: function _createChangeStreamCursor(options) {
      var _this6 = this;

      var changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);

      if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }

      var pipeline = [{
        $changeStream: changeStreamStageOptions
      }].concat(_toConsumableArray(this.pipeline));
      var client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER ? this.parent : this.type === CHANGE_DOMAIN_TYPES.DATABASE ? this.parent.s.client : this.type === CHANGE_DOMAIN_TYPES.COLLECTION ? this.parent.s.db.s.client : null;

      if (client == null) {
        // This should never happen because of the assertion in the constructor
        throw new error_1.MongoRuntimeError("Changestream type should only be one of cluster, database, collection. Found ".concat(this.type.toString()));
      }

      var changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline, options);

      var _iterator = _createForOfIteratorHelper(CHANGE_STREAM_EVENTS),
          _step;

      try {
        var _loop = function _loop() {
          var event = _step.value;
          changeStreamCursor.on(event, function (e) {
            return _this6.emit(event, e);
          });
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (this.listenerCount(ChangeStream.CHANGE) > 0) {
        this._streamEvents(changeStreamCursor);
      }

      return changeStreamCursor;
    }
    /** @internal */

  }, {
    key: "_closeEmitterModeWithError",
    value: function _closeEmitterModeWithError(error) {
      this.emit(ChangeStream.ERROR, error);
      this.close(function () {// nothing to do
      });
    }
    /** @internal */

  }, {
    key: "_streamEvents",
    value: function _streamEvents(cursor) {
      var _this7 = this;

      var _a;

      this._setIsEmitter();

      var stream = (_a = this[kCursorStream]) !== null && _a !== void 0 ? _a : cursor.stream();
      this[kCursorStream] = stream;
      stream.on('data', function (change) {
        try {
          var processedChange = _this7._processChange(change);

          _this7.emit(ChangeStream.CHANGE, processedChange);
        } catch (error) {
          _this7.emit(ChangeStream.ERROR, error);
        }
      });
      stream.on('error', function (error) {
        return _this7._processErrorStreamMode(error);
      });
    }
    /** @internal */

  }, {
    key: "_endStream",
    value: function _endStream() {
      var cursorStream = this[kCursorStream];

      if (cursorStream) {
        ['data', 'close', 'end', 'error'].forEach(function (event) {
          return cursorStream.removeAllListeners(event);
        });
        cursorStream.destroy();
      }

      this[kCursorStream] = undefined;
    }
    /** @internal */

  }, {
    key: "_processChange",
    value: function _processChange(change) {
      if (this[kClosed]) {
        // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      } // a null change means the cursor has been notified, implicitly closing the change stream


      if (change == null) {
        // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
        throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
      }

      if (change && !change._id) {
        throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
      } // cache the resume token


      this.cursor.cacheResumeToken(change._id); // wipe the startAtOperationTime if there was one so that there won't be a conflict
      // between resumeToken and startAtOperationTime if we need to reconnect the cursor

      this.options.startAtOperationTime = undefined;
      return change;
    }
    /** @internal */

  }, {
    key: "_processErrorStreamMode",
    value: function _processErrorStreamMode(changeStreamError) {
      var _this8 = this;

      // If the change stream has been closed explicitly, do not process error.
      if (this[kClosed]) return;

      if ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
        this._endStream();

        this.cursor.close()["catch"](function () {
          return null;
        });
        var topology = (0, utils_1.getTopology)(this.parent);
        topology.selectServer(this.cursor.readPreference, {}, function (serverSelectionError) {
          if (serverSelectionError) return _this8._closeEmitterModeWithError(changeStreamError);
          _this8.cursor = _this8._createChangeStreamCursor(_this8.cursor.resumeOptions);
        });
      } else {
        this._closeEmitterModeWithError(changeStreamError);
      }
    }
    /** @internal */

  }, {
    key: "_processErrorIteratorModeCallback",
    value: function _processErrorIteratorModeCallback(changeStreamError, callback) {
      var _this9 = this;

      if (this[kClosed]) {
        // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
        return callback(new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR));
      }

      if ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
        this.cursor.close()["catch"](function () {
          return null;
        });
        var topology = (0, utils_1.getTopology)(this.parent);
        topology.selectServer(this.cursor.readPreference, {}, function (serverSelectionError) {
          // if the topology can't reconnect, close the stream
          if (serverSelectionError) return _this9.close(function () {
            return callback(changeStreamError);
          });
          _this9.cursor = _this9._createChangeStreamCursor(_this9.cursor.resumeOptions);
          callback();
        });
      } else {
        this.close(function () {
          return callback(changeStreamError);
        });
      }
    }
  }]);

  return ChangeStream;
}(mongo_types_1.TypedEventEmitter);

exports.ChangeStream = ChangeStream;
/** @event */

ChangeStream.RESPONSE = constants_1.RESPONSE;
/** @event */

ChangeStream.MORE = constants_1.MORE;
/** @event */

ChangeStream.INIT = constants_1.INIT;
/** @event */

ChangeStream.CLOSE = constants_1.CLOSE;
/**
 * Fired for each new matching change in the specified namespace. Attaching a `change`
 * event listener to a Change Stream will switch the stream into flowing mode. Data will
 * then be passed as soon as it is available.
 * @event
 */

ChangeStream.CHANGE = constants_1.CHANGE;
/** @event */

ChangeStream.END = constants_1.END;
/** @event */

ChangeStream.ERROR = constants_1.ERROR;
/**
 * Emitted each time the change stream stores a new resume token.
 * @event
 */

ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;

/***/ }),

/***/ 4629:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AuthProvider = exports.AuthContext = void 0;

var error_1 = __webpack_require__(9271);
/** Context used during authentication */


var AuthContext = /*#__PURE__*/_createClass(function AuthContext(connection, credentials, options) {
  _classCallCheck(this, AuthContext);

  this.connection = connection;
  this.credentials = credentials;
  this.options = options;
});

exports.AuthContext = AuthContext;

var AuthProvider = /*#__PURE__*/function () {
  function AuthProvider() {
    _classCallCheck(this, AuthProvider);
  }

  _createClass(AuthProvider, [{
    key: "prepare",
    value:
    /**
     * Prepare the handshake document before the initial handshake.
     *
     * @param handshakeDoc - The document used for the initial handshake on a connection
     * @param authContext - Context for authentication flow
     */
    function prepare(handshakeDoc, authContext, callback) {
      callback(undefined, handshakeDoc);
    }
    /**
     * Authenticate
     *
     * @param context - A shared context for authentication flow
     * @param callback - The callback to return the result from the authentication
     */

  }, {
    key: "auth",
    value: function auth(context, callback) {
      // TODO(NODE-3483): Replace this with MongoMethodOverrideError
      callback(new error_1.MongoRuntimeError('`auth` method must be overridden by subclass'));
    }
  }]);

  return AuthProvider;
}();

exports.AuthProvider = AuthProvider;

/***/ }),

/***/ 8211:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;

var dns = __webpack_require__(9523);

var deps_1 = __webpack_require__(2524);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var auth_provider_1 = __webpack_require__(4629);
/** @public */


exports.GSSAPICanonicalizationValue = Object.freeze({
  on: true,
  off: false,
  none: 'none',
  forward: 'forward',
  forwardAndReverse: 'forwardAndReverse'
});

var GSSAPI = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(GSSAPI, _auth_provider_1$Auth);

  var _super = _createSuper(GSSAPI);

  function GSSAPI() {
    _classCallCheck(this, GSSAPI);

    return _super.apply(this, arguments);
  }

  _createClass(GSSAPI, [{
    key: "auth",
    value: function auth(authContext, callback) {
      var connection = authContext.connection,
          credentials = authContext.credentials;
      if (credentials == null) return callback(new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication'));
      var username = credentials.username;

      function externalCommand(command, cb) {
        return connection.command((0, utils_1.ns)('$external.$cmd'), command, undefined, cb);
      }

      makeKerberosClient(authContext, function (err, client) {
        if (err) return callback(err);
        if (client == null) return callback(new error_1.MongoMissingDependencyError('GSSAPI client missing'));
        client.step('', function (err, payload) {
          if (err) return callback(err);
          externalCommand(saslStart(payload), function (err, result) {
            if (err) return callback(err);
            if (result == null) return callback();
            negotiate(client, 10, result.payload, function (err, payload) {
              if (err) return callback(err);
              externalCommand(saslContinue(payload, result.conversationId), function (err, result) {
                if (err) return callback(err);
                if (result == null) return callback();
                finalize(client, username, result.payload, function (err, payload) {
                  if (err) return callback(err);
                  externalCommand({
                    saslContinue: 1,
                    conversationId: result.conversationId,
                    payload: payload
                  }, function (err, result) {
                    if (err) return callback(err);
                    callback(undefined, result);
                  });
                });
              });
            });
          });
        });
      });
    }
  }]);

  return GSSAPI;
}(auth_provider_1.AuthProvider);

exports.GSSAPI = GSSAPI;

function makeKerberosClient(authContext, callback) {
  var _a;

  var hostAddress = authContext.options.hostAddress;
  var credentials = authContext.credentials;

  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {
    return callback(new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.'));
  }

  if ('kModuleError' in deps_1.Kerberos) {
    return callback(deps_1.Kerberos['kModuleError']);
  }

  var initializeClient = deps_1.Kerberos.initializeClient;
  var username = credentials.username,
      password = credentials.password;
  var mechanismProperties = credentials.mechanismProperties;
  var serviceName = (_a = mechanismProperties.SERVICE_NAME) !== null && _a !== void 0 ? _a : 'mongodb';
  performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties, function (err, host) {
    var _a;

    if (err) return callback(err);
    var initOptions = {};

    if (password != null) {
      Object.assign(initOptions, {
        user: username,
        password: password
      });
    }

    var spnHost = (_a = mechanismProperties.SERVICE_HOST) !== null && _a !== void 0 ? _a : host;
    var spn = "".concat(serviceName).concat(process.platform === 'win32' ? '/' : '@').concat(spnHost);

    if ('SERVICE_REALM' in mechanismProperties) {
      spn = "".concat(spn, "@").concat(mechanismProperties.SERVICE_REALM);
    }

    initializeClient(spn, initOptions, function (err, client) {
      // TODO(NODE-3483)
      if (err) return callback(new error_1.MongoRuntimeError(err));
      callback(undefined, client);
    });
  });
}

function saslStart(payload) {
  return {
    saslStart: 1,
    mechanism: 'GSSAPI',
    payload: payload,
    autoAuthorize: 1
  };
}

function saslContinue(payload, conversationId) {
  return {
    saslContinue: 1,
    conversationId: conversationId,
    payload: payload
  };
}

function negotiate(client, retries, payload, callback) {
  client.step(payload, function (err, response) {
    // Retries exhausted, raise error
    if (err && retries === 0) return callback(err); // Adjust number of retries and call step again

    if (err) return negotiate(client, retries - 1, payload, callback); // Return the payload

    callback(undefined, response || '');
  });
}

function finalize(client, user, payload, callback) {
  // GSS Client Unwrap
  client.unwrap(payload, function (err, response) {
    if (err) return callback(err); // Wrap the response

    client.wrap(response || '', {
      user: user
    }, function (err, wrapped) {
      if (err) return callback(err); // Return the payload

      callback(undefined, wrapped);
    });
  });
}

function performGSSAPICanonicalizeHostName(host, mechanismProperties, callback) {
  var mode = mechanismProperties.CANONICALIZE_HOST_NAME;

  if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {
    return callback(undefined, host);
  } // If forward and reverse or true


  if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {
    // Perform the lookup of the ip address.
    dns.lookup(host, function (error, address) {
      // No ip found, return the error.
      if (error) return callback(error); // Perform a reverse ptr lookup on the ip address.

      dns.resolvePtr(address, function (err, results) {
        // This can error as ptr records may not exist for all ips. In this case
        // fallback to a cname lookup as dns.lookup() does not return the
        // cname.
        if (err) {
          return resolveCname(host, callback);
        } // If the ptr did not error but had no results, return the host.


        callback(undefined, results.length > 0 ? results[0] : host);
      });
    });
  } else {
    // The case for forward is just to resolve the cname as dns.lookup()
    // will not return it.
    resolveCname(host, callback);
  }
}

exports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;

function resolveCname(host, callback) {
  // Attempt to resolve the host name
  dns.resolveCname(host, function (err, r) {
    if (err) return callback(undefined, host); // Get the first resolve host id

    if (r.length > 0) {
      return callback(undefined, r[0]);
    }

    callback(undefined, host);
  });
}

exports.resolveCname = resolveCname;

/***/ }),

/***/ 8302:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoCredentials = void 0;

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var gssapi_1 = __webpack_require__(8211);

var providers_1 = __webpack_require__(2581); // https://github.com/mongodb/specifications/blob/master/source/auth/auth.rst


function getDefaultAuthMechanism(hello) {
  if (hello) {
    // If hello contains saslSupportedMechs, use scram-sha-256
    // if it is available, else scram-sha-1
    if (Array.isArray(hello.saslSupportedMechs)) {
      return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
    } // Fallback to legacy selection method. If wire version >= 3, use scram-sha-1


    if (hello.maxWireVersion >= 3) {
      return providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
    }
  } // Default for wireprotocol < 3


  return providers_1.AuthMechanism.MONGODB_CR;
}
/**
 * A representation of the credentials used by MongoDB
 * @public
 */


var MongoCredentials = /*#__PURE__*/function () {
  function MongoCredentials(options) {
    _classCallCheck(this, MongoCredentials);

    this.username = options.username;
    this.password = options.password;
    this.source = options.source;

    if (!this.source && options.db) {
      this.source = options.db;
    }

    this.mechanism = options.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
    this.mechanismProperties = options.mechanismProperties || {};

    if (this.mechanism.match(/MONGODB-AWS/i)) {
      if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
        this.username = process.env.AWS_ACCESS_KEY_ID;
      }

      if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
        this.password = process.env.AWS_SECRET_ACCESS_KEY;
      }

      if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
        this.mechanismProperties = _objectSpread(_objectSpread({}, this.mechanismProperties), {}, {
          AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
        });
      }
    }

    if ('gssapiCanonicalizeHostName' in this.mechanismProperties) {
      (0, utils_1.emitWarningOnce)('gssapiCanonicalizeHostName is deprecated. Please use CANONICALIZE_HOST_NAME instead.');
      this.mechanismProperties.CANONICALIZE_HOST_NAME = this.mechanismProperties.gssapiCanonicalizeHostName;
    }

    Object.freeze(this.mechanismProperties);
    Object.freeze(this);
  }
  /** Determines if two MongoCredentials objects are equivalent */


  _createClass(MongoCredentials, [{
    key: "equals",
    value: function equals(other) {
      return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
    }
    /**
     * If the authentication mechanism is set to "default", resolves the authMechanism
     * based on the server version and server supported sasl mechanisms.
     *
     * @param hello - A hello response from the server
     */

  }, {
    key: "resolveAuthMechanism",
    value: function resolveAuthMechanism(hello) {
      // If the mechanism is not "default", then it does not need to be resolved
      if (this.mechanism.match(/DEFAULT/i)) {
        return new MongoCredentials({
          username: this.username,
          password: this.password,
          source: this.source,
          mechanism: getDefaultAuthMechanism(hello),
          mechanismProperties: this.mechanismProperties
        });
      }

      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var _a;

      if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI || this.mechanism === providers_1.AuthMechanism.MONGODB_CR || this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) && !this.username) {
        throw new error_1.MongoMissingCredentialsError("Username required for mechanism '".concat(this.mechanism, "'"));
      }

      if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
        if (this.source != null && this.source !== '$external') {
          // TODO(NODE-3485): Replace this with a MongoAuthValidationError
          throw new error_1.MongoAPIError("Invalid source '".concat(this.source, "' for mechanism '").concat(this.mechanism, "' specified."));
        }
      }

      if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
        // TODO(NODE-3485): Replace this with a MongoAuthValidationError
        throw new error_1.MongoAPIError('PLAIN Authentication Mechanism needs an auth source');
      }

      if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
        if (this.password === '') {
          Reflect.set(this, 'password', undefined);
          return;
        } // TODO(NODE-3485): Replace this with a MongoAuthValidationError


        throw new error_1.MongoAPIError("Password not allowed for mechanism MONGODB-X509");
      }

      var canonicalization = (_a = this.mechanismProperties.CANONICALIZE_HOST_NAME) !== null && _a !== void 0 ? _a : false;

      if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
        throw new error_1.MongoAPIError("Invalid CANONICALIZE_HOST_NAME value: ".concat(canonicalization));
      }
    }
  }], [{
    key: "merge",
    value: function merge(creds, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;

      return new MongoCredentials({
        username: (_b = (_a = options.username) !== null && _a !== void 0 ? _a : creds === null || creds === void 0 ? void 0 : creds.username) !== null && _b !== void 0 ? _b : '',
        password: (_d = (_c = options.password) !== null && _c !== void 0 ? _c : creds === null || creds === void 0 ? void 0 : creds.password) !== null && _d !== void 0 ? _d : '',
        mechanism: (_f = (_e = options.mechanism) !== null && _e !== void 0 ? _e : creds === null || creds === void 0 ? void 0 : creds.mechanism) !== null && _f !== void 0 ? _f : providers_1.AuthMechanism.MONGODB_DEFAULT,
        mechanismProperties: (_h = (_g = options.mechanismProperties) !== null && _g !== void 0 ? _g : creds === null || creds === void 0 ? void 0 : creds.mechanismProperties) !== null && _h !== void 0 ? _h : {},
        source: (_l = (_k = (_j = options.source) !== null && _j !== void 0 ? _j : options.db) !== null && _k !== void 0 ? _k : creds === null || creds === void 0 ? void 0 : creds.source) !== null && _l !== void 0 ? _l : 'admin'
      });
    }
  }]);

  return MongoCredentials;
}();

exports.MongoCredentials = MongoCredentials;

/***/ }),

/***/ 2778:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoCR = void 0;

var crypto = __webpack_require__(6113);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var auth_provider_1 = __webpack_require__(4629);

var MongoCR = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(MongoCR, _auth_provider_1$Auth);

  var _super = _createSuper(MongoCR);

  function MongoCR() {
    _classCallCheck(this, MongoCR);

    return _super.apply(this, arguments);
  }

  _createClass(MongoCR, [{
    key: "auth",
    value: function auth(authContext, callback) {
      var connection = authContext.connection,
          credentials = authContext.credentials;

      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));
      }

      var username = credentials.username;
      var password = credentials.password;
      var source = credentials.source;
      connection.command((0, utils_1.ns)("".concat(source, ".$cmd")), {
        getnonce: 1
      }, undefined, function (err, r) {
        var nonce = null;
        var key = null; // Get nonce

        if (err == null) {
          nonce = r.nonce; // Use node md5 generator

          var md5 = crypto.createHash('md5'); // Generate keys used for authentication

          md5.update("".concat(username, ":mongo:").concat(password), 'utf8');
          var hash_password = md5.digest('hex'); // Final key

          md5 = crypto.createHash('md5');
          md5.update(nonce + username + hash_password, 'utf8');
          key = md5.digest('hex');
        }

        var authenticateCommand = {
          authenticate: 1,
          user: username,
          nonce: nonce,
          key: key
        };
        connection.command((0, utils_1.ns)("".concat(source, ".$cmd")), authenticateCommand, undefined, callback);
      });
    }
  }]);

  return MongoCR;
}(auth_provider_1.AuthProvider);

exports.MongoCR = MongoCR;

/***/ }),

/***/ 130:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoDBAWS = void 0;

var crypto = __webpack_require__(6113);

var http = __webpack_require__(3685);

var url = __webpack_require__(7310);

var BSON = __webpack_require__(53);

var deps_1 = __webpack_require__(2524);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var auth_provider_1 = __webpack_require__(4629);

var mongo_credentials_1 = __webpack_require__(8302);

var providers_1 = __webpack_require__(2581);

var ASCII_N = 110;
var AWS_RELATIVE_URI = 'http://169.254.170.2';
var AWS_EC2_URI = 'http://169.254.169.254';
var AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';
var bsonOptions = {
  promoteLongs: true,
  promoteValues: true,
  promoteBuffers: false,
  bsonRegExp: false
};

var MongoDBAWS = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(MongoDBAWS, _auth_provider_1$Auth);

  var _super = _createSuper(MongoDBAWS);

  function MongoDBAWS() {
    _classCallCheck(this, MongoDBAWS);

    return _super.apply(this, arguments);
  }

  _createClass(MongoDBAWS, [{
    key: "auth",
    value: function auth(authContext, callback) {
      var _this = this;

      var connection = authContext.connection,
          credentials = authContext.credentials;

      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));
      }

      if ('kModuleError' in deps_1.aws4) {
        return callback(deps_1.aws4['kModuleError']);
      }

      var sign = deps_1.aws4.sign;

      if ((0, utils_1.maxWireVersion)(connection) < 9) {
        callback(new error_1.MongoCompatibilityError('MONGODB-AWS authentication requires MongoDB version 4.4 or later'));
        return;
      }

      if (!credentials.username) {
        makeTempCredentials(credentials, function (err, tempCredentials) {
          if (err || !tempCredentials) return callback(err);
          authContext.credentials = tempCredentials;

          _this.auth(authContext, callback);
        });
        return;
      }

      var accessKeyId = credentials.username;
      var secretAccessKey = credentials.password;
      var sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN; // If all three defined, include sessionToken, else include username and pass, else no credentials

      var awsCredentials = accessKeyId && secretAccessKey && sessionToken ? {
        accessKeyId: accessKeyId,
        secretAccessKey: secretAccessKey,
        sessionToken: sessionToken
      } : accessKeyId && secretAccessKey ? {
        accessKeyId: accessKeyId,
        secretAccessKey: secretAccessKey
      } : undefined;
      var db = credentials.source;
      crypto.randomBytes(32, function (err, nonce) {
        if (err) {
          callback(err);
          return;
        }

        var saslStart = {
          saslStart: 1,
          mechanism: 'MONGODB-AWS',
          payload: BSON.serialize({
            r: nonce,
            p: ASCII_N
          }, bsonOptions)
        };
        connection.command((0, utils_1.ns)("".concat(db, ".$cmd")), saslStart, undefined, function (err, res) {
          if (err) return callback(err);
          var serverResponse = BSON.deserialize(res.payload.buffer, bsonOptions);
          var host = serverResponse.h;
          var serverNonce = serverResponse.s.buffer;

          if (serverNonce.length !== 64) {
            callback( // TODO(NODE-3483)
            new error_1.MongoRuntimeError("Invalid server nonce length ".concat(serverNonce.length, ", expected 64")));
            return;
          }

          if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
            // TODO(NODE-3483)
            callback(new error_1.MongoRuntimeError('Server nonce does not begin with client nonce'));
            return;
          }

          if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {
            // TODO(NODE-3483)
            callback(new error_1.MongoRuntimeError("Server returned an invalid host: \"".concat(host, "\"")));
            return;
          }

          var body = 'Action=GetCallerIdentity&Version=2011-06-15';
          var options = sign({
            method: 'POST',
            host: host,
            region: deriveRegion(serverResponse.h),
            service: 'sts',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'Content-Length': body.length,
              'X-MongoDB-Server-Nonce': serverNonce.toString('base64'),
              'X-MongoDB-GS2-CB-Flag': 'n'
            },
            path: '/',
            body: body
          }, awsCredentials);
          var payload = {
            a: options.headers.Authorization,
            d: options.headers['X-Amz-Date']
          };

          if (sessionToken) {
            payload.t = sessionToken;
          }

          var saslContinue = {
            saslContinue: 1,
            conversationId: 1,
            payload: BSON.serialize(payload, bsonOptions)
          };
          connection.command((0, utils_1.ns)("".concat(db, ".$cmd")), saslContinue, undefined, callback);
        });
      });
    }
  }]);

  return MongoDBAWS;
}(auth_provider_1.AuthProvider);

exports.MongoDBAWS = MongoDBAWS;

function makeTempCredentials(credentials, callback) {
  function done(creds) {
    if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {
      callback(new error_1.MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials'));
      return;
    }

    callback(undefined, new mongo_credentials_1.MongoCredentials({
      username: creds.AccessKeyId,
      password: creds.SecretAccessKey,
      source: credentials.source,
      mechanism: providers_1.AuthMechanism.MONGODB_AWS,
      mechanismProperties: {
        AWS_SESSION_TOKEN: creds.Token
      }
    }));
  } // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI
  // is set then drivers MUST assume that it was set by an AWS ECS agent


  if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
    request("".concat(AWS_RELATIVE_URI).concat(process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI), undefined, function (err, res) {
      if (err) return callback(err);
      done(res);
    });
    return;
  } // Otherwise assume we are on an EC2 instance
  // get a token


  request("".concat(AWS_EC2_URI, "/latest/api/token"), {
    method: 'PUT',
    json: false,
    headers: {
      'X-aws-ec2-metadata-token-ttl-seconds': 30
    }
  }, function (err, token) {
    if (err) return callback(err); // get role name

    request("".concat(AWS_EC2_URI, "/").concat(AWS_EC2_PATH), {
      json: false,
      headers: {
        'X-aws-ec2-metadata-token': token
      }
    }, function (err, roleName) {
      if (err) return callback(err); // get temp credentials

      request("".concat(AWS_EC2_URI, "/").concat(AWS_EC2_PATH, "/").concat(roleName), {
        headers: {
          'X-aws-ec2-metadata-token': token
        }
      }, function (err, creds) {
        if (err) return callback(err);
        done(creds);
      });
    });
  });
}

function deriveRegion(host) {
  var parts = host.split('.');

  if (parts.length === 1 || parts[1] === 'amazonaws') {
    return 'us-east-1';
  }

  return parts[1];
}

function request(uri, _options, callback) {
  var options = Object.assign({
    method: 'GET',
    timeout: 10000,
    json: true
  }, url.parse(uri), _options);
  var req = http.request(options, function (res) {
    res.setEncoding('utf8');
    var data = '';
    res.on('data', function (d) {
      return data += d;
    });
    res.on('end', function () {
      if (options.json === false) {
        callback(undefined, data);
        return;
      }

      try {
        var parsed = JSON.parse(data);
        callback(undefined, parsed);
      } catch (err) {
        // TODO(NODE-3483)
        callback(new error_1.MongoRuntimeError("Invalid JSON response: \"".concat(data, "\"")));
      }
    });
  });
  req.on('timeout', function () {
    req.destroy(new error_1.MongoAWSError("AWS request to ".concat(uri, " timed out after ").concat(options.timeout, " ms")));
  });
  req.on('error', function (err) {
    return callback(err);
  });
  req.end();
}

/***/ }),

/***/ 313:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Plain = void 0;

var bson_1 = __webpack_require__(53);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var auth_provider_1 = __webpack_require__(4629);

var Plain = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(Plain, _auth_provider_1$Auth);

  var _super = _createSuper(Plain);

  function Plain() {
    _classCallCheck(this, Plain);

    return _super.apply(this, arguments);
  }

  _createClass(Plain, [{
    key: "auth",
    value: function auth(authContext, callback) {
      var connection = authContext.connection,
          credentials = authContext.credentials;

      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));
      }

      var username = credentials.username;
      var password = credentials.password;
      var payload = new bson_1.Binary(Buffer.from("\0".concat(username, "\0").concat(password)));
      var command = {
        saslStart: 1,
        mechanism: 'PLAIN',
        payload: payload,
        autoAuthorize: 1
      };
      connection.command((0, utils_1.ns)('$external.$cmd'), command, undefined, callback);
    }
  }]);

  return Plain;
}(auth_provider_1.AuthProvider);

exports.Plain = Plain;

/***/ }),

/***/ 2581:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports.AuthMechanism = void 0;
/** @public */

exports.AuthMechanism = Object.freeze({
  MONGODB_AWS: 'MONGODB-AWS',
  MONGODB_CR: 'MONGODB-CR',
  MONGODB_DEFAULT: 'DEFAULT',
  MONGODB_GSSAPI: 'GSSAPI',
  MONGODB_PLAIN: 'PLAIN',
  MONGODB_SCRAM_SHA1: 'SCRAM-SHA-1',
  MONGODB_SCRAM_SHA256: 'SCRAM-SHA-256',
  MONGODB_X509: 'MONGODB-X509'
});
/** @internal */

exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = new Set([exports.AuthMechanism.MONGODB_GSSAPI, exports.AuthMechanism.MONGODB_AWS, exports.AuthMechanism.MONGODB_X509]);

/***/ }),

/***/ 4788:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ScramSHA256 = exports.ScramSHA1 = void 0;

var crypto = __webpack_require__(6113);

var bson_1 = __webpack_require__(53);

var deps_1 = __webpack_require__(2524);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var auth_provider_1 = __webpack_require__(4629);

var providers_1 = __webpack_require__(2581);

var ScramSHA = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(ScramSHA, _auth_provider_1$Auth);

  var _super = _createSuper(ScramSHA);

  function ScramSHA(cryptoMethod) {
    var _this;

    _classCallCheck(this, ScramSHA);

    _this = _super.call(this);
    _this.cryptoMethod = cryptoMethod || 'sha1';
    return _this;
  }

  _createClass(ScramSHA, [{
    key: "prepare",
    value: function prepare(handshakeDoc, authContext, callback) {
      var cryptoMethod = this.cryptoMethod;
      var credentials = authContext.credentials;

      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));
      }

      if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {
        (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');
      }

      crypto.randomBytes(24, function (err, nonce) {
        if (err) {
          return callback(err);
        } // store the nonce for later use


        Object.assign(authContext, {
          nonce: nonce
        });
        var request = Object.assign({}, handshakeDoc, {
          speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
            db: credentials.source
          })
        });
        callback(undefined, request);
      });
    }
  }, {
    key: "auth",
    value: function auth(authContext, callback) {
      var response = authContext.response;

      if (response && response.speculativeAuthenticate) {
        continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
        return;
      }

      executeScram(this.cryptoMethod, authContext, callback);
    }
  }]);

  return ScramSHA;
}(auth_provider_1.AuthProvider);

function cleanUsername(username) {
  return username.replace('=', '=3D').replace(',', '=2C');
}

function clientFirstMessageBare(username, nonce) {
  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
  // Since the username is not sasl-prep-d, we need to do this here.
  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);
}

function makeFirstMessage(cryptoMethod, credentials, nonce) {
  var username = cleanUsername(credentials.username);
  var mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
  // Since the username is not sasl-prep-d, we need to do this here.

  return {
    saslStart: 1,
    mechanism: mechanism,
    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),
    autoAuthorize: 1,
    options: {
      skipEmptyExchange: true
    }
  };
}

function executeScram(cryptoMethod, authContext, callback) {
  var connection = authContext.connection,
      credentials = authContext.credentials;

  if (!credentials) {
    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));
  }

  if (!authContext.nonce) {
    return callback(new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property'));
  }

  var nonce = authContext.nonce;
  var db = credentials.source;
  var saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
  connection.command((0, utils_1.ns)("".concat(db, ".$cmd")), saslStartCmd, undefined, function (_err, result) {
    var err = resolveError(_err, result);

    if (err) {
      return callback(err);
    }

    continueScramConversation(cryptoMethod, result, authContext, callback);
  });
}

function continueScramConversation(cryptoMethod, response, authContext, callback) {
  var connection = authContext.connection;
  var credentials = authContext.credentials;

  if (!credentials) {
    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));
  }

  if (!authContext.nonce) {
    return callback(new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));
  }

  var nonce = authContext.nonce;
  var db = credentials.source;
  var username = cleanUsername(credentials.username);
  var password = credentials.password;
  var processedPassword;

  if (cryptoMethod === 'sha256') {
    processedPassword = 'kModuleError' in deps_1.saslprep ? password : (0, deps_1.saslprep)(password);
  } else {
    try {
      processedPassword = passwordDigest(username, password);
    } catch (e) {
      return callback(e);
    }
  }

  var payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;
  var dict = parsePayload(payload.value());
  var iterations = parseInt(dict.i, 10);

  if (iterations && iterations < 4096) {
    callback( // TODO(NODE-3483)
    new error_1.MongoRuntimeError("Server returned an invalid iteration count ".concat(iterations)), false);
    return;
  }

  var salt = dict.s;
  var rnonce = dict.r;

  if (rnonce.startsWith('nonce')) {
    // TODO(NODE-3483)
    callback(new error_1.MongoRuntimeError("Server returned an invalid nonce: ".concat(rnonce)), false);
    return;
  } // Set up start of proof


  var withoutProof = "c=biws,r=".concat(rnonce);
  var saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);
  var clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');
  var serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');
  var storedKey = H(cryptoMethod, clientKey);
  var authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');
  var clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
  var clientProof = "p=".concat(xor(clientKey, clientSignature));
  var clientFinal = [withoutProof, clientProof].join(',');
  var serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
  var saslContinueCmd = {
    saslContinue: 1,
    conversationId: response.conversationId,
    payload: new bson_1.Binary(Buffer.from(clientFinal))
  };
  connection.command((0, utils_1.ns)("".concat(db, ".$cmd")), saslContinueCmd, undefined, function (_err, r) {
    var err = resolveError(_err, r);

    if (err) {
      return callback(err);
    }

    var parsedResponse = parsePayload(r.payload.value());

    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {
      callback(new error_1.MongoRuntimeError('Server returned an invalid signature'));
      return;
    }

    if (!r || r.done !== false) {
      return callback(err, r);
    }

    var retrySaslContinueCmd = {
      saslContinue: 1,
      conversationId: r.conversationId,
      payload: Buffer.alloc(0)
    };
    connection.command((0, utils_1.ns)("".concat(db, ".$cmd")), retrySaslContinueCmd, undefined, callback);
  });
}

function parsePayload(payload) {
  var dict = {};
  var parts = payload.split(',');

  for (var i = 0; i < parts.length; i++) {
    var valueParts = parts[i].split('=');
    dict[valueParts[0]] = valueParts[1];
  }

  return dict;
}

function passwordDigest(username, password) {
  if (typeof username !== 'string') {
    throw new error_1.MongoInvalidArgumentError('Username must be a string');
  }

  if (typeof password !== 'string') {
    throw new error_1.MongoInvalidArgumentError('Password must be a string');
  }

  if (password.length === 0) {
    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');
  }

  var md5;

  try {
    md5 = crypto.createHash('md5');
  } catch (err) {
    if (crypto.getFips()) {
      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.
      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'
      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');
    }

    throw err;
  }

  md5.update("".concat(username, ":mongo:").concat(password), 'utf8');
  return md5.digest('hex');
} // XOR two buffers


function xor(a, b) {
  if (!Buffer.isBuffer(a)) {
    a = Buffer.from(a);
  }

  if (!Buffer.isBuffer(b)) {
    b = Buffer.from(b);
  }

  var length = Math.max(a.length, b.length);
  var res = [];

  for (var i = 0; i < length; i += 1) {
    res.push(a[i] ^ b[i]);
  }

  return Buffer.from(res).toString('base64');
}

function H(method, text) {
  return crypto.createHash(method).update(text).digest();
}

function HMAC(method, key, text) {
  return crypto.createHmac(method, key).update(text).digest();
}

var _hiCache = {};
var _hiCacheCount = 0;

function _hiCachePurge() {
  _hiCache = {};
  _hiCacheCount = 0;
}

var hiLengthMap = {
  sha256: 32,
  sha1: 20
};

function HI(data, salt, iterations, cryptoMethod) {
  // omit the work if already generated
  var key = [data, salt.toString('base64'), iterations].join('_');

  if (_hiCache[key] != null) {
    return _hiCache[key];
  } // generate the salt


  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth

  if (_hiCacheCount >= 200) {
    _hiCachePurge();
  }

  _hiCache[key] = saltedData;
  _hiCacheCount += 1;
  return saltedData;
}

function compareDigest(lhs, rhs) {
  if (lhs.length !== rhs.length) {
    return false;
  }

  if (typeof crypto.timingSafeEqual === 'function') {
    return crypto.timingSafeEqual(lhs, rhs);
  }

  var result = 0;

  for (var i = 0; i < lhs.length; i++) {
    result |= lhs[i] ^ rhs[i];
  }

  return result === 0;
}

function resolveError(err, result) {
  if (err) return err;

  if (result) {
    if (result.$err || result.errmsg) return new error_1.MongoServerError(result);
  }

  return;
}

var ScramSHA1 = /*#__PURE__*/function (_ScramSHA) {
  _inherits(ScramSHA1, _ScramSHA);

  var _super2 = _createSuper(ScramSHA1);

  function ScramSHA1() {
    _classCallCheck(this, ScramSHA1);

    return _super2.call(this, 'sha1');
  }

  return _createClass(ScramSHA1);
}(ScramSHA);

exports.ScramSHA1 = ScramSHA1;

var ScramSHA256 = /*#__PURE__*/function (_ScramSHA2) {
  _inherits(ScramSHA256, _ScramSHA2);

  var _super3 = _createSuper(ScramSHA256);

  function ScramSHA256() {
    _classCallCheck(this, ScramSHA256);

    return _super3.call(this, 'sha256');
  }

  return _createClass(ScramSHA256);
}(ScramSHA);

exports.ScramSHA256 = ScramSHA256;

/***/ }),

/***/ 3190:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.X509 = void 0;

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var auth_provider_1 = __webpack_require__(4629);

var X509 = /*#__PURE__*/function (_auth_provider_1$Auth) {
  _inherits(X509, _auth_provider_1$Auth);

  var _super = _createSuper(X509);

  function X509() {
    _classCallCheck(this, X509);

    return _super.apply(this, arguments);
  }

  _createClass(X509, [{
    key: "prepare",
    value: function prepare(handshakeDoc, authContext, callback) {
      var credentials = authContext.credentials;

      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));
      }

      Object.assign(handshakeDoc, {
        speculativeAuthenticate: x509AuthenticateCommand(credentials)
      });
      callback(undefined, handshakeDoc);
    }
  }, {
    key: "auth",
    value: function auth(authContext, callback) {
      var connection = authContext.connection;
      var credentials = authContext.credentials;

      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));
      }

      var response = authContext.response;

      if (response && response.speculativeAuthenticate) {
        return callback();
      }

      connection.command((0, utils_1.ns)('$external.$cmd'), x509AuthenticateCommand(credentials), undefined, callback);
    }
  }]);

  return X509;
}(auth_provider_1.AuthProvider);

exports.X509 = X509;

function x509AuthenticateCommand(credentials) {
  var command = {
    authenticate: 1,
    mechanism: 'MONGODB-X509'
  };

  if (credentials.username) {
    command.user = credentials.username;
  }

  return command;
}

/***/ }),

/***/ 8884:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;

var constants_1 = __webpack_require__(1254);

var utils_1 = __webpack_require__(4356);

var commands_1 = __webpack_require__(8338);
/**
 * An event indicating the start of a given
 * @public
 * @category Event
 */


var CommandStartedEvent = /*#__PURE__*/function () {
  /**
   * Create a started event
   *
   * @internal
   * @param pool - the pool that originated the command
   * @param command - the command
   */
  function CommandStartedEvent(connection, command) {
    _classCallCheck(this, CommandStartedEvent);

    var cmd = extractCommand(command);
    var commandName = extractCommandName(cmd);

    var _extractConnectionDet = extractConnectionDetails(connection),
        address = _extractConnectionDet.address,
        connectionId = _extractConnectionDet.connectionId,
        serviceId = _extractConnectionDet.serviceId; // TODO: remove in major revision, this is not spec behavior


    if (SENSITIVE_COMMANDS.has(commandName)) {
      this.commandObj = {};
      this.commandObj[commandName] = true;
    }

    this.address = address;
    this.connectionId = connectionId;
    this.serviceId = serviceId;
    this.requestId = command.requestId;
    this.databaseName = databaseName(command);
    this.commandName = commandName;
    this.command = maybeRedact(commandName, cmd, cmd);
  }
  /* @internal */


  _createClass(CommandStartedEvent, [{
    key: "hasServiceId",
    get: function get() {
      return !!this.serviceId;
    }
  }]);

  return CommandStartedEvent;
}();

exports.CommandStartedEvent = CommandStartedEvent;
/**
 * An event indicating the success of a given command
 * @public
 * @category Event
 */

var CommandSucceededEvent = /*#__PURE__*/function () {
  /**
   * Create a succeeded event
   *
   * @internal
   * @param pool - the pool that originated the command
   * @param command - the command
   * @param reply - the reply for this command from the server
   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
   */
  function CommandSucceededEvent(connection, command, reply, started) {
    _classCallCheck(this, CommandSucceededEvent);

    var cmd = extractCommand(command);
    var commandName = extractCommandName(cmd);

    var _extractConnectionDet2 = extractConnectionDetails(connection),
        address = _extractConnectionDet2.address,
        connectionId = _extractConnectionDet2.connectionId,
        serviceId = _extractConnectionDet2.serviceId;

    this.address = address;
    this.connectionId = connectionId;
    this.serviceId = serviceId;
    this.requestId = command.requestId;
    this.commandName = commandName;
    this.duration = (0, utils_1.calculateDurationInMs)(started);
    this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));
  }
  /* @internal */


  _createClass(CommandSucceededEvent, [{
    key: "hasServiceId",
    get: function get() {
      return !!this.serviceId;
    }
  }]);

  return CommandSucceededEvent;
}();

exports.CommandSucceededEvent = CommandSucceededEvent;
/**
 * An event indicating the failure of a given command
 * @public
 * @category Event
 */

var CommandFailedEvent = /*#__PURE__*/function () {
  /**
   * Create a failure event
   *
   * @internal
   * @param pool - the pool that originated the command
   * @param command - the command
   * @param error - the generated error or a server error response
   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
   */
  function CommandFailedEvent(connection, command, error, started) {
    _classCallCheck(this, CommandFailedEvent);

    var cmd = extractCommand(command);
    var commandName = extractCommandName(cmd);

    var _extractConnectionDet3 = extractConnectionDetails(connection),
        address = _extractConnectionDet3.address,
        connectionId = _extractConnectionDet3.connectionId,
        serviceId = _extractConnectionDet3.serviceId;

    this.address = address;
    this.connectionId = connectionId;
    this.serviceId = serviceId;
    this.requestId = command.requestId;
    this.commandName = commandName;
    this.duration = (0, utils_1.calculateDurationInMs)(started);
    this.failure = maybeRedact(commandName, cmd, error);
  }
  /* @internal */


  _createClass(CommandFailedEvent, [{
    key: "hasServiceId",
    get: function get() {
      return !!this.serviceId;
    }
  }]);

  return CommandFailedEvent;
}();

exports.CommandFailedEvent = CommandFailedEvent;
/** Commands that we want to redact because of the sensitive nature of their contents */

var SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']);
var HELLO_COMMANDS = new Set(['hello', constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]); // helper methods

var extractCommandName = function extractCommandName(commandDoc) {
  return Object.keys(commandDoc)[0];
};

var namespace = function namespace(command) {
  return command.ns;
};

var databaseName = function databaseName(command) {
  return command.ns.split('.')[0];
};

var collectionName = function collectionName(command) {
  return command.ns.split('.')[1];
};

var maybeRedact = function maybeRedact(commandName, commandDoc, result) {
  return SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;
};

var LEGACY_FIND_QUERY_MAP = {
  $query: 'filter',
  $orderby: 'sort',
  $hint: 'hint',
  $comment: 'comment',
  $maxScan: 'maxScan',
  $max: 'max',
  $min: 'min',
  $returnKey: 'returnKey',
  $showDiskLoc: 'showRecordId',
  $maxTimeMS: 'maxTimeMS',
  $snapshot: 'snapshot'
};
var LEGACY_FIND_OPTIONS_MAP = {
  numberToSkip: 'skip',
  numberToReturn: 'batchSize',
  returnFieldSelector: 'projection'
};
var OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];
/** Extract the actual command from the query, possibly up-converting if it's a legacy format */

function extractCommand(command) {
  var _a;

  if (command instanceof commands_1.Msg) {
    return (0, utils_1.deepCopy)(command.command);
  }

  if ((_a = command.query) === null || _a === void 0 ? void 0 : _a.$query) {
    var result;

    if (command.ns === 'admin.$cmd') {
      // up-convert legacy command
      result = Object.assign({}, command.query.$query);
    } else {
      // up-convert legacy find command
      result = {
        find: collectionName(command)
      };
      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(function (key) {
        if (command.query[key] != null) {
          result[LEGACY_FIND_QUERY_MAP[key]] = (0, utils_1.deepCopy)(command.query[key]);
        }
      });
    }

    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(function (key) {
      var legacyKey = key;

      if (command[legacyKey] != null) {
        result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = (0, utils_1.deepCopy)(command[legacyKey]);
      }
    });
    OP_QUERY_KEYS.forEach(function (key) {
      if (command[key]) {
        result[key] = command[key];
      }
    });

    if (command.pre32Limit != null) {
      result.limit = command.pre32Limit;
    }

    if (command.query.$explain) {
      return {
        explain: result
      };
    }

    return result;
  }

  var clonedQuery = {};
  var clonedCommand = {};

  if (command.query) {
    for (var k in command.query) {
      clonedQuery[k] = (0, utils_1.deepCopy)(command.query[k]);
    }

    clonedCommand.query = clonedQuery;
  }

  for (var _k in command) {
    if (_k === 'query') continue;
    clonedCommand[_k] = (0, utils_1.deepCopy)(command[_k]);
  }

  return command.query ? clonedQuery : clonedCommand;
}

function extractReply(command, reply) {
  if (!reply) {
    return reply;
  }

  if (command instanceof commands_1.Msg) {
    return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
  } // is this a legacy find command?


  if (command.query && command.query.$query != null) {
    return {
      ok: 1,
      cursor: {
        id: (0, utils_1.deepCopy)(reply.cursorId),
        ns: namespace(command),
        firstBatch: (0, utils_1.deepCopy)(reply.documents)
      }
    };
  }

  return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
}

function extractConnectionDetails(connection) {
  var connectionId;

  if ('id' in connection) {
    connectionId = connection.id;
  }

  return {
    address: connection.address,
    serviceId: connection.serviceId,
    connectionId: connectionId
  };
}

/***/ }),

/***/ 8338:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BinMsg = exports.Msg = exports.Response = exports.Query = void 0;

var BSON = __webpack_require__(53);

var error_1 = __webpack_require__(9271);

var read_preference_1 = __webpack_require__(3985);

var utils_1 = __webpack_require__(4356);

var constants_1 = __webpack_require__(8871); // Incrementing request id


var _requestId = 0; // Query flags

var OPTS_TAILABLE_CURSOR = 2;
var OPTS_SECONDARY = 4;
var OPTS_OPLOG_REPLAY = 8;
var OPTS_NO_CURSOR_TIMEOUT = 16;
var OPTS_AWAIT_DATA = 32;
var OPTS_EXHAUST = 64;
var OPTS_PARTIAL = 128; // Response flags

var CURSOR_NOT_FOUND = 1;
var QUERY_FAILURE = 2;
var SHARD_CONFIG_STALE = 4;
var AWAIT_CAPABLE = 8;
/**************************************************************
 * QUERY
 **************************************************************/

/** @internal */

var Query = /*#__PURE__*/function () {
  function Query(ns, query, options) {
    _classCallCheck(this, Query);

    // Basic options needed to be passed in
    // TODO(NODE-3483): Replace with MongoCommandError
    if (ns == null) throw new error_1.MongoRuntimeError('Namespace must be specified for query'); // TODO(NODE-3483): Replace with MongoCommandError

    if (query == null) throw new error_1.MongoRuntimeError('A query document must be specified for query'); // Validate that we are not passing 0x00 in the collection name

    if (ns.indexOf('\x00') !== -1) {
      // TODO(NODE-3483): Use MongoNamespace static method
      throw new error_1.MongoRuntimeError('Namespace cannot contain a null character');
    } // Basic options


    this.ns = ns;
    this.query = query; // Additional options

    this.numberToSkip = options.numberToSkip || 0;
    this.numberToReturn = options.numberToReturn || 0;
    this.returnFieldSelector = options.returnFieldSelector || undefined;
    this.requestId = Query.getRequestId(); // special case for pre-3.2 find commands, delete ASAP

    this.pre32Limit = options.pre32Limit; // Serialization option

    this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;
    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    this.batchSize = this.numberToReturn; // Flags

    this.tailable = false;
    this.secondaryOk = typeof options.secondaryOk === 'boolean' ? options.secondaryOk : false;
    this.oplogReplay = false;
    this.noCursorTimeout = false;
    this.awaitData = false;
    this.exhaust = false;
    this.partial = false;
  }
  /** Assign next request Id. */


  _createClass(Query, [{
    key: "incRequestId",
    value: function incRequestId() {
      this.requestId = _requestId++;
    }
    /** Peek next request Id. */

  }, {
    key: "nextRequestId",
    value: function nextRequestId() {
      return _requestId + 1;
    }
    /** Increment then return next request Id. */

  }, {
    key: "toBin",
    value: // Uses a single allocated buffer for the process, avoiding multiple memory allocations
    function toBin() {
      var buffers = [];
      var projection = null; // Set up the flags

      var flags = 0;

      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }

      if (this.secondaryOk) {
        flags |= OPTS_SECONDARY;
      }

      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }

      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }

      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }

      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }

      if (this.partial) {
        flags |= OPTS_PARTIAL;
      } // If batchSize is different to this.numberToReturn


      if (this.batchSize !== this.numberToReturn) this.numberToReturn = this.batchSize; // Allocate write protocol header buffer

      var header = Buffer.alloc(4 * 4 + // Header
      4 + // Flags
      Buffer.byteLength(this.ns) + 1 + // namespace
      4 + // numberToSkip
      4 // numberToReturn
      ); // Add header to buffers

      buffers.push(header); // Serialize the query

      var query = BSON.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      }); // Add query document

      buffers.push(query);

      if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
        // Serialize the projection document
        projection = BSON.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        }); // Add projection document

        buffers.push(projection);
      } // Total message size


      var totalLength = header.length + query.length + (projection ? projection.length : 0); // Set up the index

      var index = 4; // Write total document length

      header[3] = totalLength >> 24 & 0xff;
      header[2] = totalLength >> 16 & 0xff;
      header[1] = totalLength >> 8 & 0xff;
      header[0] = totalLength & 0xff; // Write header information requestId

      header[index + 3] = this.requestId >> 24 & 0xff;
      header[index + 2] = this.requestId >> 16 & 0xff;
      header[index + 1] = this.requestId >> 8 & 0xff;
      header[index] = this.requestId & 0xff;
      index = index + 4; // Write header information responseTo

      header[index + 3] = 0 >> 24 & 0xff;
      header[index + 2] = 0 >> 16 & 0xff;
      header[index + 1] = 0 >> 8 & 0xff;
      header[index] = 0 & 0xff;
      index = index + 4; // Write header information OP_QUERY

      header[index + 3] = constants_1.OP_QUERY >> 24 & 0xff;
      header[index + 2] = constants_1.OP_QUERY >> 16 & 0xff;
      header[index + 1] = constants_1.OP_QUERY >> 8 & 0xff;
      header[index] = constants_1.OP_QUERY & 0xff;
      index = index + 4; // Write header information flags

      header[index + 3] = flags >> 24 & 0xff;
      header[index + 2] = flags >> 16 & 0xff;
      header[index + 1] = flags >> 8 & 0xff;
      header[index] = flags & 0xff;
      index = index + 4; // Write collection name

      index = index + header.write(this.ns, index, 'utf8') + 1;
      header[index - 1] = 0; // Write header information flags numberToSkip

      header[index + 3] = this.numberToSkip >> 24 & 0xff;
      header[index + 2] = this.numberToSkip >> 16 & 0xff;
      header[index + 1] = this.numberToSkip >> 8 & 0xff;
      header[index] = this.numberToSkip & 0xff;
      index = index + 4; // Write header information flags numberToReturn

      header[index + 3] = this.numberToReturn >> 24 & 0xff;
      header[index + 2] = this.numberToReturn >> 16 & 0xff;
      header[index + 1] = this.numberToReturn >> 8 & 0xff;
      header[index] = this.numberToReturn & 0xff;
      index = index + 4; // Return the buffers

      return buffers;
    }
  }], [{
    key: "getRequestId",
    value: function getRequestId() {
      return ++_requestId;
    }
  }]);

  return Query;
}();

exports.Query = Query;
/** @internal */

var Response = /*#__PURE__*/function () {
  function Response(message, msgHeader, msgBody, opts) {
    _classCallCheck(this, Response);

    this.documents = new Array(0);
    this.parsed = false;
    this.raw = message;
    this.data = msgBody;
    this.opts = opts !== null && opts !== void 0 ? opts : {
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      bsonRegExp: false
    }; // Read the message header

    this.length = msgHeader.length;
    this.requestId = msgHeader.requestId;
    this.responseTo = msgHeader.responseTo;
    this.opCode = msgHeader.opCode;
    this.fromCompressed = msgHeader.fromCompressed; // Flag values

    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;
    this.promoteValues = typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;
    this.promoteBuffers = typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;
    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;
  }

  _createClass(Response, [{
    key: "isParsed",
    value: function isParsed() {
      return this.parsed;
    }
  }, {
    key: "parse",
    value: function parse(options) {
      var _a, _b, _c, _d; // Don't parse again if not needed


      if (this.parsed) return;
      options = options !== null && options !== void 0 ? options : {}; // Allow the return of raw documents instead of parsing

      var raw = options.raw || false;
      var documentsReturnedIn = options.documentsReturnedIn || null;
      var promoteLongs = (_a = options.promoteLongs) !== null && _a !== void 0 ? _a : this.opts.promoteLongs;
      var promoteValues = (_b = options.promoteValues) !== null && _b !== void 0 ? _b : this.opts.promoteValues;
      var promoteBuffers = (_c = options.promoteBuffers) !== null && _c !== void 0 ? _c : this.opts.promoteBuffers;
      var bsonRegExp = (_d = options.bsonRegExp) !== null && _d !== void 0 ? _d : this.opts.bsonRegExp;
      var bsonSize; // Set up the options

      var _options = {
        promoteLongs: promoteLongs,
        promoteValues: promoteValues,
        promoteBuffers: promoteBuffers,
        bsonRegExp: bsonRegExp
      }; // Position within OP_REPLY at which documents start
      // (See https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#wire-op-reply)

      this.index = 20; // Read the message body

      this.responseFlags = this.data.readInt32LE(0);
      this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
      this.startingFrom = this.data.readInt32LE(12);
      this.numberReturned = this.data.readInt32LE(16); // Preallocate document array

      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0; // Parse Body

      for (var i = 0; i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24; // If we have raw results specified slice the return document

        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = BSON.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        } // Adjust the index


        this.index = this.index + bsonSize;
      }

      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        var fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        var doc = BSON.deserialize(this.documents[0], _options);
        this.documents = [doc];
      } // Set parsed


      this.parsed = true;
    }
  }]);

  return Response;
}();

exports.Response = Response; // Implementation of OP_MSG spec:
// https://github.com/mongodb/specifications/blob/master/source/message/OP_MSG.rst
//
// struct Section {
//   uint8 payloadType;
//   union payload {
//       document  document; // payloadType == 0
//       struct sequence { // payloadType == 1
//           int32      size;
//           cstring    identifier;
//           document*  documents;
//       };
//   };
// };
// struct OP_MSG {
//   struct MsgHeader {
//       int32  messageLength;
//       int32  requestID;
//       int32  responseTo;
//       int32  opCode = 2013;
//   };
//   uint32      flagBits;
//   Section+    sections;
//   [uint32     checksum;]
// };
// Msg Flags

var OPTS_CHECKSUM_PRESENT = 1;
var OPTS_MORE_TO_COME = 2;
var OPTS_EXHAUST_ALLOWED = 1 << 16;
/** @internal */

var Msg = /*#__PURE__*/function () {
  function Msg(ns, command, options) {
    _classCallCheck(this, Msg);

    // Basic options needed to be passed in
    if (command == null) throw new error_1.MongoInvalidArgumentError('Query document must be specified for query'); // Basic options

    this.ns = ns;
    this.command = command;
    this.command.$db = (0, utils_1.databaseNamespace)(ns);

    if (options.readPreference && options.readPreference.mode !== read_preference_1.ReadPreference.PRIMARY) {
      this.command.$readPreference = options.readPreference.toJSON();
    } // Ensure empty options


    this.options = options !== null && options !== void 0 ? options : {}; // Additional options

    this.requestId = options.requestId ? options.requestId : Msg.getRequestId(); // Serialization option

    this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;
    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16; // flags

    this.checksumPresent = false;
    this.moreToCome = options.moreToCome || false;
    this.exhaustAllowed = typeof options.exhaustAllowed === 'boolean' ? options.exhaustAllowed : false;
  }

  _createClass(Msg, [{
    key: "toBin",
    value: function toBin() {
      var buffers = [];
      var flags = 0;

      if (this.checksumPresent) {
        flags |= OPTS_CHECKSUM_PRESENT;
      }

      if (this.moreToCome) {
        flags |= OPTS_MORE_TO_COME;
      }

      if (this.exhaustAllowed) {
        flags |= OPTS_EXHAUST_ALLOWED;
      }

      var header = Buffer.alloc(4 * 4 + // Header
      4 // Flags
      );
      buffers.push(header);
      var totalLength = header.length;
      var command = this.command;
      totalLength += this.makeDocumentSegment(buffers, command);
      header.writeInt32LE(totalLength, 0); // messageLength

      header.writeInt32LE(this.requestId, 4); // requestID

      header.writeInt32LE(0, 8); // responseTo

      header.writeInt32LE(constants_1.OP_MSG, 12); // opCode

      header.writeUInt32LE(flags, 16); // flags

      return buffers;
    }
  }, {
    key: "makeDocumentSegment",
    value: function makeDocumentSegment(buffers, document) {
      var payloadTypeBuffer = Buffer.alloc(1);
      payloadTypeBuffer[0] = 0;
      var documentBuffer = this.serializeBson(document);
      buffers.push(payloadTypeBuffer);
      buffers.push(documentBuffer);
      return payloadTypeBuffer.length + documentBuffer.length;
    }
  }, {
    key: "serializeBson",
    value: function serializeBson(document) {
      return BSON.serialize(document, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
    }
  }], [{
    key: "getRequestId",
    value: function getRequestId() {
      _requestId = _requestId + 1 & 0x7fffffff;
      return _requestId;
    }
  }]);

  return Msg;
}();

exports.Msg = Msg;
/** @internal */

var BinMsg = /*#__PURE__*/function () {
  function BinMsg(message, msgHeader, msgBody, opts) {
    _classCallCheck(this, BinMsg);

    this.parsed = false;
    this.raw = message;
    this.data = msgBody;
    this.opts = opts !== null && opts !== void 0 ? opts : {
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      bsonRegExp: false
    }; // Read the message header

    this.length = msgHeader.length;
    this.requestId = msgHeader.requestId;
    this.responseTo = msgHeader.responseTo;
    this.opCode = msgHeader.opCode;
    this.fromCompressed = msgHeader.fromCompressed; // Read response flags

    this.responseFlags = msgBody.readInt32LE(0);
    this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
    this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
    this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;
    this.promoteValues = typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;
    this.promoteBuffers = typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;
    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;
    this.documents = [];
  }

  _createClass(BinMsg, [{
    key: "isParsed",
    value: function isParsed() {
      return this.parsed;
    }
  }, {
    key: "parse",
    value: function parse(options) {
      var _a, _b, _c, _d; // Don't parse again if not needed


      if (this.parsed) return;
      options = options !== null && options !== void 0 ? options : {};
      this.index = 4; // Allow the return of raw documents instead of parsing

      var raw = options.raw || false;
      var documentsReturnedIn = options.documentsReturnedIn || null;
      var promoteLongs = (_a = options.promoteLongs) !== null && _a !== void 0 ? _a : this.opts.promoteLongs;
      var promoteValues = (_b = options.promoteValues) !== null && _b !== void 0 ? _b : this.opts.promoteValues;
      var promoteBuffers = (_c = options.promoteBuffers) !== null && _c !== void 0 ? _c : this.opts.promoteBuffers;
      var bsonRegExp = (_d = options.bsonRegExp) !== null && _d !== void 0 ? _d : this.opts.bsonRegExp;
      var validation = this.parseBsonSerializationOptions(options); // Set up the options

      var bsonOptions = {
        promoteLongs: promoteLongs,
        promoteValues: promoteValues,
        promoteBuffers: promoteBuffers,
        bsonRegExp: bsonRegExp,
        validation: validation // Due to the strictness of the BSON libraries validation option we need this cast

      };

      while (this.index < this.data.length) {
        var payloadType = this.data.readUInt8(this.index++);

        if (payloadType === 0) {
          var bsonSize = this.data.readUInt32LE(this.index);
          var bin = this.data.slice(this.index, this.index + bsonSize);
          this.documents.push(raw ? bin : BSON.deserialize(bin, bsonOptions));
          this.index += bsonSize;
        } else if (payloadType === 1) {
          // It was decided that no driver makes use of payload type 1
          // TODO(NODE-3483): Replace with MongoDeprecationError
          throw new error_1.MongoRuntimeError('OP_MSG Payload Type 1 detected unsupported protocol');
        }
      }

      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        var fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        bsonOptions.fieldsAsRaw = fieldsAsRaw;
        var doc = BSON.deserialize(this.documents[0], bsonOptions);
        this.documents = [doc];
      }

      this.parsed = true;
    }
  }, {
    key: "parseBsonSerializationOptions",
    value: function parseBsonSerializationOptions(_ref) {
      var enableUtf8Validation = _ref.enableUtf8Validation;

      if (enableUtf8Validation === false) {
        return {
          utf8: false
        };
      }

      return {
        utf8: {
          writeErrors: false
        }
      };
    }
  }]);

  return BinMsg;
}();

exports.BinMsg = BinMsg;

/***/ }),

/***/ 7247:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;

var net = __webpack_require__(1808);

var socks_1 = __webpack_require__(1048);

var tls = __webpack_require__(4404);

var bson_1 = __webpack_require__(53);

var constants_1 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var auth_provider_1 = __webpack_require__(4629);

var gssapi_1 = __webpack_require__(8211);

var mongocr_1 = __webpack_require__(2778);

var mongodb_aws_1 = __webpack_require__(130);

var plain_1 = __webpack_require__(313);

var providers_1 = __webpack_require__(2581);

var scram_1 = __webpack_require__(4788);

var x509_1 = __webpack_require__(3190);

var connection_1 = __webpack_require__(7625);

var constants_2 = __webpack_require__(8871);

var AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);

function connect(options, callback) {
  makeConnection(_objectSpread(_objectSpread({}, options), {}, {
    existingSocket: undefined
  }), function (err, socket) {
    var _a;

    if (err || !socket) {
      return callback(err);
    }

    var ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;

    if (options.autoEncrypter) {
      ConnectionType = connection_1.CryptoConnection;
    }

    performInitialHandshake(new ConnectionType(socket, options), options, callback);
  });
}

exports.connect = connect;

function checkSupportedServer(hello, options) {
  var _a;

  var serverVersionHighEnough = hello && (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof bson_1.Int32) && hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
  var serverVersionLowEnough = hello && (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof bson_1.Int32) && hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;

  if (serverVersionHighEnough) {
    if (serverVersionLowEnough) {
      return null;
    }

    var _message = "Server at ".concat(options.hostAddress, " reports minimum wire version ").concat(JSON.stringify(hello.minWireVersion), ", but this version of the Node.js Driver requires at most ").concat(constants_2.MAX_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(constants_2.MAX_SUPPORTED_SERVER_VERSION, ")");

    return new error_1.MongoCompatibilityError(_message);
  }

  var message = "Server at ".concat(options.hostAddress, " reports maximum wire version ").concat((_a = JSON.stringify(hello.maxWireVersion)) !== null && _a !== void 0 ? _a : 0, ", but this version of the Node.js Driver requires at least ").concat(constants_2.MIN_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(constants_2.MIN_SUPPORTED_SERVER_VERSION, ")");
  return new error_1.MongoCompatibilityError(message);
}

function performInitialHandshake(conn, options, _callback) {
  var callback = function callback(err, ret) {
    if (err && conn) {
      conn.destroy();
    }

    _callback(err, ret);
  };

  var credentials = options.credentials;

  if (credentials) {
    if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !AUTH_PROVIDERS.get(credentials.mechanism)) {
      callback(new error_1.MongoInvalidArgumentError("AuthMechanism '".concat(credentials.mechanism, "' not supported")));
      return;
    }
  }

  var authContext = new auth_provider_1.AuthContext(conn, credentials, options);
  prepareHandshakeDocument(authContext, function (err, handshakeDoc) {
    if (err || !handshakeDoc) {
      return callback(err);
    }

    var handshakeOptions = Object.assign({}, options);

    if (typeof options.connectTimeoutMS === 'number') {
      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS
      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
    }

    var start = new Date().getTime();
    conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions, function (err, response) {
      if (err) {
        callback(err);
        return;
      }

      if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {
        callback(new error_1.MongoServerError(response));
        return;
      }

      if (!('isWritablePrimary' in response)) {
        // Provide hello-style response document.
        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
      }

      if (response.helloOk) {
        conn.helloOk = true;
      }

      var supportedServerErr = checkSupportedServer(response, options);

      if (supportedServerErr) {
        callback(supportedServerErr);
        return;
      }

      if (options.loadBalanced) {
        if (!response.serviceId) {
          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));
        }
      } // NOTE: This is metadata attached to the connection while porting away from
      //       handshake being done in the `Server` class. Likely, it should be
      //       relocated, or at very least restructured.


      conn.hello = response;
      conn.lastHelloMS = new Date().getTime() - start;

      if (!response.arbiterOnly && credentials) {
        // store the response on auth context
        authContext.response = response;
        var resolvedCredentials = credentials.resolveAuthMechanism(response);
        var provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);

        if (!provider) {
          return callback(new error_1.MongoInvalidArgumentError("No AuthProvider for ".concat(resolvedCredentials.mechanism, " defined.")));
        }

        provider.auth(authContext, function (err) {
          if (err) {
            if (err instanceof error_1.MongoError) {
              err.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);

              if ((0, error_1.needsRetryableWriteLabel)(err, response.maxWireVersion)) {
                err.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
              }
            }

            return callback(err);
          }

          callback(undefined, conn);
        });
        return;
      }

      callback(undefined, conn);
    });
  });
}

function prepareHandshakeDocument(authContext, callback) {
  var _handshakeDoc;

  var options = authContext.options;
  var compressors = options.compressors ? options.compressors : [];
  var serverApi = authContext.connection.serverApi;
  var handshakeDoc = (_handshakeDoc = {}, _defineProperty(_handshakeDoc, (serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : constants_1.LEGACY_HELLO_COMMAND, true), _defineProperty(_handshakeDoc, "helloOk", true), _defineProperty(_handshakeDoc, "client", options.metadata || (0, utils_1.makeClientMetadata)(options)), _defineProperty(_handshakeDoc, "compression", compressors), _defineProperty(_handshakeDoc, "loadBalanced", options.loadBalanced), _handshakeDoc);
  var credentials = authContext.credentials;

  if (credentials) {
    if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {
      handshakeDoc.saslSupportedMechs = "".concat(credentials.source, ".").concat(credentials.username);

      var _provider = AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);

      if (!_provider) {
        // This auth mechanism is always present.
        return callback(new error_1.MongoInvalidArgumentError("No AuthProvider for ".concat(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, " defined.")));
      }

      return _provider.prepare(handshakeDoc, authContext, callback);
    }

    var provider = AUTH_PROVIDERS.get(credentials.mechanism);

    if (!provider) {
      return callback(new error_1.MongoInvalidArgumentError("No AuthProvider for ".concat(credentials.mechanism, " defined.")));
    }

    return provider.prepare(handshakeDoc, authContext, callback);
  }

  callback(undefined, handshakeDoc);
}
/** @public */


exports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];
/** @public */

exports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];

function parseConnectOptions(options) {
  var hostAddress = options.hostAddress;
  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
  var result = {};

  var _iterator = _createForOfIteratorHelper(exports.LEGAL_TCP_SOCKET_OPTIONS),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var name = _step.value;

      if (options[name] != null) {
        result[name] = options[name];
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (typeof hostAddress.socketPath === 'string') {
    result.path = hostAddress.socketPath;
    return result;
  } else if (typeof hostAddress.host === 'string') {
    result.host = hostAddress.host;
    result.port = hostAddress.port;
    return result;
  } else {
    // This should never happen since we set up HostAddresses
    // But if we don't throw here the socket could hang until timeout
    // TODO(NODE-3483)
    throw new error_1.MongoRuntimeError("Unexpected HostAddress ".concat(JSON.stringify(hostAddress)));
  }
}

function parseSslOptions(options) {
  var result = parseConnectOptions(options); // Merge in valid SSL options

  var _iterator2 = _createForOfIteratorHelper(exports.LEGAL_TLS_SOCKET_OPTIONS),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var name = _step2.value;

      if (options[name] != null) {
        result[name] = options[name];
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  if (options.existingSocket) {
    result.socket = options.existingSocket;
  } // Set default sni servername to be the same as host


  if (result.servername == null && result.host && !net.isIP(result.host)) {
    result.servername = result.host;
  }

  return result;
}

var SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];
var SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);

function makeConnection(options, _callback) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;

  var useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;
  var keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;
  var socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;
  var noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;
  var connectTimeoutMS = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;
  var rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;
  var keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 120000;
  var existingSocket = options.existingSocket;
  var socket;

  var callback = function callback(err, ret) {
    if (err && socket) {
      socket.destroy();
    }

    _callback(err, ret);
  };

  if (options.proxyHost != null) {
    // Currently, only Socks5 is supported.
    return makeSocks5Connection(_objectSpread(_objectSpread({}, options), {}, {
      connectTimeoutMS: connectTimeoutMS // Should always be present for Socks5

    }), callback);
  }

  if (useTLS) {
    var tlsSocket = tls.connect(parseSslOptions(options));

    if (typeof tlsSocket.disableRenegotiation === 'function') {
      tlsSocket.disableRenegotiation();
    }

    socket = tlsSocket;
  } else if (existingSocket) {
    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,
    // so we only need to handle the non-TLS case here (where existingSocket
    // gives us all we need out of the box).
    socket = existingSocket;
  } else {
    socket = net.createConnection(parseConnectOptions(options));
  }

  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
  socket.setTimeout(connectTimeoutMS);
  socket.setNoDelay(noDelay);
  var connectEvent = useTLS ? 'secureConnect' : 'connect';
  var cancellationHandler;

  function errorHandler(eventName) {
    return function (err) {
      SOCKET_ERROR_EVENTS.forEach(function (event) {
        return socket.removeAllListeners(event);
      });

      if (cancellationHandler && options.cancellationToken) {
        options.cancellationToken.removeListener('cancel', cancellationHandler);
      }

      socket.removeListener(connectEvent, connectHandler);
      callback(connectionFailureError(eventName, err));
    };
  }

  function connectHandler() {
    SOCKET_ERROR_EVENTS.forEach(function (event) {
      return socket.removeAllListeners(event);
    });

    if (cancellationHandler && options.cancellationToken) {
      options.cancellationToken.removeListener('cancel', cancellationHandler);
    }

    if ('authorizationError' in socket) {
      if (socket.authorizationError && rejectUnauthorized) {
        return callback(socket.authorizationError);
      }
    }

    socket.setTimeout(socketTimeoutMS);
    callback(undefined, socket);
  }

  SOCKET_ERROR_EVENTS.forEach(function (event) {
    return socket.once(event, errorHandler(event));
  });

  if (options.cancellationToken) {
    cancellationHandler = errorHandler('cancel');
    options.cancellationToken.once('cancel', cancellationHandler);
  }

  if (existingSocket) {
    process.nextTick(connectHandler);
  } else {
    socket.once(connectEvent, connectHandler);
  }
}

function makeSocks5Connection(options, callback) {
  var _a, _b;

  var hostAddress = utils_1.HostAddress.fromHostPort((_a = options.proxyHost) !== null && _a !== void 0 ? _a : '', // proxyHost is guaranteed to set here
  (_b = options.proxyPort) !== null && _b !== void 0 ? _b : 1080); // First, connect to the proxy server itself:

  makeConnection(_objectSpread(_objectSpread({}, options), {}, {
    hostAddress: hostAddress,
    tls: false,
    proxyHost: undefined
  }), function (err, rawSocket) {
    if (err) {
      return callback(err);
    }

    var destination = parseConnectOptions(options);

    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {
      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));
    } // Then, establish the Socks5 proxy connection:


    socks_1.SocksClient.createConnection({
      existing_socket: rawSocket,
      timeout: options.connectTimeoutMS,
      command: 'connect',
      destination: {
        host: destination.host,
        port: destination.port
      },
      proxy: {
        // host and port are ignored because we pass existing_socket
        host: 'iLoveJavaScript',
        port: 0,
        type: 5,
        userId: options.proxyUsername || undefined,
        password: options.proxyPassword || undefined
      }
    }).then(function (_ref) {
      var socket = _ref.socket;
      // Finally, now treat the resulting duplex stream as the
      // socket over which we send and receive wire protocol messages:
      makeConnection(_objectSpread(_objectSpread({}, options), {}, {
        existingSocket: socket,
        proxyHost: undefined
      }), callback);
    }, function (error) {
      return callback(connectionFailureError('error', error));
    });
  });
}

function connectionFailureError(type, err) {
  switch (type) {
    case 'error':
      return new error_1.MongoNetworkError(err);

    case 'timeout':
      return new error_1.MongoNetworkTimeoutError('connection timed out');

    case 'close':
      return new error_1.MongoNetworkError('connection closed');

    case 'cancel':
      return new error_1.MongoNetworkError('connection establishment was cancelled');

    default:
      return new error_1.MongoNetworkError('unknown network error');
  }
}

/***/ }),

/***/ 7625:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;

var timers_1 = __webpack_require__(9512);

var constants_1 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var mongo_types_1 = __webpack_require__(3738);

var sessions_1 = __webpack_require__(4408);

var utils_1 = __webpack_require__(4356);

var command_monitoring_events_1 = __webpack_require__(8884);

var commands_1 = __webpack_require__(8338);

var message_stream_1 = __webpack_require__(7658);

var stream_description_1 = __webpack_require__(2632);

var shared_1 = __webpack_require__(4242);
/** @internal */


var kStream = Symbol('stream');
/** @internal */

var kQueue = Symbol('queue');
/** @internal */

var kMessageStream = Symbol('messageStream');
/** @internal */

var kGeneration = Symbol('generation');
/** @internal */

var kLastUseTime = Symbol('lastUseTime');
/** @internal */

var kClusterTime = Symbol('clusterTime');
/** @internal */

var kDescription = Symbol('description');
/** @internal */

var kHello = Symbol('hello');
/** @internal */

var kAutoEncrypter = Symbol('autoEncrypter');
/** @internal */

var kDelayedTimeoutId = Symbol('delayedTimeoutId');
/** @internal */

var Connection = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(Connection, _mongo_types_1$TypedE);

  var _super = _createSuper(Connection);

  function Connection(stream, options) {
    var _this;

    _classCallCheck(this, Connection);

    var _a, _b;

    _this = _super.call(this);
    _this.id = options.id;
    _this.address = streamIdentifier(stream, options);
    _this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;
    _this.monitorCommands = options.monitorCommands;
    _this.serverApi = options.serverApi;
    _this.closed = false;
    _this.destroyed = false;
    _this[kHello] = null;
    _this[kClusterTime] = null;
    _this[kDescription] = new stream_description_1.StreamDescription(_this.address, options);
    _this[kGeneration] = options.generation;
    _this[kLastUseTime] = (0, utils_1.now)(); // setup parser stream and message handling

    _this[kQueue] = new Map();
    _this[kMessageStream] = new message_stream_1.MessageStream(_objectSpread(_objectSpread({}, options), {}, {
      maxBsonMessageSize: (_b = _this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize
    }));
    _this[kStream] = stream;
    _this[kDelayedTimeoutId] = null;

    _this[kMessageStream].on('message', function (message) {
      return _this.onMessage(message);
    });

    _this[kMessageStream].on('error', function (error) {
      return _this.onError(error);
    });

    _this[kStream].on('close', function () {
      return _this.onClose();
    });

    _this[kStream].on('timeout', function () {
      return _this.onTimeout();
    });

    _this[kStream].on('error', function () {
      /* ignore errors, listen to `close` instead */
    }); // hook the message stream up to the passed in stream


    _this[kStream].pipe(_this[kMessageStream]);

    _this[kMessageStream].pipe(_this[kStream]);

    return _this;
  }

  _createClass(Connection, [{
    key: "description",
    get: function get() {
      return this[kDescription];
    }
  }, {
    key: "hello",
    get: function get() {
      return this[kHello];
    } // the `connect` method stores the result of the handshake hello on the connection
    ,
    set: function set(response) {
      this[kDescription].receiveResponse(response);
      this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future

      this[kHello] = response;
    } // Set the whether the message stream is for a monitoring connection.

  }, {
    key: "isMonitoringConnection",
    get: function get() {
      return this[kMessageStream].isMonitoringConnection;
    },
    set: function set(value) {
      this[kMessageStream].isMonitoringConnection = value;
    }
  }, {
    key: "serviceId",
    get: function get() {
      var _a;

      return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      return this.description.loadBalanced;
    }
  }, {
    key: "generation",
    get: function get() {
      return this[kGeneration] || 0;
    },
    set: function set(generation) {
      this[kGeneration] = generation;
    }
  }, {
    key: "idleTime",
    get: function get() {
      return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);
    }
  }, {
    key: "clusterTime",
    get: function get() {
      return this[kClusterTime];
    }
  }, {
    key: "stream",
    get: function get() {
      return this[kStream];
    }
  }, {
    key: "markAvailable",
    value: function markAvailable() {
      this[kLastUseTime] = (0, utils_1.now)();
    }
  }, {
    key: "onError",
    value: function onError(error) {
      if (this.closed) {
        return;
      }

      this[kStream].destroy(error);
      this.closed = true;

      var _iterator = _createForOfIteratorHelper(this[kQueue].values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var op = _step.value;
          op.cb(error);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this[kQueue].clear();
      this.emit(Connection.CLOSE);
    }
  }, {
    key: "onClose",
    value: function onClose() {
      if (this.closed) {
        return;
      }

      this.closed = true;
      var message = "connection ".concat(this.id, " to ").concat(this.address, " closed");

      var _iterator2 = _createForOfIteratorHelper(this[kQueue].values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var op = _step2.value;
          op.cb(new error_1.MongoNetworkError(message));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this[kQueue].clear();
      this.emit(Connection.CLOSE);
    }
  }, {
    key: "onTimeout",
    value: function onTimeout() {
      var _this2 = this;

      if (this.closed) {
        return;
      }

      this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(function () {
        _this2[kStream].destroy();

        _this2.closed = true;
        var message = "connection ".concat(_this2.id, " to ").concat(_this2.address, " timed out");
        var beforeHandshake = _this2.hello == null;

        var _iterator3 = _createForOfIteratorHelper(_this2[kQueue].values()),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var op = _step3.value;
            op.cb(new error_1.MongoNetworkTimeoutError(message, {
              beforeHandshake: beforeHandshake
            }));
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        _this2[kQueue].clear();

        _this2.emit(Connection.CLOSE);
      }, 1).unref(); // No need for this timer to hold the event loop open
    }
  }, {
    key: "onMessage",
    value: function onMessage(message) {
      var delayedTimeoutId = this[kDelayedTimeoutId];

      if (delayedTimeoutId != null) {
        (0, timers_1.clearTimeout)(delayedTimeoutId);
        this[kDelayedTimeoutId] = null;
      } // always emit the message, in case we are streaming


      this.emit('message', message);
      var operationDescription = this[kQueue].get(message.responseTo);

      if (!operationDescription) {
        return;
      }

      var callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to
      // track response, however the server currently synthetically produces remote requests
      // making the `responseTo` change on each response

      this[kQueue]["delete"](message.responseTo);

      if ('moreToCome' in message && message.moreToCome) {
        // requeue the callback for next synthetic request
        this[kQueue].set(message.requestId, operationDescription);
      } else if (operationDescription.socketTimeoutOverride) {
        this[kStream].setTimeout(this.socketTimeoutMS);
      }

      try {
        // Pass in the entire description because it has BSON parsing options
        message.parse(operationDescription);
      } catch (err) {
        // If this error is generated by our own code, it will already have the correct class applied
        // if it is not, then it is coming from a catastrophic data parse failure or the BSON library
        // in either case, it should not be wrapped
        callback(err);
        return;
      }

      if (message.documents[0]) {
        var document = message.documents[0];
        var session = operationDescription.session;

        if (session) {
          (0, sessions_1.updateSessionFromResponse)(session, document);
        }

        if (document.$clusterTime) {
          this[kClusterTime] = document.$clusterTime;
          this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);
        }

        if (operationDescription.command) {
          if (document.writeConcernError) {
            callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));
            return;
          }

          if (document.ok === 0 || document.$err || document.errmsg || document.code) {
            callback(new error_1.MongoServerError(document));
            return;
          }
        } else {
          // Pre 3.2 support
          if (document.ok === 0 || document.$err || document.errmsg) {
            callback(new error_1.MongoServerError(document));
            return;
          }
        }
      }

      callback(undefined, message.documents[0]);
    }
  }, {
    key: "destroy",
    value: function destroy(options, callback) {
      var _this3 = this;

      if (typeof options === 'function') {
        callback = options;
        options = {
          force: false
        };
      }

      this.removeAllListeners(Connection.PINNED);
      this.removeAllListeners(Connection.UNPINNED);
      options = Object.assign({
        force: false
      }, options);

      if (this[kStream] == null || this.destroyed) {
        this.destroyed = true;

        if (typeof callback === 'function') {
          callback();
        }

        return;
      }

      if (options.force) {
        this[kStream].destroy();
        this.destroyed = true;

        if (typeof callback === 'function') {
          callback();
        }

        return;
      }

      this[kStream].end(function () {
        _this3.destroyed = true;

        if (typeof callback === 'function') {
          callback();
        }
      });
    }
  }, {
    key: "command",
    value: function command(ns, cmd, options, callback) {
      var readPreference = (0, shared_1.getReadPreference)(cmd, options);
      var shouldUseOpMsg = supportsOpMsg(this);
      var session = options === null || options === void 0 ? void 0 : options.session;
      var clusterTime = this.clusterTime;
      var finalCmd = Object.assign({}, cmd);

      if (this.serverApi) {
        var _this$serverApi = this.serverApi,
            version = _this$serverApi.version,
            strict = _this$serverApi.strict,
            deprecationErrors = _this$serverApi.deprecationErrors;
        finalCmd.apiVersion = version;
        if (strict != null) finalCmd.apiStrict = strict;
        if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;
      }

      if (hasSessionSupport(this) && session) {
        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
          clusterTime = session.clusterTime;
        }

        var err = (0, sessions_1.applySession)(session, finalCmd, options);

        if (err) {
          return callback(err);
        }
      } // if we have a known cluster time, gossip it


      if (clusterTime) {
        finalCmd.$clusterTime = clusterTime;
      }

      if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {
        finalCmd = {
          $query: finalCmd,
          $readPreference: readPreference.toJSON()
        };
      }

      var commandOptions = Object.assign({
        command: true,
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false,
        // This value is not overridable
        secondaryOk: readPreference.secondaryOk()
      }, options);
      var cmdNs = "".concat(ns.db, ".$cmd");
      var message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);

      try {
        write(this, message, commandOptions, callback);
      } catch (err) {
        callback(err);
      }
    }
  }]);

  return Connection;
}(mongo_types_1.TypedEventEmitter);

exports.Connection = Connection;
/** @event */

Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
/** @event */

Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
/** @event */

Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
/** @event */

Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
/** @event */

Connection.CLOSE = constants_1.CLOSE;
/** @event */

Connection.MESSAGE = constants_1.MESSAGE;
/** @event */

Connection.PINNED = constants_1.PINNED;
/** @event */

Connection.UNPINNED = constants_1.UNPINNED;
/** @internal */

var CryptoConnection = /*#__PURE__*/function (_Connection) {
  _inherits(CryptoConnection, _Connection);

  var _super2 = _createSuper(CryptoConnection);

  function CryptoConnection(stream, options) {
    var _this4;

    _classCallCheck(this, CryptoConnection);

    _this4 = _super2.call(this, stream, options);
    _this4[kAutoEncrypter] = options.autoEncrypter;
    return _this4;
  }
  /** @internal @override */


  _createClass(CryptoConnection, [{
    key: "command",
    value: function command(ns, cmd, options, callback) {
      var _this5 = this;

      var autoEncrypter = this[kAutoEncrypter];

      if (!autoEncrypter) {
        return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));
      }

      var serverWireVersion = (0, utils_1.maxWireVersion)(this);

      if (serverWireVersion === 0) {
        // This means the initial handshake hasn't happened yet
        return _get(_getPrototypeOf(CryptoConnection.prototype), "command", this).call(this, ns, cmd, options, callback);
      }

      if (serverWireVersion < 8) {
        callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));
        return;
      } // Save sort or indexKeys based on the command being run
      // the encrypt API serializes our JS objects to BSON to pass to the native code layer
      // and then deserializes the encrypted result, the protocol level components
      // of the command (ex. sort) are then converted to JS objects potentially losing
      // import key order information. These fields are never encrypted so we can save the values
      // from before the encryption and replace them after encryption has been performed


      var sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
      var indexKeys = cmd.createIndexes ? cmd.indexes.map(function (index) {
        return index.key;
      }) : null;
      autoEncrypter.encrypt(ns.toString(), cmd, options, function (err, encrypted) {
        if (err || encrypted == null) {
          callback(err, null);
          return;
        } // Replace the saved values


        if (sort != null && (cmd.find || cmd.findAndModify)) {
          encrypted.sort = sort;
        }

        if (indexKeys != null && cmd.createIndexes) {
          var _iterator4 = _createForOfIteratorHelper(indexKeys.entries()),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _step4$value = _slicedToArray(_step4.value, 2),
                  offset = _step4$value[0],
                  index = _step4$value[1];

              encrypted.indexes[offset].key = index;
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }

        _get(_getPrototypeOf(CryptoConnection.prototype), "command", _this5).call(_this5, ns, encrypted, options, function (err, response) {
          if (err || response == null) {
            callback(err, response);
            return;
          }

          autoEncrypter.decrypt(response, options, callback);
        });
      });
    }
  }]);

  return CryptoConnection;
}(Connection);

exports.CryptoConnection = CryptoConnection;
/** @internal */

function hasSessionSupport(conn) {
  var description = conn.description;
  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;
}

exports.hasSessionSupport = hasSessionSupport;

function supportsOpMsg(conn) {
  var description = conn.description;

  if (description == null) {
    return false;
  }

  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;
}

function streamIdentifier(stream, options) {
  if (options.proxyHost) {
    // If proxy options are specified, the properties of `stream` itself
    // will not accurately reflect what endpoint this is connected to.
    return options.hostAddress.toString();
  }

  if (typeof stream.address === 'function') {
    return "".concat(stream.remoteAddress, ":").concat(stream.remotePort);
  }

  return (0, utils_1.uuidV4)().toString('hex');
}

function write(conn, command, options, callback) {
  options = options !== null && options !== void 0 ? options : {};
  var operationDescription = {
    requestId: command.requestId,
    cb: callback,
    session: options.session,
    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,
    documentsReturnedIn: options.documentsReturnedIn,
    command: !!options.command,
    // for BSON parsing
    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,
    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,
    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,
    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,
    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,
    raw: typeof options.raw === 'boolean' ? options.raw : false,
    started: 0
  };

  if (conn[kDescription] && conn[kDescription].compressor) {
    operationDescription.agreedCompressor = conn[kDescription].compressor;

    if (conn[kDescription].zlibCompressionLevel) {
      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;
    }
  }

  if (typeof options.socketTimeoutMS === 'number') {
    operationDescription.socketTimeoutOverride = true;
    conn[kStream].setTimeout(options.socketTimeoutMS);
  } // if command monitoring is enabled we need to modify the callback here


  if (conn.monitorCommands) {
    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));
    operationDescription.started = (0, utils_1.now)();

    operationDescription.cb = function (err, reply) {
      if (err) {
        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));
      } else {
        if (reply && (reply.ok === 0 || reply.$err)) {
          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));
        } else {
          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));
        }
      }

      if (typeof callback === 'function') {
        callback(err, reply);
      }
    };
  }

  if (!operationDescription.noResponse) {
    conn[kQueue].set(operationDescription.requestId, operationDescription);
  }

  try {
    conn[kMessageStream].writeCommand(command, operationDescription);
  } catch (e) {
    if (!operationDescription.noResponse) {
      conn[kQueue]["delete"](operationDescription.requestId);
      operationDescription.cb(e);
      return;
    }
  }

  if (operationDescription.noResponse) {
    operationDescription.cb();
  }
}

/***/ }),

/***/ 6854:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionPool = exports.PoolState = void 0;

var Denque = __webpack_require__(2279);

var timers_1 = __webpack_require__(9512);

var constants_1 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var logger_1 = __webpack_require__(295);

var mongo_types_1 = __webpack_require__(3738);

var utils_1 = __webpack_require__(4356);

var connect_1 = __webpack_require__(7247);

var connection_1 = __webpack_require__(7625);

var connection_pool_events_1 = __webpack_require__(640);

var errors_1 = __webpack_require__(1171);

var metrics_1 = __webpack_require__(8274);
/** @internal */


var kLogger = Symbol('logger');
/** @internal */

var kConnections = Symbol('connections');
/** @internal */

var kPending = Symbol('pending');
/** @internal */

var kCheckedOut = Symbol('checkedOut');
/** @internal */

var kMinPoolSizeTimer = Symbol('minPoolSizeTimer');
/** @internal */

var kGeneration = Symbol('generation');
/** @internal */

var kServiceGenerations = Symbol('serviceGenerations');
/** @internal */

var kConnectionCounter = Symbol('connectionCounter');
/** @internal */

var kCancellationToken = Symbol('cancellationToken');
/** @internal */

var kWaitQueue = Symbol('waitQueue');
/** @internal */

var kCancelled = Symbol('cancelled');
/** @internal */

var kMetrics = Symbol('metrics');
/** @internal */

var kProcessingWaitQueue = Symbol('processingWaitQueue');
/** @internal */

var kPoolState = Symbol('poolState');
/** @internal */

exports.PoolState = Object.freeze({
  paused: 'paused',
  ready: 'ready',
  closed: 'closed'
});
/**
 * A pool of connections which dynamically resizes, and emit events related to pool activity
 * @internal
 */

var ConnectionPool = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(ConnectionPool, _mongo_types_1$TypedE);

  var _super = _createSuper(ConnectionPool);

  /** @internal */
  function ConnectionPool(options) {
    var _this;

    _classCallCheck(this, ConnectionPool);

    var _a, _b, _c, _d, _e;

    _this = _super.call(this);
    _this.options = Object.freeze(_objectSpread(_objectSpread({}, options), {}, {
      connectionType: connection_1.Connection,
      maxPoolSize: (_a = options.maxPoolSize) !== null && _a !== void 0 ? _a : 100,
      minPoolSize: (_b = options.minPoolSize) !== null && _b !== void 0 ? _b : 0,
      maxConnecting: (_c = options.maxConnecting) !== null && _c !== void 0 ? _c : 2,
      maxIdleTimeMS: (_d = options.maxIdleTimeMS) !== null && _d !== void 0 ? _d : 0,
      waitQueueTimeoutMS: (_e = options.waitQueueTimeoutMS) !== null && _e !== void 0 ? _e : 0,
      autoEncrypter: options.autoEncrypter,
      metadata: options.metadata
    }));

    if (_this.options.minPoolSize > _this.options.maxPoolSize) {
      throw new error_1.MongoInvalidArgumentError('Connection pool minimum size must not be greater than maximum pool size');
    }

    _this[kPoolState] = exports.PoolState.paused;
    _this[kLogger] = new logger_1.Logger('ConnectionPool');
    _this[kConnections] = new Denque();
    _this[kPending] = 0;
    _this[kCheckedOut] = 0;
    _this[kMinPoolSizeTimer] = undefined;
    _this[kGeneration] = 0;
    _this[kServiceGenerations] = new Map();
    _this[kConnectionCounter] = (0, utils_1.makeCounter)(1);
    _this[kCancellationToken] = new mongo_types_1.CancellationToken();

    _this[kCancellationToken].setMaxListeners(Infinity);

    _this[kWaitQueue] = new Denque();
    _this[kMetrics] = new metrics_1.ConnectionPoolMetrics();
    _this[kProcessingWaitQueue] = false;
    process.nextTick(function () {
      _this.emit(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(_assertThisInitialized(_this)));

      _this.ensureMinPoolSize();
    });
    return _this;
  }
  /** The address of the endpoint the pool is connected to */


  _createClass(ConnectionPool, [{
    key: "address",
    get: function get() {
      return this.options.hostAddress.toString();
    }
    /**
     * Check if the pool has been closed
     *
     * TODO(NODE-3263): We can remove this property once shell no longer needs it
     */

  }, {
    key: "closed",
    get: function get() {
      return this[kPoolState] === exports.PoolState.closed;
    }
    /** An integer representing the SDAM generation of the pool */

  }, {
    key: "generation",
    get: function get() {
      return this[kGeneration];
    }
    /** An integer expressing how many total connections (available + pending + in use) the pool currently has */

  }, {
    key: "totalConnectionCount",
    get: function get() {
      return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;
    }
    /** An integer expressing how many connections are currently available in the pool. */

  }, {
    key: "availableConnectionCount",
    get: function get() {
      return this[kConnections].length;
    }
  }, {
    key: "pendingConnectionCount",
    get: function get() {
      return this[kPending];
    }
  }, {
    key: "currentCheckedOutCount",
    get: function get() {
      return this[kCheckedOut];
    }
  }, {
    key: "waitQueueSize",
    get: function get() {
      return this[kWaitQueue].length;
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      return this.options.loadBalanced;
    }
  }, {
    key: "serviceGenerations",
    get: function get() {
      return this[kServiceGenerations];
    }
    /**
     * Get the metrics information for the pool when a wait queue timeout occurs.
     */

  }, {
    key: "waitQueueErrorMetrics",
    value: function waitQueueErrorMetrics() {
      return this[kMetrics].info(this.options.maxPoolSize);
    }
    /**
     * Set the pool state to "ready"
     */

  }, {
    key: "ready",
    value: function ready() {
      this[kPoolState] = exports.PoolState.ready;
    }
    /**
     * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it
     * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or
     * explicitly destroyed by the new owner.
     */

  }, {
    key: "checkOut",
    value: function checkOut(callback) {
      var _this2 = this;

      this.emit(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));

      if (this.closed) {
        this.emit(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, 'poolClosed'));
        callback(new errors_1.PoolClosedError(this));
        return;
      }

      var waitQueueMember = {
        callback: callback
      };
      var waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;

      if (waitQueueTimeoutMS) {
        waitQueueMember.timer = (0, timers_1.setTimeout)(function () {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = undefined;

          _this2.emit(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(_this2, 'timeout'));

          waitQueueMember.callback(new errors_1.WaitQueueTimeoutError(_this2.loadBalanced ? _this2.waitQueueErrorMetrics() : 'Timed out while checking out a connection from connection pool', _this2.address));
        }, waitQueueTimeoutMS);
      }

      this[kWaitQueue].push(waitQueueMember);
      process.nextTick(function () {
        return _this2.processWaitQueue();
      });
    }
    /**
     * Check a connection into the pool.
     *
     * @param connection - The connection to check in
     */

  }, {
    key: "checkIn",
    value: function checkIn(connection) {
      var _this3 = this;

      var poolClosed = this.closed;
      var stale = this.connectionIsStale(connection);
      var willDestroy = !!(poolClosed || stale || connection.closed);

      if (!willDestroy) {
        connection.markAvailable();
        this[kConnections].unshift(connection);
      }

      this[kCheckedOut]--;
      this.emit(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));

      if (willDestroy) {
        var reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';
        this.destroyConnection(connection, reason);
      }

      process.nextTick(function () {
        return _this3.processWaitQueue();
      });
    }
    /**
     * Clear the pool
     *
     * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a
     * previous generation will eventually be pruned during subsequent checkouts.
     */

  }, {
    key: "clear",
    value: function clear(serviceId) {
      if (this.loadBalanced && serviceId) {
        var sid = serviceId.toHexString();
        var generation = this.serviceGenerations.get(sid); // Only need to worry if the generation exists, since it should
        // always be there but typescript needs the check.

        if (generation == null) {
          // TODO(NODE-3483)
          throw new error_1.MongoRuntimeError('Service generations are required in load balancer mode.');
        } else {
          // Increment the generation for the service id.
          this.serviceGenerations.set(sid, generation + 1);
        }
      } else {
        this[kGeneration] += 1;
      }

      this.emit(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, serviceId));
    }
  }, {
    key: "close",
    value: function close(_options, _cb) {
      var _this4 = this;

      var options = _options;
      var callback = _cb !== null && _cb !== void 0 ? _cb : _options;

      if (typeof options === 'function') {
        options = {};
      }

      options = Object.assign({
        force: false
      }, options);

      if (this.closed) {
        return callback();
      } // immediately cancel any in-flight connections


      this[kCancellationToken].emit('cancel'); // drain the wait queue

      while (this.waitQueueSize) {
        var waitQueueMember = this[kWaitQueue].pop();

        if (waitQueueMember) {
          if (waitQueueMember.timer) {
            (0, timers_1.clearTimeout)(waitQueueMember.timer);
          }

          if (!waitQueueMember[kCancelled]) {
            // TODO(NODE-3483): Replace with MongoConnectionPoolClosedError
            waitQueueMember.callback(new error_1.MongoRuntimeError('Connection pool closed'));
          }
        }
      } // clear the min pool size timer


      var minPoolSizeTimer = this[kMinPoolSizeTimer];

      if (minPoolSizeTimer) {
        (0, timers_1.clearTimeout)(minPoolSizeTimer);
      } // end the connection counter


      if (typeof this[kConnectionCounter]["return"] === 'function') {
        this[kConnectionCounter]["return"](undefined);
      } // mark the pool as closed immediately


      this[kPoolState] = exports.PoolState.closed;
      (0, utils_1.eachAsync)(this[kConnections].toArray(), function (conn, cb) {
        _this4.emit(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(_this4, conn, 'poolClosed'));

        conn.destroy(options, cb);
      }, function (err) {
        _this4[kConnections].clear();

        _this4.emit(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(_this4));

        callback(err);
      });
    }
    /**
     * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda
     * has completed by calling back.
     *
     * NOTE: please note the required signature of `fn`
     *
     * @remarks When in load balancer mode, connections can be pinned to cursors or transactions.
     *   In these cases we pass the connection in to this method to ensure it is used and a new
     *   connection is not checked out.
     *
     * @param conn - A pinned connection for use in load balancing mode.
     * @param fn - A function which operates on a managed connection
     * @param callback - The original callback
     */

  }, {
    key: "withConnection",
    value: function withConnection(conn, fn, callback) {
      var _this5 = this;

      if (conn) {
        // use the provided connection, and do _not_ check it in after execution
        fn(undefined, conn, function (fnErr, result) {
          if (typeof callback === 'function') {
            if (fnErr) {
              callback(fnErr);
            } else {
              callback(undefined, result);
            }
          }
        });
        return;
      }

      this.checkOut(function (err, conn) {
        // don't callback with `err` here, we might want to act upon it inside `fn`
        fn(err, conn, function (fnErr, result) {
          if (typeof callback === 'function') {
            if (fnErr) {
              callback(fnErr);
            } else {
              callback(undefined, result);
            }
          }

          if (conn) {
            _this5.checkIn(conn);
          }
        });
      });
    }
  }, {
    key: "destroyConnection",
    value: function destroyConnection(connection, reason) {
      this.emit(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason)); // destroy the connection

      process.nextTick(function () {
        return connection.destroy();
      });
    }
  }, {
    key: "connectionIsStale",
    value: function connectionIsStale(connection) {
      var serviceId = connection.serviceId;

      if (this.loadBalanced && serviceId) {
        var sid = serviceId.toHexString();
        var generation = this.serviceGenerations.get(sid);
        return connection.generation !== generation;
      }

      return connection.generation !== this[kGeneration];
    }
  }, {
    key: "connectionIsIdle",
    value: function connectionIsIdle(connection) {
      return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
    }
  }, {
    key: "connectionIsPerished",
    value: function connectionIsPerished(connection) {
      var isStale = this.connectionIsStale(connection);
      var isIdle = this.connectionIsIdle(connection);

      if (!isStale && !isIdle && !connection.closed) {
        return false;
      }

      var reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';
      this.destroyConnection(connection, reason);
      return true;
    }
  }, {
    key: "createConnection",
    value: function createConnection(callback) {
      var _this6 = this;

      var connectOptions = _objectSpread(_objectSpread({}, this.options), {}, {
        id: this[kConnectionCounter].next().value,
        generation: this[kGeneration],
        cancellationToken: this[kCancellationToken]
      });

      this[kPending]++; // This is our version of a "virtual" no-I/O connection as the spec requires

      this.emit(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, {
        id: connectOptions.id
      }));
      (0, connect_1.connect)(connectOptions, function (err, connection) {
        if (err || !connection) {
          _this6[kLogger].debug("connection attempt failed with error [".concat(JSON.stringify(err), "]"));

          callback(err);
          return;
        } // The pool might have closed since we started trying to create a connection


        if (_this6.closed) {
          _this6[kPending]--;
          connection.destroy({
            force: true
          });
          return;
        } // forward all events from the connection to the pool


        var _loop = function _loop() {
          var event = _arr[_i];
          connection.on(event, function (e) {
            return _this6.emit(event, e);
          });
        };

        for (var _i = 0, _arr = [].concat(_toConsumableArray(constants_1.APM_EVENTS), [connection_1.Connection.CLUSTER_TIME_RECEIVED]); _i < _arr.length; _i++) {
          _loop();
        }

        if (_this6.loadBalanced) {
          connection.on(connection_1.Connection.PINNED, function (pinType) {
            return _this6[kMetrics].markPinned(pinType);
          });
          connection.on(connection_1.Connection.UNPINNED, function (pinType) {
            return _this6[kMetrics].markUnpinned(pinType);
          });
          var serviceId = connection.serviceId;

          if (serviceId) {
            var generation;
            var sid = serviceId.toHexString();

            if (generation = _this6.serviceGenerations.get(sid)) {
              connection.generation = generation;
            } else {
              _this6.serviceGenerations.set(sid, 0);

              connection.generation = 0;
            }
          }
        }

        connection.markAvailable();

        _this6.emit(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(_this6, connection));

        callback(undefined, connection);
        return;
      });
    }
  }, {
    key: "ensureMinPoolSize",
    value: function ensureMinPoolSize() {
      var _this7 = this;

      var minPoolSize = this.options.minPoolSize;

      if (this.closed || minPoolSize === 0) {
        return;
      }

      if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {
        // NOTE: ensureMinPoolSize should not try to get all the pending
        // connection permits because that potentially delays the availability of
        // the connection to a checkout request
        this.createConnection(function (err, connection) {
          _this7[kPending]--;

          if (!err && connection) {
            _this7[kConnections].push(connection);

            process.nextTick(function () {
              return _this7.processWaitQueue();
            });
          }

          _this7[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(function () {
            return _this7.ensureMinPoolSize();
          }, 10);
        });
      } else {
        this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(function () {
          return _this7.ensureMinPoolSize();
        }, 100);
      }
    }
  }, {
    key: "processWaitQueue",
    value: function processWaitQueue() {
      var _this8 = this;

      if (this.closed || this[kProcessingWaitQueue]) {
        return;
      }

      this[kProcessingWaitQueue] = true;

      while (this.waitQueueSize) {
        var waitQueueMember = this[kWaitQueue].peekFront();

        if (!waitQueueMember) {
          this[kWaitQueue].shift();
          continue;
        }

        if (waitQueueMember[kCancelled]) {
          this[kWaitQueue].shift();
          continue;
        }

        if (!this.availableConnectionCount) {
          break;
        }

        var connection = this[kConnections].shift();

        if (!connection) {
          break;
        }

        if (!this.connectionIsPerished(connection)) {
          this[kCheckedOut]++;
          this.emit(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection));

          if (waitQueueMember.timer) {
            (0, timers_1.clearTimeout)(waitQueueMember.timer);
          }

          this[kWaitQueue].shift();
          waitQueueMember.callback(undefined, connection);
        }
      }

      var _this$options = this.options,
          maxPoolSize = _this$options.maxPoolSize,
          maxConnecting = _this$options.maxConnecting;

      var _loop2 = function _loop2() {
        var waitQueueMember = _this8[kWaitQueue].shift();

        if (!waitQueueMember || waitQueueMember[kCancelled]) {
          return "continue";
        }

        _this8.createConnection(function (err, connection) {
          _this8[kPending]--;

          if (waitQueueMember[kCancelled]) {
            if (!err && connection) {
              _this8[kConnections].push(connection);
            }
          } else {
            if (err) {
              _this8.emit(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(_this8, err));
            } else if (connection) {
              _this8[kCheckedOut]++;

              _this8.emit(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(_this8, connection));
            }

            if (waitQueueMember.timer) {
              (0, timers_1.clearTimeout)(waitQueueMember.timer);
            }

            waitQueueMember.callback(err, connection);
          }

          process.nextTick(function () {
            return _this8.processWaitQueue();
          });
        });
      };

      while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
        var _ret = _loop2();

        if (_ret === "continue") continue;
      }

      this[kProcessingWaitQueue] = false;
    }
  }]);

  return ConnectionPool;
}(mongo_types_1.TypedEventEmitter);

exports.ConnectionPool = ConnectionPool;
/**
 * Emitted when the connection pool is created.
 * @event
 */

ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
/**
 * Emitted once when the connection pool is closed
 * @event
 */

ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
/**
 * Emitted each time the connection pool is cleared and it's generation incremented
 * @event
 */

ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
/**
 * Emitted when a connection is created.
 * @event
 */

ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
/**
 * Emitted when a connection becomes established, and is ready to use
 * @event
 */

ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
/**
 * Emitted when a connection is closed
 * @event
 */

ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
/**
 * Emitted when an attempt to check out a connection begins
 * @event
 */

ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
/**
 * Emitted when an attempt to check out a connection fails
 * @event
 */

ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
/**
 * Emitted each time a connection is successfully checked out of the connection pool
 * @event
 */

ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
/**
 * Emitted each time a connection is successfully checked into the connection pool
 * @event
 */

ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;

/***/ }),

/***/ 640:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionPoolClearedEvent = exports.ConnectionCheckedInEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolMonitoringEvent = void 0;
/**
 * The base export class for all monitoring events published from the connection pool
 * @public
 * @category Event
 */

var ConnectionPoolMonitoringEvent = /*#__PURE__*/_createClass(
/** @internal */
function ConnectionPoolMonitoringEvent(pool) {
  _classCallCheck(this, ConnectionPoolMonitoringEvent);

  this.time = new Date();
  this.address = pool.address;
});

exports.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;
/**
 * An event published when a connection pool is created
 * @public
 * @category Event
 */

var ConnectionPoolCreatedEvent = /*#__PURE__*/function (_ConnectionPoolMonito) {
  _inherits(ConnectionPoolCreatedEvent, _ConnectionPoolMonito);

  var _super = _createSuper(ConnectionPoolCreatedEvent);

  /** @internal */
  function ConnectionPoolCreatedEvent(pool) {
    var _this;

    _classCallCheck(this, ConnectionPoolCreatedEvent);

    _this = _super.call(this, pool);
    _this.options = pool.options;
    return _this;
  }

  return _createClass(ConnectionPoolCreatedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;
/**
 * An event published when a connection pool is closed
 * @public
 * @category Event
 */

var ConnectionPoolClosedEvent = /*#__PURE__*/function (_ConnectionPoolMonito2) {
  _inherits(ConnectionPoolClosedEvent, _ConnectionPoolMonito2);

  var _super2 = _createSuper(ConnectionPoolClosedEvent);

  /** @internal */
  function ConnectionPoolClosedEvent(pool) {
    _classCallCheck(this, ConnectionPoolClosedEvent);

    return _super2.call(this, pool);
  }

  return _createClass(ConnectionPoolClosedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;
/**
 * An event published when a connection pool creates a new connection
 * @public
 * @category Event
 */

var ConnectionCreatedEvent = /*#__PURE__*/function (_ConnectionPoolMonito3) {
  _inherits(ConnectionCreatedEvent, _ConnectionPoolMonito3);

  var _super3 = _createSuper(ConnectionCreatedEvent);

  /** @internal */
  function ConnectionCreatedEvent(pool, connection) {
    var _this2;

    _classCallCheck(this, ConnectionCreatedEvent);

    _this2 = _super3.call(this, pool);
    _this2.connectionId = connection.id;
    return _this2;
  }

  return _createClass(ConnectionCreatedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCreatedEvent = ConnectionCreatedEvent;
/**
 * An event published when a connection is ready for use
 * @public
 * @category Event
 */

var ConnectionReadyEvent = /*#__PURE__*/function (_ConnectionPoolMonito4) {
  _inherits(ConnectionReadyEvent, _ConnectionPoolMonito4);

  var _super4 = _createSuper(ConnectionReadyEvent);

  /** @internal */
  function ConnectionReadyEvent(pool, connection) {
    var _this3;

    _classCallCheck(this, ConnectionReadyEvent);

    _this3 = _super4.call(this, pool);
    _this3.connectionId = connection.id;
    return _this3;
  }

  return _createClass(ConnectionReadyEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionReadyEvent = ConnectionReadyEvent;
/**
 * An event published when a connection is closed
 * @public
 * @category Event
 */

var ConnectionClosedEvent = /*#__PURE__*/function (_ConnectionPoolMonito5) {
  _inherits(ConnectionClosedEvent, _ConnectionPoolMonito5);

  var _super5 = _createSuper(ConnectionClosedEvent);

  /** @internal */
  function ConnectionClosedEvent(pool, connection, reason) {
    var _this4;

    _classCallCheck(this, ConnectionClosedEvent);

    _this4 = _super5.call(this, pool);
    _this4.connectionId = connection.id;
    _this4.reason = reason || 'unknown';
    _this4.serviceId = connection.serviceId;
    return _this4;
  }

  return _createClass(ConnectionClosedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionClosedEvent = ConnectionClosedEvent;
/**
 * An event published when a request to check a connection out begins
 * @public
 * @category Event
 */

var ConnectionCheckOutStartedEvent = /*#__PURE__*/function (_ConnectionPoolMonito6) {
  _inherits(ConnectionCheckOutStartedEvent, _ConnectionPoolMonito6);

  var _super6 = _createSuper(ConnectionCheckOutStartedEvent);

  /** @internal */
  function ConnectionCheckOutStartedEvent(pool) {
    _classCallCheck(this, ConnectionCheckOutStartedEvent);

    return _super6.call(this, pool);
  }

  return _createClass(ConnectionCheckOutStartedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;
/**
 * An event published when a request to check a connection out fails
 * @public
 * @category Event
 */

var ConnectionCheckOutFailedEvent = /*#__PURE__*/function (_ConnectionPoolMonito7) {
  _inherits(ConnectionCheckOutFailedEvent, _ConnectionPoolMonito7);

  var _super7 = _createSuper(ConnectionCheckOutFailedEvent);

  /** @internal */
  function ConnectionCheckOutFailedEvent(pool, reason) {
    var _this5;

    _classCallCheck(this, ConnectionCheckOutFailedEvent);

    _this5 = _super7.call(this, pool);
    _this5.reason = reason;
    return _this5;
  }

  return _createClass(ConnectionCheckOutFailedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;
/**
 * An event published when a connection is checked out of the connection pool
 * @public
 * @category Event
 */

var ConnectionCheckedOutEvent = /*#__PURE__*/function (_ConnectionPoolMonito8) {
  _inherits(ConnectionCheckedOutEvent, _ConnectionPoolMonito8);

  var _super8 = _createSuper(ConnectionCheckedOutEvent);

  /** @internal */
  function ConnectionCheckedOutEvent(pool, connection) {
    var _this6;

    _classCallCheck(this, ConnectionCheckedOutEvent);

    _this6 = _super8.call(this, pool);
    _this6.connectionId = connection.id;
    return _this6;
  }

  return _createClass(ConnectionCheckedOutEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;
/**
 * An event published when a connection is checked into the connection pool
 * @public
 * @category Event
 */

var ConnectionCheckedInEvent = /*#__PURE__*/function (_ConnectionPoolMonito9) {
  _inherits(ConnectionCheckedInEvent, _ConnectionPoolMonito9);

  var _super9 = _createSuper(ConnectionCheckedInEvent);

  /** @internal */
  function ConnectionCheckedInEvent(pool, connection) {
    var _this7;

    _classCallCheck(this, ConnectionCheckedInEvent);

    _this7 = _super9.call(this, pool);
    _this7.connectionId = connection.id;
    return _this7;
  }

  return _createClass(ConnectionCheckedInEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionCheckedInEvent = ConnectionCheckedInEvent;
/**
 * An event published when a connection pool is cleared
 * @public
 * @category Event
 */

var ConnectionPoolClearedEvent = /*#__PURE__*/function (_ConnectionPoolMonito10) {
  _inherits(ConnectionPoolClearedEvent, _ConnectionPoolMonito10);

  var _super10 = _createSuper(ConnectionPoolClearedEvent);

  /** @internal */
  function ConnectionPoolClearedEvent(pool, serviceId) {
    var _this8;

    _classCallCheck(this, ConnectionPoolClearedEvent);

    _this8 = _super10.call(this, pool);
    _this8.serviceId = serviceId;
    return _this8;
  }

  return _createClass(ConnectionPoolClearedEvent);
}(ConnectionPoolMonitoringEvent);

exports.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;

/***/ }),

/***/ 1171:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WaitQueueTimeoutError = exports.PoolClosedError = void 0;

var error_1 = __webpack_require__(9271);
/**
 * An error indicating a connection pool is closed
 * @category Error
 */


var PoolClosedError = /*#__PURE__*/function (_error_1$MongoDriverE) {
  _inherits(PoolClosedError, _error_1$MongoDriverE);

  var _super = _createSuper(PoolClosedError);

  function PoolClosedError(pool) {
    var _this;

    _classCallCheck(this, PoolClosedError);

    _this = _super.call(this, 'Attempted to check out a connection from closed connection pool');
    _this.address = pool.address;
    return _this;
  }

  _createClass(PoolClosedError, [{
    key: "name",
    get: function get() {
      return 'MongoPoolClosedError';
    }
  }]);

  return PoolClosedError;
}(error_1.MongoDriverError);

exports.PoolClosedError = PoolClosedError;
/**
 * An error thrown when a request to check out a connection times out
 * @category Error
 */

var WaitQueueTimeoutError = /*#__PURE__*/function (_error_1$MongoDriverE2) {
  _inherits(WaitQueueTimeoutError, _error_1$MongoDriverE2);

  var _super2 = _createSuper(WaitQueueTimeoutError);

  function WaitQueueTimeoutError(message, address) {
    var _this2;

    _classCallCheck(this, WaitQueueTimeoutError);

    _this2 = _super2.call(this, message);
    _this2.address = address;
    return _this2;
  }

  _createClass(WaitQueueTimeoutError, [{
    key: "name",
    get: function get() {
      return 'MongoWaitQueueTimeoutError';
    }
  }]);

  return WaitQueueTimeoutError;
}(error_1.MongoDriverError);

exports.WaitQueueTimeoutError = WaitQueueTimeoutError;

/***/ }),

/***/ 7658:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageStream = void 0;

var stream_1 = __webpack_require__(2781);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var commands_1 = __webpack_require__(8338);

var compression_1 = __webpack_require__(2501);

var constants_1 = __webpack_require__(8871);

var MESSAGE_HEADER_SIZE = 16;
var COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID

var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
/** @internal */

var kBuffer = Symbol('buffer');
/**
 * A duplex stream that is capable of reading and writing raw wire protocol messages, with
 * support for optional compression
 * @internal
 */

var MessageStream = /*#__PURE__*/function (_stream_1$Duplex) {
  _inherits(MessageStream, _stream_1$Duplex);

  var _super = _createSuper(MessageStream);

  function MessageStream() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MessageStream);

    _this = _super.call(this, options);
    /** @internal */

    _this.isMonitoringConnection = false;
    _this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
    _this[kBuffer] = new utils_1.BufferPool();
    return _this;
  }

  _createClass(MessageStream, [{
    key: "buffer",
    get: function get() {
      return this[kBuffer];
    }
  }, {
    key: "_write",
    value: function _write(chunk, _, callback) {
      this[kBuffer].append(chunk);
      processIncomingData(this, callback);
    }
  }, {
    key: "_read",
    value: function
      /* size */
    _read() {
      // NOTE: This implementation is empty because we explicitly push data to be read
      //       when `writeMessage` is called.
      return;
    }
  }, {
    key: "writeCommand",
    value: function writeCommand(command, operationDescription) {
      var _this2 = this;

      // TODO: agreed compressor should live in `StreamDescription`
      var compressorName = operationDescription && operationDescription.agreedCompressor ? operationDescription.agreedCompressor : 'none';

      if (compressorName === 'none' || !canCompress(command)) {
        var data = command.toBin();
        this.push(Array.isArray(data) ? Buffer.concat(data) : data);
        return;
      } // otherwise, compress the message


      var concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
      var messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message

      var originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body

      (0, compression_1.compress)({
        options: operationDescription
      }, messageToBeCompressed, function (err, compressedMessage) {
        if (err || !compressedMessage) {
          operationDescription.cb(err);
          return;
        } // Create the msgHeader of OP_COMPRESSED


        var msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength

        msgHeader.writeInt32LE(command.requestId, 4); // requestID

        msgHeader.writeInt32LE(0, 8); // responseTo (zero)

        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode
        // Create the compression details of OP_COMPRESSED

        var compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode

        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader

        compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID

        _this2.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
      });
    }
  }]);

  return MessageStream;
}(stream_1.Duplex);

exports.MessageStream = MessageStream; // Return whether a command contains an uncompressible command term
// Will return true if command contains no uncompressible command terms

function canCompress(command) {
  var commandDoc = command instanceof commands_1.Msg ? command.command : command.query;
  var commandName = Object.keys(commandDoc)[0];
  return !compression_1.uncompressibleCommands.has(commandName);
}

function processIncomingData(stream, callback) {
  var buffer = stream[kBuffer];

  if (buffer.length < 4) {
    callback();
    return;
  }

  var sizeOfMessage = buffer.peek(4).readInt32LE();

  if (sizeOfMessage < 0) {
    callback(new error_1.MongoParseError("Invalid message size: ".concat(sizeOfMessage)));
    return;
  }

  if (sizeOfMessage > stream.maxBsonMessageSize) {
    callback(new error_1.MongoParseError("Invalid message size: ".concat(sizeOfMessage, ", max allowed: ").concat(stream.maxBsonMessageSize)));
    return;
  }

  if (sizeOfMessage > buffer.length) {
    callback();
    return;
  }

  var message = buffer.read(sizeOfMessage);
  var messageHeader = {
    length: message.readInt32LE(0),
    requestId: message.readInt32LE(4),
    responseTo: message.readInt32LE(8),
    opCode: message.readInt32LE(12)
  };

  var monitorHasAnotherHello = function monitorHasAnotherHello() {
    if (stream.isMonitoringConnection) {
      // Can we read the next message size?
      if (buffer.length >= 4) {
        var _sizeOfMessage = buffer.peek(4).readInt32LE();

        if (_sizeOfMessage <= buffer.length) {
          return true;
        }
      }
    }

    return false;
  };

  var ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;

  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {
    var messageBody = message.slice(MESSAGE_HEADER_SIZE); // If we are a monitoring connection message stream and
    // there is more in the buffer that can be read, skip processing since we
    // want the last hello command response that is in the buffer.

    if (monitorHasAnotherHello()) {
      processIncomingData(stream, callback);
    } else {
      stream.emit('message', new ResponseType(message, messageHeader, messageBody));

      if (buffer.length >= 4) {
        processIncomingData(stream, callback);
      } else {
        callback();
      }
    }

    return;
  }

  messageHeader.fromCompressed = true;
  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
  var compressorID = message[MESSAGE_HEADER_SIZE + 8];
  var compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode

  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;
  (0, compression_1.decompress)(compressorID, compressedBuffer, function (err, messageBody) {
    if (err || !messageBody) {
      callback(err);
      return;
    }

    if (messageBody.length !== messageHeader.length) {
      callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));
      return;
    } // If we are a monitoring connection message stream and
    // there is more in the buffer that can be read, skip processing since we
    // want the last hello command response that is in the buffer.


    if (monitorHasAnotherHello()) {
      processIncomingData(stream, callback);
    } else {
      stream.emit('message', new ResponseType(message, messageHeader, messageBody));

      if (buffer.length >= 4) {
        processIncomingData(stream, callback);
      } else {
        callback();
      }
    }
  });
}

/***/ }),

/***/ 8274:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionPoolMetrics = void 0;
/** @internal */

var ConnectionPoolMetrics = /*#__PURE__*/function () {
  function ConnectionPoolMetrics() {
    _classCallCheck(this, ConnectionPoolMetrics);

    this.txnConnections = 0;
    this.cursorConnections = 0;
    this.otherConnections = 0;
  }
  /**
   * Mark a connection as pinned for a specific operation.
   */


  _createClass(ConnectionPoolMetrics, [{
    key: "markPinned",
    value: function markPinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections += 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections += 1;
      } else {
        this.otherConnections += 1;
      }
    }
    /**
     * Unmark a connection as pinned for an operation.
     */

  }, {
    key: "markUnpinned",
    value: function markUnpinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections -= 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections -= 1;
      } else {
        this.otherConnections -= 1;
      }
    }
    /**
     * Return information about the cmap metrics as a string.
     */

  }, {
    key: "info",
    value: function info(maxPoolSize) {
      return 'Timed out while checking out a connection from connection pool: ' + "maxPoolSize: ".concat(maxPoolSize, ", ") + "connections in use by cursors: ".concat(this.cursorConnections, ", ") + "connections in use by transactions: ".concat(this.txnConnections, ", ") + "connections in use by other operations: ".concat(this.otherConnections);
    }
    /**
     * Reset the metrics to the initial values.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
  }]);

  return ConnectionPoolMetrics;
}();

exports.ConnectionPoolMetrics = ConnectionPoolMetrics;
ConnectionPoolMetrics.TXN = 'txn';
ConnectionPoolMetrics.CURSOR = 'cursor';
ConnectionPoolMetrics.OTHER = 'other';

/***/ }),

/***/ 2632:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StreamDescription = void 0;

var common_1 = __webpack_require__(4118);

var server_description_1 = __webpack_require__(1071);

var RESPONSE_FIELDS = ['minWireVersion', 'maxWireVersion', 'maxBsonObjectSize', 'maxMessageSizeBytes', 'maxWriteBatchSize', 'logicalSessionTimeoutMinutes'];
/** @public */

var StreamDescription = /*#__PURE__*/function () {
  function StreamDescription(address, options) {
    _classCallCheck(this, StreamDescription);

    this.address = address;
    this.type = common_1.ServerType.Unknown;
    this.minWireVersion = undefined;
    this.maxWireVersion = undefined;
    this.maxBsonObjectSize = 16777216;
    this.maxMessageSizeBytes = 48000000;
    this.maxWriteBatchSize = 100000;
    this.logicalSessionTimeoutMinutes = options === null || options === void 0 ? void 0 : options.logicalSessionTimeoutMinutes;
    this.loadBalanced = !!(options === null || options === void 0 ? void 0 : options.loadBalanced);
    this.compressors = options && options.compressors && Array.isArray(options.compressors) ? options.compressors : [];
  }

  _createClass(StreamDescription, [{
    key: "receiveResponse",
    value: function receiveResponse(response) {
      if (response == null) {
        return;
      }

      this.type = (0, server_description_1.parseServerType)(response);

      var _iterator = _createForOfIteratorHelper(RESPONSE_FIELDS),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var field = _step.value;

          if (response[field] != null) {
            this[field] = response[field];
          } // testing case


          if ('__nodejs_mock_server__' in response) {
            this.__nodejs_mock_server__ = response['__nodejs_mock_server__'];
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (response.compression) {
        this.compressor = this.compressors.filter(function (c) {
          var _a;

          return (_a = response.compression) === null || _a === void 0 ? void 0 : _a.includes(c);
        })[0];
      }
    }
  }]);

  return StreamDescription;
}();

exports.StreamDescription = StreamDescription;

/***/ }),

/***/ 2501:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;

var zlib = __webpack_require__(9796);

var constants_1 = __webpack_require__(1254);

var deps_1 = __webpack_require__(2524);

var error_1 = __webpack_require__(9271);
/** @public */


exports.Compressor = Object.freeze({
  none: 0,
  snappy: 1,
  zlib: 2,
  zstd: 3
});
exports.uncompressibleCommands = new Set([constants_1.LEGACY_HELLO_COMMAND, 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']);
var MAX_COMPRESSOR_ID = 3;
var ZSTD_COMPRESSION_LEVEL = 3; // Facilitate compressing a message using an agreed compressor

function compress(self, dataToBeCompressed, callback) {
  var zlibOptions = {};

  switch (self.options.agreedCompressor) {
    case 'snappy':
      {
        if ('kModuleError' in deps_1.Snappy) {
          return callback(deps_1.Snappy['kModuleError']);
        }

        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {
          deps_1.Snappy.compress(dataToBeCompressed, callback);
        } else {
          deps_1.Snappy.compress(dataToBeCompressed).then(function (buffer) {
            return callback(undefined, buffer);
          }, function (error) {
            return callback(error);
          });
        }

        break;
      }

    case 'zlib':
      // Determine zlibCompressionLevel
      if (self.options.zlibCompressionLevel) {
        zlibOptions.level = self.options.zlibCompressionLevel;
      }

      zlib.deflate(dataToBeCompressed, zlibOptions, callback);
      break;

    case 'zstd':
      if ('kModuleError' in deps_1.ZStandard) {
        return callback(deps_1.ZStandard['kModuleError']);
      }

      deps_1.ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then(function (buffer) {
        return callback(undefined, buffer);
      }, function (error) {
        return callback(error);
      });
      break;

    default:
      throw new error_1.MongoInvalidArgumentError("Unknown compressor ".concat(self.options.agreedCompressor, " failed to compress"));
  }
}

exports.compress = compress; // Decompress a message using the given compressor

function decompress(compressorID, compressedData, callback) {
  if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {
    throw new error_1.MongoDecompressionError("Server sent message compressed using an unsupported compressor. (Received compressor ID ".concat(compressorID, ")"));
  }

  switch (compressorID) {
    case exports.Compressor.snappy:
      {
        if ('kModuleError' in deps_1.Snappy) {
          return callback(deps_1.Snappy['kModuleError']);
        }

        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {
          deps_1.Snappy.uncompress(compressedData, {
            asBuffer: true
          }, callback);
        } else {
          deps_1.Snappy.uncompress(compressedData, {
            asBuffer: true
          }).then(function (buffer) {
            return callback(undefined, buffer);
          }, function (error) {
            return callback(error);
          });
        }

        break;
      }

    case exports.Compressor.zstd:
      {
        if ('kModuleError' in deps_1.ZStandard) {
          return callback(deps_1.ZStandard['kModuleError']);
        }

        deps_1.ZStandard.decompress(compressedData).then(function (buffer) {
          return callback(undefined, buffer);
        }, function (error) {
          return callback(error);
        });
        break;
      }

    case exports.Compressor.zlib:
      zlib.inflate(compressedData, callback);
      break;

    default:
      callback(undefined, compressedData);
  }
}

exports.decompress = decompress;

/***/ }),

/***/ 8871:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OP_MSG = exports.OP_COMPRESSED = exports.OP_DELETE = exports.OP_QUERY = exports.OP_INSERT = exports.OP_UPDATE = exports.OP_REPLY = exports.MAX_SUPPORTED_WIRE_VERSION = exports.MIN_SUPPORTED_WIRE_VERSION = exports.MAX_SUPPORTED_SERVER_VERSION = exports.MIN_SUPPORTED_SERVER_VERSION = void 0;
exports.MIN_SUPPORTED_SERVER_VERSION = '3.6';
exports.MAX_SUPPORTED_SERVER_VERSION = '6.0';
exports.MIN_SUPPORTED_WIRE_VERSION = 6;
exports.MAX_SUPPORTED_WIRE_VERSION = 17;
exports.OP_REPLY = 1;
exports.OP_UPDATE = 2001;
exports.OP_INSERT = 2002;
exports.OP_QUERY = 2004;
exports.OP_DELETE = 2006;
exports.OP_COMPRESSED = 2012;
exports.OP_MSG = 2013;

/***/ }),

/***/ 4242:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isSharded = exports.applyCommonQueryOptions = exports.getReadPreference = void 0;

var error_1 = __webpack_require__(9271);

var read_preference_1 = __webpack_require__(3985);

var common_1 = __webpack_require__(4118);

var topology_description_1 = __webpack_require__(4201);

function getReadPreference(cmd, options) {
  // Default to command version of the readPreference
  var readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary; // If we have an option readPreference override the command one

  if (options === null || options === void 0 ? void 0 : options.readPreference) {
    readPreference = options.readPreference;
  }

  if (typeof readPreference === 'string') {
    readPreference = read_preference_1.ReadPreference.fromString(readPreference);
  }

  if (!(readPreference instanceof read_preference_1.ReadPreference)) {
    throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
  }

  return readPreference;
}

exports.getReadPreference = getReadPreference;

function applyCommonQueryOptions(queryOptions, options) {
  Object.assign(queryOptions, {
    raw: typeof options.raw === 'boolean' ? options.raw : false,
    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,
    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,
    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,
    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,
    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true
  });

  if (options.session) {
    queryOptions.session = options.session;
  }

  return queryOptions;
}

exports.applyCommonQueryOptions = applyCommonQueryOptions;

function isSharded(topologyOrServer) {
  if (topologyOrServer == null) {
    return false;
  }

  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
    return true;
  } // NOTE: This is incredibly inefficient, and should be removed once command construction
  //       happens based on `Server` not `Topology`.


  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
    var servers = Array.from(topologyOrServer.description.servers.values());
    return servers.some(function (server) {
      return server.type === common_1.ServerType.Mongos;
    });
  }

  return false;
}

exports.isSharded = isSharded;

/***/ }),

/***/ 9730:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Collection = void 0;

var bson_1 = __webpack_require__(53);

var ordered_1 = __webpack_require__(1409);

var unordered_1 = __webpack_require__(1878);

var change_stream_1 = __webpack_require__(4672);

var aggregation_cursor_1 = __webpack_require__(5983);

var find_cursor_1 = __webpack_require__(1284);

var list_indexes_cursor_1 = __webpack_require__(668);

var error_1 = __webpack_require__(9271);

var bulk_write_1 = __webpack_require__(492);

var count_1 = __webpack_require__(2307);

var count_documents_1 = __webpack_require__(4961);

var delete_1 = __webpack_require__(7857);

var distinct_1 = __webpack_require__(6192);

var drop_1 = __webpack_require__(406);

var estimated_document_count_1 = __webpack_require__(2261);

var execute_operation_1 = __webpack_require__(7887);

var find_and_modify_1 = __webpack_require__(2016);

var indexes_1 = __webpack_require__(6338);

var insert_1 = __webpack_require__(2330);

var is_capped_1 = __webpack_require__(5707);

var map_reduce_1 = __webpack_require__(8600);

var options_operation_1 = __webpack_require__(2320);

var rename_1 = __webpack_require__(8851);

var stats_1 = __webpack_require__(9073);

var update_1 = __webpack_require__(6262);

var read_concern_1 = __webpack_require__(2027);

var read_preference_1 = __webpack_require__(3985);

var utils_1 = __webpack_require__(4356);

var write_concern_1 = __webpack_require__(1473);
/**
 * The **Collection** class is an internal class that embodies a MongoDB collection
 * allowing for insert/update/remove/find and other command operation on that MongoDB collection.
 *
 * **COLLECTION Cannot directly be instantiated**
 * @public
 *
 * @example
 * ```js
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) {
 *   // Create a collection we want to drop later
 *   const col = client.db(dbName).collection('createIndexExample1');
 *   // Show that duplicate records got dropped
 *   col.find({}).toArray(function(err, items) {
 *     expect(err).to.not.exist;
 *     test.equal(4, items.length);
 *     client.close();
 *   });
 * });
 * ```
 */


var Collection = /*#__PURE__*/function () {
  /**
   * Create a new Collection instance
   * @internal
   */
  function Collection(db, name, options) {
    _classCallCheck(this, Collection);

    var _a, _b;

    (0, utils_1.checkCollectionName)(name); // Internal state

    this.s = {
      db: db,
      options: options,
      namespace: new utils_1.MongoDBNamespace(db.databaseName, name),
      pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,
      readPreference: read_preference_1.ReadPreference.fromOptions(options),
      bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),
      readConcern: read_concern_1.ReadConcern.fromOptions(options),
      writeConcern: write_concern_1.WriteConcern.fromOptions(options)
    };
  }
  /**
   * The name of the database this collection belongs to
   */


  _createClass(Collection, [{
    key: "dbName",
    get: function get() {
      return this.s.namespace.db;
    }
    /**
     * The name of this collection
     */

  }, {
    key: "collectionName",
    get: function get() {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return this.s.namespace.collection;
    }
    /**
     * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`
     */

  }, {
    key: "namespace",
    get: function get() {
      return this.s.namespace.toString();
    }
    /**
     * The current readConcern of the collection. If not explicitly defined for
     * this collection, will be inherited from the parent DB
     */

  }, {
    key: "readConcern",
    get: function get() {
      if (this.s.readConcern == null) {
        return this.s.db.readConcern;
      }

      return this.s.readConcern;
    }
    /**
     * The current readPreference of the collection. If not explicitly defined for
     * this collection, will be inherited from the parent DB
     */

  }, {
    key: "readPreference",
    get: function get() {
      if (this.s.readPreference == null) {
        return this.s.db.readPreference;
      }

      return this.s.readPreference;
    }
  }, {
    key: "bsonOptions",
    get: function get() {
      return this.s.bsonOptions;
    }
    /**
     * The current writeConcern of the collection. If not explicitly defined for
     * this collection, will be inherited from the parent DB
     */

  }, {
    key: "writeConcern",
    get: function get() {
      if (this.s.writeConcern == null) {
        return this.s.db.writeConcern;
      }

      return this.s.writeConcern;
    }
    /** The current index hint for the collection */

  }, {
    key: "hint",
    get: function get() {
      return this.s.collectionHint;
    },
    set: function set(v) {
      this.s.collectionHint = (0, utils_1.normalizeHintField)(v);
    }
  }, {
    key: "insertOne",
    value: function insertOne(doc, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      } // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x
      // we support that option style here only


      if (options && Reflect.get(options, 'w')) {
        options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));
      }

      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "insertMany",
    value: function insertMany(docs, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options ? Object.assign({}, options) : {
        ordered: true
      };
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "bulkWrite",
    value: function bulkWrite(operations, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options || {
        ordered: true
      };

      if (!Array.isArray(operations)) {
        throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
      }

      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "updateOne",
    value: function updateOne(filter, update, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "replaceOne",
    value: function replaceOne(filter, replacement, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "updateMany",
    value: function updateMany(filter, update, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "deleteOne",
    value: function deleteOne(filter, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "deleteMany",
    value: function deleteMany(filter, options, callback) {
      if (filter == null) {
        filter = {};
        options = {};
        callback = undefined;
      } else if (typeof filter === 'function') {
        callback = filter;
        filter = {};
        options = {};
      } else if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "rename",
    value: function rename(newName, options, callback) {
      if (typeof options === 'function') callback = options, options = {}; // Intentionally, we do not inherit options from parent for this operation.

      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new rename_1.RenameOperation(this, newName, _objectSpread(_objectSpread({}, options), {}, {
        readPreference: read_preference_1.ReadPreference.PRIMARY
      })), callback);
    }
  }, {
    key: "drop",
    value: function drop(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);
    }
  }, {
    key: "findOne",
    value: function findOne(filter, options, callback) {
      if (callback != null && typeof callback !== 'function') {
        throw new error_1.MongoInvalidArgumentError('Third parameter to `findOne()` must be a callback or undefined');
      }

      if (typeof filter === 'function') {
        callback = filter;
        filter = {};
        options = {};
      }

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      var finalFilter = filter !== null && filter !== void 0 ? filter : {};
      var finalOptions = options !== null && options !== void 0 ? options : {};
      return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);
    }
  }, {
    key: "find",
    value: function find(filter, options) {
      if (arguments.length > 2) {
        throw new error_1.MongoInvalidArgumentError('Method "collection.find()" accepts at most two arguments');
      }

      if (typeof options === 'function') {
        throw new error_1.MongoInvalidArgumentError('Argument "options" must not be function');
      }

      return new find_cursor_1.FindCursor(this.s.db.s.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));
    }
  }, {
    key: "options",
    value: function options(_options, callback) {
      if (typeof _options === 'function') callback = _options, _options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, _options)), callback);
    }
  }, {
    key: "isCapped",
    value: function isCapped(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "createIndex",
    value: function createIndex(indexSpec, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "createIndexes",
    value: function createIndexes(indexSpecs, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options ? Object.assign({}, options) : {};
      if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "dropIndex",
    value: function dropIndex(indexName, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = (0, utils_1.resolveOptions)(this, options); // Run only against primary

      options.readPreference = read_preference_1.ReadPreference.primary;
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexOperation(this, indexName, options), callback);
    }
  }, {
    key: "dropIndexes",
    value: function dropIndexes(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
    }
    /**
     * Get the list of all indexes information for the collection.
     *
     * @param options - Optional settings for the command
     */

  }, {
    key: "listIndexes",
    value: function listIndexes(options) {
      return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));
    }
  }, {
    key: "indexExists",
    value: function indexExists(indexes, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "indexInformation",
    value: function indexInformation(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "estimatedDocumentCount",
    value: function estimatedDocumentCount(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "countDocuments",
    value: function countDocuments(filter, options, callback) {
      if (filter == null) {
        filter = {}, options = {}, callback = undefined;
      } else if (typeof filter === 'function') {
        callback = filter, filter = {}, options = {};
      } else {
        if (arguments.length === 2) {
          if (typeof options === 'function') callback = options, options = {};
        }
      }

      filter !== null && filter !== void 0 ? filter : filter = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);
    } // Implementation

  }, {
    key: "distinct",
    value: function distinct(key, filter, options, callback) {
      if (typeof filter === 'function') {
        callback = filter, filter = {}, options = {};
      } else {
        if (arguments.length === 3 && typeof options === 'function') {
          callback = options, options = {};
        }
      }

      filter !== null && filter !== void 0 ? filter : filter = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "indexes",
    value: function indexes(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "stats",
    value: function stats(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new stats_1.CollStatsOperation(this, options), callback);
    }
  }, {
    key: "findOneAndDelete",
    value: function findOneAndDelete(filter, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "findOneAndReplace",
    value: function findOneAndReplace(filter, replacement, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "findOneAndUpdate",
    value: function findOneAndUpdate(filter, update, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);
    }
    /**
     * Execute an aggregation framework pipeline against the collection, needs MongoDB \>= 2.2
     *
     * @param pipeline - An array of aggregation pipelines to execute
     * @param options - Optional settings for the command
     */

  }, {
    key: "aggregate",
    value: function aggregate() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 ? arguments[1] : undefined;

      if (arguments.length > 2) {
        throw new error_1.MongoInvalidArgumentError('Method "collection.aggregate()" accepts at most two arguments');
      }

      if (!Array.isArray(pipeline)) {
        throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
      }

      if (typeof options === 'function') {
        throw new error_1.MongoInvalidArgumentError('Argument "options" must not be function');
      }

      return new aggregation_cursor_1.AggregationCursor(this.s.db.s.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
     *
     * @remarks
     * watch() accepts two generic arguments for distinct usecases:
     * - The first is to override the schema that may be defined for this specific collection
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     * @example
     * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`
     * ```ts
     * collection.watch<{ _id: number }>()
     *   .on('change', change => console.log(change._id.toFixed(4)));
     * ```
     *
     * @example
     * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.
     * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.
     * No need start from scratch on the ChangeStreamInsertDocument type!
     * By using an intersection we can save time and ensure defaults remain the same type!
     * ```ts
     * collection
     *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([
     *     { $addFields: { comment: 'big changes' } },
     *     { $match: { operationType: 'insert' } }
     *   ])
     *   .on('change', change => {
     *     change.comment.startsWith('big');
     *     change.operationType === 'insert';
     *     // No need to narrow in code because the generics did that for us!
     *     expectType<Schema>(change.fullDocument);
     *   });
     * ```
     *
     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     * @typeParam TLocal - Type of the data being detected by the change stream
     * @typeParam TChange - Type of the whole change stream document emitted
     */

  }, {
    key: "watch",
    value: function watch() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Allow optionally not specifying a pipeline
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }

      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
  }, {
    key: "mapReduce",
    value: function mapReduce(map, reduce, options, callback) {
      (0, utils_1.emitWarningOnce)('collection.mapReduce is deprecated. Use the aggregation pipeline instead. Visit https://docs.mongodb.com/manual/reference/map-reduce-to-aggregation-pipeline for more information on how to translate map-reduce operations to the aggregation pipeline.');
      if ('function' === typeof options) callback = options, options = {}; // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)
      // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8

      if ((options === null || options === void 0 ? void 0 : options.out) == null) {
        throw new error_1.MongoInvalidArgumentError('Option "out" must be defined, see mongodb docs for possible values');
      }

      if ('function' === typeof map) {
        map = map.toString();
      }

      if ('function' === typeof reduce) {
        reduce = reduce.toString();
      }

      if ('function' === typeof options.finalize) {
        options.finalize = options.finalize.toString();
      }

      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new map_reduce_1.MapReduceOperation(this, map, reduce, (0, utils_1.resolveOptions)(this, options)), callback);
    }
    /**
     * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
     *
     * @throws MongoNotConnectedError
     * @remarks
     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implemenation.
     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
     */

  }, {
    key: "initializeUnorderedBulkOp",
    value: function initializeUnorderedBulkOp(options) {
      return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    /**
     * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.
     *
     * @throws MongoNotConnectedError
     * @remarks
     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implemenation.
     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
     */

  }, {
    key: "initializeOrderedBulkOp",
    value: function initializeOrderedBulkOp(options) {
      return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    /** Get the db scoped logger */

  }, {
    key: "getLogger",
    value: function getLogger() {
      return this.s.db.s.logger;
    }
  }, {
    key: "logger",
    get: function get() {
      return this.s.db.s.logger;
    }
    /**
     * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
     * can be overridden by setting the **forceServerObjectId** flag.
     *
     * @deprecated Use insertOne, insertMany or bulkWrite instead.
     * @param docs - The documents to insert
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */

  }, {
    key: "insert",
    value: function insert(docs, options, callback) {
      (0, utils_1.emitWarningOnce)('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');
      if (typeof options === 'function') callback = options, options = {};
      options = options || {
        ordered: false
      };
      docs = !Array.isArray(docs) ? [docs] : docs;

      if (options.keepGoing === true) {
        options.ordered = false;
      }

      return this.insertMany(docs, options, callback);
    }
    /**
     * Updates documents.
     *
     * @deprecated use updateOne, updateMany or bulkWrite
     * @param filter - The filter for the update operation.
     * @param update - The update operations to be applied to the documents
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */

  }, {
    key: "update",
    value: function update(filter, _update, options, callback) {
      (0, utils_1.emitWarningOnce)('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return this.updateMany(filter, _update, options, callback);
    }
    /**
     * Remove documents.
     *
     * @deprecated use deleteOne, deleteMany or bulkWrite
     * @param filter - The filter for the remove operation.
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */

  }, {
    key: "remove",
    value: function remove(filter, options, callback) {
      (0, utils_1.emitWarningOnce)('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return this.deleteMany(filter, options, callback);
    }
  }, {
    key: "count",
    value: function count(filter, options, callback) {
      if (typeof filter === 'function') {
        callback = filter, filter = {}, options = {};
      } else {
        if (typeof options === 'function') callback = options, options = {};
      }

      filter !== null && filter !== void 0 ? filter : filter = {};
      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_1.CountOperation(utils_1.MongoDBNamespace.fromString(this.namespace), filter, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }]);

  return Collection;
}();

exports.Collection = Collection;

/***/ }),

/***/ 6964:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _templateObject;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

var _marked = /*#__PURE__*/_regeneratorRuntime().mark(entriesFromString);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FEATURE_FLAGS = exports.DEFAULT_OPTIONS = exports.OPTIONS = exports.parseOptions = exports.checkTLSOptions = exports.resolveSRVRecord = void 0;

var dns = __webpack_require__(9523);

var fs = __webpack_require__(7147);

var mongodb_connection_string_url_1 = __webpack_require__(5588);

var url_1 = __webpack_require__(7310);

var mongo_credentials_1 = __webpack_require__(8302);

var providers_1 = __webpack_require__(2581);

var compression_1 = __webpack_require__(2501);

var encrypter_1 = __webpack_require__(353);

var error_1 = __webpack_require__(9271);

var logger_1 = __webpack_require__(295);

var mongo_client_1 = __webpack_require__(9635);

var promise_provider_1 = __webpack_require__(8912);

var read_concern_1 = __webpack_require__(2027);

var read_preference_1 = __webpack_require__(3985);

var utils_1 = __webpack_require__(4356);

var write_concern_1 = __webpack_require__(1473);

var VALID_TXT_RECORDS = ['authSource', 'replicaSet', 'loadBalanced'];
var LB_SINGLE_HOST_ERROR = 'loadBalanced option only supported with a single host in the URI';
var LB_REPLICA_SET_ERROR = 'loadBalanced option not supported with a replicaSet option';
var LB_DIRECT_CONNECTION_ERROR = 'loadBalanced option not supported when directConnection is provided';
/**
 * Determines whether a provided address matches the provided parent domain in order
 * to avoid certain attack vectors.
 *
 * @param srvAddress - The address to check against a domain
 * @param parentDomain - The domain to check the provided address against
 * @returns Whether the provided address matches the parent domain
 */

function matchesParentDomain(srvAddress, parentDomain) {
  var regex = /^.*?\./;
  var srv = ".".concat(srvAddress.replace(regex, ''));
  var parent = ".".concat(parentDomain.replace(regex, ''));
  return srv.endsWith(parent);
}
/**
 * Lookup a `mongodb+srv` connection string, combine the parts and reparse it as a normal
 * connection string.
 *
 * @param uri - The connection string to parse
 * @param options - Optional user provided connection string options
 */


function resolveSRVRecord(options, callback) {
  if (typeof options.srvHost !== 'string') {
    return callback(new error_1.MongoAPIError('Option "srvHost" must not be empty'));
  }

  if (options.srvHost.split('.').length < 3) {
    // TODO(NODE-3484): Replace with MongoConnectionStringError
    return callback(new error_1.MongoAPIError('URI must include hostname, domain name, and tld'));
  } // Resolve the SRV record and use the result as the list of hosts to connect to.


  var lookupAddress = options.srvHost;
  dns.resolveSrv("_".concat(options.srvServiceName, "._tcp.").concat(lookupAddress), function (err, addresses) {
    if (err) return callback(err);

    if (addresses.length === 0) {
      return callback(new error_1.MongoAPIError('No addresses found at host'));
    }

    var _iterator = _createForOfIteratorHelper(addresses),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var name = _step.value.name;

        if (!matchesParentDomain(name, lookupAddress)) {
          return callback(new error_1.MongoAPIError('Server record does not share hostname with parent URI'));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var hostAddresses = addresses.map(function (r) {
      var _a;

      return utils_1.HostAddress.fromString("".concat(r.name, ":").concat((_a = r.port) !== null && _a !== void 0 ? _a : 27017));
    });
    var lbError = validateLoadBalancedOptions(hostAddresses, options, true);

    if (lbError) {
      return callback(lbError);
    } // Resolve TXT record and add options from there if they exist.


    dns.resolveTxt(lookupAddress, function (err, record) {
      var _a, _b, _c;

      if (err) {
        if (err.code !== 'ENODATA' && err.code !== 'ENOTFOUND') {
          return callback(err);
        }
      } else {
        if (record.length > 1) {
          return callback(new error_1.MongoParseError('Multiple text records not allowed'));
        }

        var txtRecordOptions = new url_1.URLSearchParams(record[0].join(''));

        var txtRecordOptionKeys = _toConsumableArray(txtRecordOptions.keys());

        if (txtRecordOptionKeys.some(function (key) {
          return !VALID_TXT_RECORDS.includes(key);
        })) {
          return callback(new error_1.MongoParseError("Text record may only set any of: ".concat(VALID_TXT_RECORDS.join(', '))));
        }

        if (VALID_TXT_RECORDS.some(function (option) {
          return txtRecordOptions.get(option) === '';
        })) {
          return callback(new error_1.MongoParseError('Cannot have empty URI params in DNS TXT Record'));
        }

        var source = (_a = txtRecordOptions.get('authSource')) !== null && _a !== void 0 ? _a : undefined;
        var replicaSet = (_b = txtRecordOptions.get('replicaSet')) !== null && _b !== void 0 ? _b : undefined;
        var loadBalanced = (_c = txtRecordOptions.get('loadBalanced')) !== null && _c !== void 0 ? _c : undefined;

        if (!options.userSpecifiedAuthSource && source && options.credentials && !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
          options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, {
            source: source
          });
        }

        if (!options.userSpecifiedReplicaSet && replicaSet) {
          options.replicaSet = replicaSet;
        }

        if (loadBalanced === 'true') {
          options.loadBalanced = true;
        }

        if (options.replicaSet && options.srvMaxHosts > 0) {
          return callback(new error_1.MongoParseError('Cannot combine replicaSet option with srvMaxHosts'));
        }

        var _lbError = validateLoadBalancedOptions(hostAddresses, options, true);

        if (_lbError) {
          return callback(_lbError);
        }
      }

      callback(undefined, hostAddresses);
    });
  });
}

exports.resolveSRVRecord = resolveSRVRecord;
/**
 * Checks if TLS options are valid
 *
 * @param options - The options used for options parsing
 * @throws MongoParseError if TLS options are invalid
 */

function checkTLSOptions(options) {
  if (!options) return;

  var check = function check(a, b) {
    if (Reflect.has(options, a) && Reflect.has(options, b)) {
      throw new error_1.MongoParseError("The '".concat(a, "' option cannot be used with '").concat(b, "'"));
    }
  };

  check('tlsInsecure', 'tlsAllowInvalidCertificates');
  check('tlsInsecure', 'tlsAllowInvalidHostnames');
  check('tlsInsecure', 'tlsDisableCertificateRevocationCheck');
  check('tlsInsecure', 'tlsDisableOCSPEndpointCheck');
  check('tlsAllowInvalidCertificates', 'tlsDisableCertificateRevocationCheck');
  check('tlsAllowInvalidCertificates', 'tlsDisableOCSPEndpointCheck');
  check('tlsDisableCertificateRevocationCheck', 'tlsDisableOCSPEndpointCheck');
}

exports.checkTLSOptions = checkTLSOptions;
var TRUTHS = new Set(['true', 't', '1', 'y', 'yes']);
var FALSEHOODS = new Set(['false', 'f', '0', 'n', 'no', '-1']);

function getBoolean(name, value) {
  if (typeof value === 'boolean') return value;
  var valueString = String(value).toLowerCase();

  if (TRUTHS.has(valueString)) {
    if (valueString !== 'true') {
      (0, utils_1.emitWarningOnce)("deprecated value for ".concat(name, " : ").concat(valueString, " - please update to ").concat(name, " : true instead"));
    }

    return true;
  }

  if (FALSEHOODS.has(valueString)) {
    if (valueString !== 'false') {
      (0, utils_1.emitWarningOnce)("deprecated value for ".concat(name, " : ").concat(valueString, " - please update to ").concat(name, " : false instead"));
    }

    return false;
  }

  throw new error_1.MongoParseError("Expected ".concat(name, " to be stringified boolean value, got: ").concat(value));
}

function getInt(name, value) {
  if (typeof value === 'number') return Math.trunc(value);
  var parsedValue = Number.parseInt(String(value), 10);
  if (!Number.isNaN(parsedValue)) return parsedValue;
  throw new error_1.MongoParseError("Expected ".concat(name, " to be stringified int value, got: ").concat(value));
}

function getUint(name, value) {
  var parsedValue = getInt(name, value);

  if (parsedValue < 0) {
    throw new error_1.MongoParseError("".concat(name, " can only be a positive int value, got: ").concat(value));
  }

  return parsedValue;
}

function entriesFromString(value) {
  var keyValuePairs, _iterator2, _step2, keyValue, _keyValue$split, _keyValue$split2, key, _value;

  return _regeneratorRuntime().wrap(function entriesFromString$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          keyValuePairs = value.split(',');
          _iterator2 = _createForOfIteratorHelper(keyValuePairs);
          _context.prev = 2;

          _iterator2.s();

        case 4:
          if ((_step2 = _iterator2.n()).done) {
            _context.next = 13;
            break;
          }

          keyValue = _step2.value;
          _keyValue$split = keyValue.split(':'), _keyValue$split2 = _slicedToArray(_keyValue$split, 2), key = _keyValue$split2[0], _value = _keyValue$split2[1];

          if (!(_value == null)) {
            _context.next = 9;
            break;
          }

          throw new error_1.MongoParseError('Cannot have undefined values in key value pairs');

        case 9:
          _context.next = 11;
          return [key, _value];

        case 11:
          _context.next = 4;
          break;

        case 13:
          _context.next = 18;
          break;

        case 15:
          _context.prev = 15;
          _context.t0 = _context["catch"](2);

          _iterator2.e(_context.t0);

        case 18:
          _context.prev = 18;

          _iterator2.f();

          return _context.finish(18);

        case 21:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[2, 15, 18, 21]]);
}

var CaseInsensitiveMap = /*#__PURE__*/function (_Map) {
  _inherits(CaseInsensitiveMap, _Map);

  var _super = _createSuper(CaseInsensitiveMap);

  function CaseInsensitiveMap() {
    var entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, CaseInsensitiveMap);

    return _super.call(this, entries.map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return [k.toLowerCase(), v];
    }));
  }

  _createClass(CaseInsensitiveMap, [{
    key: "has",
    value: function has(k) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "has", this).call(this, k.toLowerCase());
    }
  }, {
    key: "get",
    value: function get(k) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "get", this).call(this, k.toLowerCase());
    }
  }, {
    key: "set",
    value: function set(k, v) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "set", this).call(this, k.toLowerCase(), v);
    }
  }, {
    key: "delete",
    value: function _delete(k) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "delete", this).call(this, k.toLowerCase());
    }
  }]);

  return CaseInsensitiveMap;
}( /*#__PURE__*/_wrapNativeSuper(Map));

function parseOptions(uri) {
  var mongoClient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
    options = mongoClient;
    mongoClient = undefined;
  }

  var url = new mongodb_connection_string_url_1["default"](uri);
  var hosts = url.hosts,
      isSRV = url.isSRV;
  var mongoOptions = Object.create(null); // Feature flags

  var _iterator3 = _createForOfIteratorHelper(Object.getOwnPropertySymbols(options)),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var flag = _step3.value;

      if (exports.FEATURE_FLAGS.has(flag)) {
        mongoOptions[flag] = options[flag];
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
  var urlOptions = new CaseInsensitiveMap();

  if (url.pathname !== '/' && url.pathname !== '') {
    var dbName = decodeURIComponent(url.pathname[0] === '/' ? url.pathname.slice(1) : url.pathname);

    if (dbName) {
      urlOptions.set('dbName', [dbName]);
    }
  }

  if (url.username !== '') {
    var auth = {
      username: decodeURIComponent(url.username)
    };

    if (typeof url.password === 'string') {
      auth.password = decodeURIComponent(url.password);
    }

    urlOptions.set('auth', [auth]);
  }

  var _iterator4 = _createForOfIteratorHelper(url.searchParams.keys()),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _key = _step4.value;

      var _values = _toConsumableArray(url.searchParams.getAll(_key));

      if (_values.includes('')) {
        throw new error_1.MongoAPIError('URI cannot contain options with no value');
      }

      if (!urlOptions.has(_key)) {
        urlOptions.set(_key, _values);
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  var objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        v = _ref4[1];

    return v != null;
  })); // Validate options that can only be provided by one of uri or object

  if (urlOptions.has('serverApi')) {
    throw new error_1.MongoParseError('URI cannot contain `serverApi`, it can only be passed to the client');
  }

  if (objectOptions.has('loadBalanced')) {
    throw new error_1.MongoParseError('loadBalanced is only a valid option in the URI');
  } // All option collection


  var allOptions = new CaseInsensitiveMap();
  var allKeys = new Set([].concat(_toConsumableArray(urlOptions.keys()), _toConsumableArray(objectOptions.keys()), _toConsumableArray(exports.DEFAULT_OPTIONS.keys())));

  var _iterator5 = _createForOfIteratorHelper(allKeys),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _key2 = _step5.value;
      var _values2 = [];
      var objectOptionValue = objectOptions.get(_key2);

      if (objectOptionValue != null) {
        _values2.push(objectOptionValue);
      }

      var urlValue = urlOptions.get(_key2);

      if (urlValue != null) {
        _values2.push.apply(_values2, _toConsumableArray(urlValue));
      }

      var defaultOptionsValue = exports.DEFAULT_OPTIONS.get(_key2);

      if (defaultOptionsValue != null) {
        _values2.push(defaultOptionsValue);
      }

      allOptions.set(_key2, _values2);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  if (allOptions.has('tlsCertificateKeyFile') && !allOptions.has('tlsCertificateFile')) {
    allOptions.set('tlsCertificateFile', allOptions.get('tlsCertificateKeyFile'));
  }

  if (allOptions.has('tls') || allOptions.has('ssl')) {
    var tlsAndSslOpts = (allOptions.get('tls') || []).concat(allOptions.get('ssl') || []).map(getBoolean.bind(null, 'tls/ssl'));

    if (new Set(tlsAndSslOpts).size !== 1) {
      throw new error_1.MongoParseError('All values of tls/ssl must be the same.');
    }
  }

  var unsupportedOptions = (0, utils_1.setDifference)(allKeys, Array.from(Object.keys(exports.OPTIONS)).map(function (s) {
    return s.toLowerCase();
  }));

  if (unsupportedOptions.size !== 0) {
    var optionWord = unsupportedOptions.size > 1 ? 'options' : 'option';
    var isOrAre = unsupportedOptions.size > 1 ? 'are' : 'is';
    throw new error_1.MongoParseError("".concat(optionWord, " ").concat(Array.from(unsupportedOptions).join(', '), " ").concat(isOrAre, " not supported"));
  } // Option parsing and setting


  for (var _i2 = 0, _Object$entries = Object.entries(exports.OPTIONS); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        descriptor = _Object$entries$_i[1];

    var values = allOptions.get(key);
    if (!values || values.length === 0) continue;
    setOption(mongoOptions, key, descriptor, values);
  }

  if (mongoOptions.credentials) {
    var isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
    var isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
    var isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;

    if ((isGssapi || isX509) && allOptions.has('authSource') && mongoOptions.credentials.source !== '$external') {
      // If authSource was explicitly given and its incorrect, we error
      throw new error_1.MongoParseError("".concat(mongoOptions.credentials, " can only have authSource set to '$external'"));
    }

    if (!(isGssapi || isX509 || isAws) && mongoOptions.dbName && !allOptions.has('authSource')) {
      // inherit the dbName unless GSSAPI or X509, then silently ignore dbName
      // and there was no specific authSource given
      mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
        source: mongoOptions.dbName
      });
    }

    mongoOptions.credentials.validate(); // Check if the only auth related option provided was authSource, if so we can remove credentials

    if (mongoOptions.credentials.password === '' && mongoOptions.credentials.username === '' && mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
      delete mongoOptions.credentials;
    }
  }

  if (!mongoOptions.dbName) {
    // dbName default is applied here because of the credential validation above
    mongoOptions.dbName = 'test';
  }

  checkTLSOptions(mongoOptions);
  if (options.promiseLibrary) promise_provider_1.PromiseProvider.set(options.promiseLibrary);
  var lbError = validateLoadBalancedOptions(hosts, mongoOptions, isSRV);

  if (lbError) {
    throw lbError;
  }

  if (mongoClient && mongoOptions.autoEncryption) {
    encrypter_1.Encrypter.checkForMongoCrypt();
    mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options);
    mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
  } // Potential SRV Overrides and SRV connection string validations


  mongoOptions.userSpecifiedAuthSource = objectOptions.has('authSource') || urlOptions.has('authSource');
  mongoOptions.userSpecifiedReplicaSet = objectOptions.has('replicaSet') || urlOptions.has('replicaSet');

  if (isSRV) {
    // SRV Record is resolved upon connecting
    mongoOptions.srvHost = hosts[0];

    if (mongoOptions.directConnection) {
      throw new error_1.MongoAPIError('SRV URI does not support directConnection');
    }

    if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === 'string') {
      throw new error_1.MongoParseError('Cannot use srvMaxHosts option with replicaSet');
    } // SRV turns on TLS by default, but users can override and turn it off


    var noUserSpecifiedTLS = !objectOptions.has('tls') && !urlOptions.has('tls');
    var noUserSpecifiedSSL = !objectOptions.has('ssl') && !urlOptions.has('ssl');

    if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
      mongoOptions.tls = true;
    }
  } else {
    var userSpecifiedSrvOptions = urlOptions.has('srvMaxHosts') || objectOptions.has('srvMaxHosts') || urlOptions.has('srvServiceName') || objectOptions.has('srvServiceName');

    if (userSpecifiedSrvOptions) {
      throw new error_1.MongoParseError('Cannot use srvMaxHosts or srvServiceName with a non-srv connection string');
    }
  }

  if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
    throw new error_1.MongoParseError('directConnection option requires exactly one host');
  }

  if (!mongoOptions.proxyHost && (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
    throw new error_1.MongoParseError('Must specify proxyHost if other proxy options are passed');
  }

  if (mongoOptions.proxyUsername && !mongoOptions.proxyPassword || !mongoOptions.proxyUsername && mongoOptions.proxyPassword) {
    throw new error_1.MongoParseError('Can only specify both of proxy username/password or neither');
  }

  var proxyOptions = ['proxyHost', 'proxyPort', 'proxyUsername', 'proxyPassword'].map(function (key) {
    var _a;

    return (_a = urlOptions.get(key)) !== null && _a !== void 0 ? _a : [];
  });

  if (proxyOptions.some(function (options) {
    return options.length > 1;
  })) {
    throw new error_1.MongoParseError('Proxy options cannot be specified multiple times in the connection string');
  }

  return mongoOptions;
}

exports.parseOptions = parseOptions;

function validateLoadBalancedOptions(hosts, mongoOptions, isSrv) {
  if (mongoOptions.loadBalanced) {
    if (hosts.length > 1) {
      return new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
    }

    if (mongoOptions.replicaSet) {
      return new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
    }

    if (mongoOptions.directConnection) {
      return new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
    }

    if (isSrv && mongoOptions.srvMaxHosts > 0) {
      return new error_1.MongoParseError('Cannot limit srv hosts with loadBalanced enabled');
    }
  }

  return;
}

function setOption(mongoOptions, key, descriptor, values) {
  var target = descriptor.target,
      type = descriptor.type,
      transform = descriptor.transform,
      deprecated = descriptor.deprecated;
  var name = target !== null && target !== void 0 ? target : key;

  if (deprecated) {
    var deprecatedMsg = typeof deprecated === 'string' ? ": ".concat(deprecated) : '';
    (0, utils_1.emitWarning)("".concat(key, " is a deprecated option").concat(deprecatedMsg));
  }

  switch (type) {
    case 'boolean':
      mongoOptions[name] = getBoolean(name, values[0]);
      break;

    case 'int':
      mongoOptions[name] = getInt(name, values[0]);
      break;

    case 'uint':
      mongoOptions[name] = getUint(name, values[0]);
      break;

    case 'string':
      if (values[0] == null) {
        break;
      }

      mongoOptions[name] = String(values[0]);
      break;

    case 'record':
      if (!(0, utils_1.isRecord)(values[0])) {
        throw new error_1.MongoParseError("".concat(name, " must be an object"));
      }

      mongoOptions[name] = values[0];
      break;

    case 'any':
      mongoOptions[name] = values[0];
      break;

    default:
      {
        if (!transform) {
          throw new error_1.MongoParseError('Descriptors missing a type must define a transform');
        }

        var transformValue = transform({
          name: name,
          options: mongoOptions,
          values: values
        });
        mongoOptions[name] = transformValue;
        break;
      }
  }
}

exports.OPTIONS = {
  appName: {
    target: 'metadata',
    transform: function transform(_ref5) {
      var options = _ref5.options,
          _ref5$values = _slicedToArray(_ref5.values, 1),
          value = _ref5$values[0];

      return (0, utils_1.makeClientMetadata)(_objectSpread(_objectSpread({}, options.driverInfo), {}, {
        appName: String(value)
      }));
    }
  },
  auth: {
    target: 'credentials',
    transform: function transform(_ref6) {
      var name = _ref6.name,
          options = _ref6.options,
          _ref6$values = _slicedToArray(_ref6.values, 1),
          value = _ref6$values[0];

      if (!(0, utils_1.isRecord)(value, ['username', 'password'])) {
        throw new error_1.MongoParseError("".concat(name, " must be an object with 'username' and 'password' properties"));
      }

      return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
        username: value.username,
        password: value.password
      });
    }
  },
  authMechanism: {
    target: 'credentials',
    transform: function transform(_ref7) {
      var options = _ref7.options,
          _ref7$values = _slicedToArray(_ref7.values, 1),
          value = _ref7$values[0];

      var _a, _b;

      var mechanisms = Object.values(providers_1.AuthMechanism);

      var _mechanisms$filter = mechanisms.filter(function (m) {
        return m.match(RegExp(String.raw(_templateObject || (_templateObject = _taggedTemplateLiteral(["\b", "\b"], ["\\b", "\\b"])), value), 'i'));
      }),
          _mechanisms$filter2 = _slicedToArray(_mechanisms$filter, 1),
          mechanism = _mechanisms$filter2[0];

      if (!mechanism) {
        throw new error_1.MongoParseError("authMechanism one of ".concat(mechanisms, ", got ").concat(value));
      }

      var source = (_a = options.credentials) === null || _a === void 0 ? void 0 : _a.source;

      if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
        // some mechanisms have '$external' as the Auth Source
        source = '$external';
      }

      var password = (_b = options.credentials) === null || _b === void 0 ? void 0 : _b.password;

      if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === '') {
        password = undefined;
      }

      return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
        mechanism: mechanism,
        source: source,
        password: password
      });
    }
  },
  authMechanismProperties: {
    target: 'credentials',
    transform: function transform(_ref8) {
      var options = _ref8.options,
          _ref8$values = _slicedToArray(_ref8.values, 1),
          optionValue = _ref8$values[0];

      if (typeof optionValue === 'string') {
        var mechanismProperties = Object.create(null);

        var _iterator6 = _createForOfIteratorHelper(entriesFromString(optionValue)),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _step6$value = _slicedToArray(_step6.value, 2),
                key = _step6$value[0],
                value = _step6$value[1];

            try {
              mechanismProperties[key] = getBoolean(key, value);
            } catch (_unused) {
              mechanismProperties[key] = value;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          mechanismProperties: mechanismProperties
        });
      }

      if (!(0, utils_1.isRecord)(optionValue)) {
        throw new error_1.MongoParseError('AuthMechanismProperties must be an object');
      }

      return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
        mechanismProperties: optionValue
      });
    }
  },
  authSource: {
    target: 'credentials',
    transform: function transform(_ref9) {
      var options = _ref9.options,
          _ref9$values = _slicedToArray(_ref9.values, 1),
          value = _ref9$values[0];

      var source = String(value);
      return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
        source: source
      });
    }
  },
  autoEncryption: {
    type: 'record'
  },
  bsonRegExp: {
    type: 'boolean'
  },
  serverApi: {
    target: 'serverApi',
    transform: function transform(_ref10) {
      var _ref10$values = _slicedToArray(_ref10.values, 1),
          version = _ref10$values[0];

      var serverApiToValidate = typeof version === 'string' ? {
        version: version
      } : version;
      var versionToValidate = serverApiToValidate && serverApiToValidate.version;

      if (!versionToValidate) {
        throw new error_1.MongoParseError("Invalid `serverApi` property; must specify a version from the following enum: [\"".concat(Object.values(mongo_client_1.ServerApiVersion).join('", "'), "\"]"));
      }

      if (!Object.values(mongo_client_1.ServerApiVersion).some(function (v) {
        return v === versionToValidate;
      })) {
        throw new error_1.MongoParseError("Invalid server API version=".concat(versionToValidate, "; must be in the following enum: [\"").concat(Object.values(mongo_client_1.ServerApiVersion).join('", "'), "\"]"));
      }

      return serverApiToValidate;
    }
  },
  checkKeys: {
    type: 'boolean'
  },
  compressors: {
    "default": 'none',
    target: 'compressors',
    transform: function transform(_ref11) {
      var values = _ref11.values;
      var compressionList = new Set();

      var _iterator7 = _createForOfIteratorHelper(values),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var compVal = _step7.value;
          var compValArray = typeof compVal === 'string' ? compVal.split(',') : compVal;

          if (!Array.isArray(compValArray)) {
            throw new error_1.MongoInvalidArgumentError('compressors must be an array or a comma-delimited list of strings');
          }

          var _iterator8 = _createForOfIteratorHelper(compValArray),
              _step8;

          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var c = _step8.value;

              if (Object.keys(compression_1.Compressor).includes(String(c))) {
                compressionList.add(String(c));
              } else {
                throw new error_1.MongoInvalidArgumentError("".concat(c, " is not a valid compression mechanism. Must be one of: ").concat(Object.keys(compression_1.Compressor), "."));
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      return _toConsumableArray(compressionList);
    }
  },
  connectTimeoutMS: {
    "default": 30000,
    type: 'uint'
  },
  dbName: {
    type: 'string'
  },
  directConnection: {
    "default": false,
    type: 'boolean'
  },
  driverInfo: {
    target: 'metadata',
    "default": (0, utils_1.makeClientMetadata)(),
    transform: function transform(_ref12) {
      var options = _ref12.options,
          _ref12$values = _slicedToArray(_ref12.values, 1),
          value = _ref12$values[0];

      var _a, _b;

      if (!(0, utils_1.isRecord)(value)) throw new error_1.MongoParseError('DriverInfo must be an object');
      return (0, utils_1.makeClientMetadata)({
        driverInfo: value,
        appName: (_b = (_a = options.metadata) === null || _a === void 0 ? void 0 : _a.application) === null || _b === void 0 ? void 0 : _b.name
      });
    }
  },
  enableUtf8Validation: {
    type: 'boolean',
    "default": true
  },
  family: {
    transform: function transform(_ref13) {
      var name = _ref13.name,
          _ref13$values = _slicedToArray(_ref13.values, 1),
          value = _ref13$values[0];

      var transformValue = getInt(name, value);

      if (transformValue === 4 || transformValue === 6) {
        return transformValue;
      }

      throw new error_1.MongoParseError("Option 'family' must be 4 or 6 got ".concat(transformValue, "."));
    }
  },
  fieldsAsRaw: {
    type: 'record'
  },
  forceServerObjectId: {
    "default": false,
    type: 'boolean'
  },
  fsync: {
    deprecated: 'Please use journal instead',
    target: 'writeConcern',
    transform: function transform(_ref14) {
      var name = _ref14.name,
          options = _ref14.options,
          _ref14$values = _slicedToArray(_ref14.values, 1),
          value = _ref14$values[0];

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          fsync: getBoolean(name, value)
        })
      });
      if (!wc) throw new error_1.MongoParseError("Unable to make a writeConcern from fsync=".concat(value));
      return wc;
    }
  },
  heartbeatFrequencyMS: {
    "default": 10000,
    type: 'uint'
  },
  ignoreUndefined: {
    type: 'boolean'
  },
  j: {
    deprecated: 'Please use journal instead',
    target: 'writeConcern',
    transform: function transform(_ref15) {
      var name = _ref15.name,
          options = _ref15.options,
          _ref15$values = _slicedToArray(_ref15.values, 1),
          value = _ref15$values[0];

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          journal: getBoolean(name, value)
        })
      });
      if (!wc) throw new error_1.MongoParseError("Unable to make a writeConcern from journal=".concat(value));
      return wc;
    }
  },
  journal: {
    target: 'writeConcern',
    transform: function transform(_ref16) {
      var name = _ref16.name,
          options = _ref16.options,
          _ref16$values = _slicedToArray(_ref16.values, 1),
          value = _ref16$values[0];

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          journal: getBoolean(name, value)
        })
      });
      if (!wc) throw new error_1.MongoParseError("Unable to make a writeConcern from journal=".concat(value));
      return wc;
    }
  },
  keepAlive: {
    "default": true,
    type: 'boolean'
  },
  keepAliveInitialDelay: {
    "default": 120000,
    type: 'uint'
  },
  loadBalanced: {
    "default": false,
    type: 'boolean'
  },
  localThresholdMS: {
    "default": 15,
    type: 'uint'
  },
  logger: {
    "default": new logger_1.Logger('MongoClient'),
    transform: function transform(_ref17) {
      var _ref17$values = _slicedToArray(_ref17.values, 1),
          value = _ref17$values[0];

      if (value instanceof logger_1.Logger) {
        return value;
      }

      (0, utils_1.emitWarning)('Alternative loggers might not be supported'); // TODO: make Logger an interface that others can implement, make usage consistent in driver
      // DRIVERS-1204

      return;
    }
  },
  loggerLevel: {
    target: 'logger',
    transform: function transform(_ref18) {
      var _ref18$values = _slicedToArray(_ref18.values, 1),
          value = _ref18$values[0];

      return new logger_1.Logger('MongoClient', {
        loggerLevel: value
      });
    }
  },
  maxConnecting: {
    "default": 2,
    transform: function transform(_ref19) {
      var name = _ref19.name,
          _ref19$values = _slicedToArray(_ref19.values, 1),
          value = _ref19$values[0];

      var maxConnecting = getUint(name, value);

      if (maxConnecting === 0) {
        throw new error_1.MongoInvalidArgumentError('maxConnecting must be > 0 if specified');
      }

      return maxConnecting;
    }
  },
  maxIdleTimeMS: {
    "default": 0,
    type: 'uint'
  },
  maxPoolSize: {
    "default": 100,
    type: 'uint'
  },
  maxStalenessSeconds: {
    target: 'readPreference',
    transform: function transform(_ref20) {
      var name = _ref20.name,
          options = _ref20.options,
          _ref20$values = _slicedToArray(_ref20.values, 1),
          value = _ref20$values[0];

      var maxStalenessSeconds = getUint(name, value);

      if (options.readPreference) {
        return read_preference_1.ReadPreference.fromOptions({
          readPreference: _objectSpread(_objectSpread({}, options.readPreference), {}, {
            maxStalenessSeconds: maxStalenessSeconds
          })
        });
      } else {
        return new read_preference_1.ReadPreference('secondary', undefined, {
          maxStalenessSeconds: maxStalenessSeconds
        });
      }
    }
  },
  minInternalBufferSize: {
    type: 'uint'
  },
  minPoolSize: {
    "default": 0,
    type: 'uint'
  },
  minHeartbeatFrequencyMS: {
    "default": 500,
    type: 'uint'
  },
  monitorCommands: {
    "default": false,
    type: 'boolean'
  },
  name: {
    target: 'driverInfo',
    transform: function transform(_ref21) {
      var _ref21$values = _slicedToArray(_ref21.values, 1),
          value = _ref21$values[0],
          options = _ref21.options;

      return _objectSpread(_objectSpread({}, options.driverInfo), {}, {
        name: String(value)
      });
    }
  },
  noDelay: {
    "default": true,
    type: 'boolean'
  },
  pkFactory: {
    "default": utils_1.DEFAULT_PK_FACTORY,
    transform: function transform(_ref22) {
      var _ref22$values = _slicedToArray(_ref22.values, 1),
          value = _ref22$values[0];

      if ((0, utils_1.isRecord)(value, ['createPk']) && typeof value.createPk === 'function') {
        return value;
      }

      throw new error_1.MongoParseError("Option pkFactory must be an object with a createPk function, got ".concat(value));
    }
  },
  promiseLibrary: {
    deprecated: true,
    type: 'any'
  },
  promoteBuffers: {
    type: 'boolean'
  },
  promoteLongs: {
    type: 'boolean'
  },
  promoteValues: {
    type: 'boolean'
  },
  proxyHost: {
    type: 'string'
  },
  proxyPassword: {
    type: 'string'
  },
  proxyPort: {
    type: 'uint'
  },
  proxyUsername: {
    type: 'string'
  },
  raw: {
    "default": false,
    type: 'boolean'
  },
  readConcern: {
    transform: function transform(_ref23) {
      var _ref23$values = _slicedToArray(_ref23.values, 1),
          value = _ref23$values[0],
          options = _ref23.options;

      if (value instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value, ['level'])) {
        return read_concern_1.ReadConcern.fromOptions(_objectSpread(_objectSpread({}, options.readConcern), value));
      }

      throw new error_1.MongoParseError("ReadConcern must be an object, got ".concat(JSON.stringify(value)));
    }
  },
  readConcernLevel: {
    target: 'readConcern',
    transform: function transform(_ref24) {
      var _ref24$values = _slicedToArray(_ref24.values, 1),
          level = _ref24$values[0],
          options = _ref24.options;

      return read_concern_1.ReadConcern.fromOptions(_objectSpread(_objectSpread({}, options.readConcern), {}, {
        level: level
      }));
    }
  },
  readPreference: {
    "default": read_preference_1.ReadPreference.primary,
    transform: function transform(_ref25) {
      var _ref25$values = _slicedToArray(_ref25.values, 1),
          value = _ref25$values[0],
          options = _ref25.options;

      var _a, _b, _c;

      if (value instanceof read_preference_1.ReadPreference) {
        return read_preference_1.ReadPreference.fromOptions(_objectSpread({
          readPreference: _objectSpread(_objectSpread({}, options.readPreference), value)
        }, value));
      }

      if ((0, utils_1.isRecord)(value, ['mode'])) {
        var rp = read_preference_1.ReadPreference.fromOptions(_objectSpread({
          readPreference: _objectSpread(_objectSpread({}, options.readPreference), value)
        }, value));
        if (rp) return rp;else throw new error_1.MongoParseError("Cannot make read preference from ".concat(JSON.stringify(value)));
      }

      if (typeof value === 'string') {
        var rpOpts = {
          hedge: (_a = options.readPreference) === null || _a === void 0 ? void 0 : _a.hedge,
          maxStalenessSeconds: (_b = options.readPreference) === null || _b === void 0 ? void 0 : _b.maxStalenessSeconds
        };
        return new read_preference_1.ReadPreference(value, (_c = options.readPreference) === null || _c === void 0 ? void 0 : _c.tags, rpOpts);
      }

      throw new error_1.MongoParseError("Unknown ReadPreference value: ".concat(value));
    }
  },
  readPreferenceTags: {
    target: 'readPreference',
    transform: function transform(_ref26) {
      var values = _ref26.values,
          options = _ref26.options;
      var tags = Array.isArray(values[0]) ? values[0] : values;
      var readPreferenceTags = [];

      var _iterator9 = _createForOfIteratorHelper(tags),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var tag = _step9.value;
          var readPreferenceTag = Object.create(null);

          if (typeof tag === 'string') {
            var _iterator10 = _createForOfIteratorHelper(entriesFromString(tag)),
                _step10;

            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var _step10$value = _slicedToArray(_step10.value, 2),
                    k = _step10$value[0],
                    v = _step10$value[1];

                readPreferenceTag[k] = v;
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
          }

          if ((0, utils_1.isRecord)(tag)) {
            for (var _i3 = 0, _Object$entries2 = Object.entries(tag); _i3 < _Object$entries2.length; _i3++) {
              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),
                  _k = _Object$entries2$_i[0],
                  _v = _Object$entries2$_i[1];

              readPreferenceTag[_k] = _v;
            }
          }

          readPreferenceTags.push(readPreferenceTag);
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      return read_preference_1.ReadPreference.fromOptions({
        readPreference: options.readPreference,
        readPreferenceTags: readPreferenceTags
      });
    }
  },
  replicaSet: {
    type: 'string'
  },
  retryReads: {
    "default": true,
    type: 'boolean'
  },
  retryWrites: {
    "default": true,
    type: 'boolean'
  },
  serializeFunctions: {
    type: 'boolean'
  },
  serverSelectionTimeoutMS: {
    "default": 30000,
    type: 'uint'
  },
  servername: {
    type: 'string'
  },
  socketTimeoutMS: {
    "default": 0,
    type: 'uint'
  },
  srvMaxHosts: {
    type: 'uint',
    "default": 0
  },
  srvServiceName: {
    type: 'string',
    "default": 'mongodb'
  },
  ssl: {
    target: 'tls',
    type: 'boolean'
  },
  sslCA: {
    target: 'ca',
    transform: function transform(_ref27) {
      var _ref27$values = _slicedToArray(_ref27.values, 1),
          value = _ref27$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  sslCRL: {
    target: 'crl',
    transform: function transform(_ref28) {
      var _ref28$values = _slicedToArray(_ref28.values, 1),
          value = _ref28$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  sslCert: {
    target: 'cert',
    transform: function transform(_ref29) {
      var _ref29$values = _slicedToArray(_ref29.values, 1),
          value = _ref29$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  sslKey: {
    target: 'key',
    transform: function transform(_ref30) {
      var _ref30$values = _slicedToArray(_ref30.values, 1),
          value = _ref30$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  sslPass: {
    deprecated: true,
    target: 'passphrase',
    type: 'string'
  },
  sslValidate: {
    target: 'rejectUnauthorized',
    type: 'boolean'
  },
  tls: {
    type: 'boolean'
  },
  tlsAllowInvalidCertificates: {
    target: 'rejectUnauthorized',
    transform: function transform(_ref31) {
      var name = _ref31.name,
          _ref31$values = _slicedToArray(_ref31.values, 1),
          value = _ref31$values[0];

      // allowInvalidCertificates is the inverse of rejectUnauthorized
      return !getBoolean(name, value);
    }
  },
  tlsAllowInvalidHostnames: {
    target: 'checkServerIdentity',
    transform: function transform(_ref32) {
      var name = _ref32.name,
          _ref32$values = _slicedToArray(_ref32.values, 1),
          value = _ref32$values[0];

      // tlsAllowInvalidHostnames means setting the checkServerIdentity function to a noop
      return getBoolean(name, value) ? function () {
        return undefined;
      } : undefined;
    }
  },
  tlsCAFile: {
    target: 'ca',
    transform: function transform(_ref33) {
      var _ref33$values = _slicedToArray(_ref33.values, 1),
          value = _ref33$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  tlsCertificateFile: {
    target: 'cert',
    transform: function transform(_ref34) {
      var _ref34$values = _slicedToArray(_ref34.values, 1),
          value = _ref34$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  tlsCertificateKeyFile: {
    target: 'key',
    transform: function transform(_ref35) {
      var _ref35$values = _slicedToArray(_ref35.values, 1),
          value = _ref35$values[0];

      return fs.readFileSync(String(value), {
        encoding: 'ascii'
      });
    }
  },
  tlsCertificateKeyFilePassword: {
    target: 'passphrase',
    type: 'any'
  },
  tlsInsecure: {
    transform: function transform(_ref36) {
      var name = _ref36.name,
          options = _ref36.options,
          _ref36$values = _slicedToArray(_ref36.values, 1),
          value = _ref36$values[0];

      var tlsInsecure = getBoolean(name, value);

      if (tlsInsecure) {
        options.checkServerIdentity = function () {
          return undefined;
        };

        options.rejectUnauthorized = false;
      } else {
        options.checkServerIdentity = options.tlsAllowInvalidHostnames ? function () {
          return undefined;
        } : undefined;
        options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
      }

      return tlsInsecure;
    }
  },
  w: {
    target: 'writeConcern',
    transform: function transform(_ref37) {
      var _ref37$values = _slicedToArray(_ref37.values, 1),
          value = _ref37$values[0],
          options = _ref37.options;

      return write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          w: value
        })
      });
    }
  },
  waitQueueTimeoutMS: {
    "default": 0,
    type: 'uint'
  },
  writeConcern: {
    target: 'writeConcern',
    transform: function transform(_ref38) {
      var _ref38$values = _slicedToArray(_ref38.values, 1),
          value = _ref38$values[0],
          options = _ref38.options;

      if ((0, utils_1.isRecord)(value) || value instanceof write_concern_1.WriteConcern) {
        return write_concern_1.WriteConcern.fromOptions({
          writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), value)
        });
      } else if (value === 'majority' || typeof value === 'number') {
        return write_concern_1.WriteConcern.fromOptions({
          writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
            w: value
          })
        });
      }

      throw new error_1.MongoParseError("Invalid WriteConcern cannot parse: ".concat(JSON.stringify(value)));
    }
  },
  wtimeout: {
    deprecated: 'Please use wtimeoutMS instead',
    target: 'writeConcern',
    transform: function transform(_ref39) {
      var _ref39$values = _slicedToArray(_ref39.values, 1),
          value = _ref39$values[0],
          options = _ref39.options;

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          wtimeout: getUint('wtimeout', value)
        })
      });
      if (wc) return wc;
      throw new error_1.MongoParseError("Cannot make WriteConcern from wtimeout");
    }
  },
  wtimeoutMS: {
    target: 'writeConcern',
    transform: function transform(_ref40) {
      var _ref40$values = _slicedToArray(_ref40.values, 1),
          value = _ref40$values[0],
          options = _ref40.options;

      var wc = write_concern_1.WriteConcern.fromOptions({
        writeConcern: _objectSpread(_objectSpread({}, options.writeConcern), {}, {
          wtimeoutMS: getUint('wtimeoutMS', value)
        })
      });
      if (wc) return wc;
      throw new error_1.MongoParseError("Cannot make WriteConcern from wtimeout");
    }
  },
  zlibCompressionLevel: {
    "default": 0,
    type: 'int'
  },
  // Custom types for modifying core behavior
  connectionType: {
    type: 'any'
  },
  srvPoller: {
    type: 'any'
  },
  // Accepted NodeJS Options
  minDHSize: {
    type: 'any'
  },
  pskCallback: {
    type: 'any'
  },
  secureContext: {
    type: 'any'
  },
  enableTrace: {
    type: 'any'
  },
  requestCert: {
    type: 'any'
  },
  rejectUnauthorized: {
    type: 'any'
  },
  checkServerIdentity: {
    type: 'any'
  },
  ALPNProtocols: {
    type: 'any'
  },
  SNICallback: {
    type: 'any'
  },
  session: {
    type: 'any'
  },
  requestOCSP: {
    type: 'any'
  },
  localAddress: {
    type: 'any'
  },
  localPort: {
    type: 'any'
  },
  hints: {
    type: 'any'
  },
  lookup: {
    type: 'any'
  },
  ca: {
    type: 'any'
  },
  cert: {
    type: 'any'
  },
  ciphers: {
    type: 'any'
  },
  crl: {
    type: 'any'
  },
  ecdhCurve: {
    type: 'any'
  },
  key: {
    type: 'any'
  },
  passphrase: {
    type: 'any'
  },
  pfx: {
    type: 'any'
  },
  secureProtocol: {
    type: 'any'
  },
  index: {
    type: 'any'
  },
  // Legacy Options, these are unused but left here to avoid errors with CSFLE lib
  useNewUrlParser: {
    type: 'boolean'
  },
  useUnifiedTopology: {
    type: 'boolean'
  }
};
exports.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports.OPTIONS).filter(function (_ref41) {
  var _ref42 = _slicedToArray(_ref41, 2),
      descriptor = _ref42[1];

  return descriptor["default"] != null;
}).map(function (_ref43) {
  var _ref44 = _slicedToArray(_ref43, 2),
      k = _ref44[0],
      d = _ref44[1];

  return [k, d["default"]];
}));
/**
 * Set of permitted feature flags
 * @internal
 */

exports.FEATURE_FLAGS = new Set([Symbol["for"]('@@mdb.skipPingOnConnect')]);

/***/ }),

/***/ 1254:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.APM_EVENTS = exports.TOPOLOGY_EVENTS = exports.CMAP_EVENTS = exports.HEARTBEAT_EVENTS = exports.RESUME_TOKEN_CHANGED = exports.END = exports.CHANGE = exports.INIT = exports.MORE = exports.RESPONSE = exports.SERVER_HEARTBEAT_FAILED = exports.SERVER_HEARTBEAT_SUCCEEDED = exports.SERVER_HEARTBEAT_STARTED = exports.COMMAND_FAILED = exports.COMMAND_SUCCEEDED = exports.COMMAND_STARTED = exports.CLUSTER_TIME_RECEIVED = exports.CONNECTION_CHECKED_IN = exports.CONNECTION_CHECKED_OUT = exports.CONNECTION_CHECK_OUT_FAILED = exports.CONNECTION_CHECK_OUT_STARTED = exports.CONNECTION_CLOSED = exports.CONNECTION_READY = exports.CONNECTION_CREATED = exports.CONNECTION_POOL_CLEARED = exports.CONNECTION_POOL_CLOSED = exports.CONNECTION_POOL_CREATED = exports.TOPOLOGY_DESCRIPTION_CHANGED = exports.TOPOLOGY_CLOSED = exports.TOPOLOGY_OPENING = exports.SERVER_DESCRIPTION_CHANGED = exports.SERVER_CLOSED = exports.SERVER_OPENING = exports.DESCRIPTION_RECEIVED = exports.UNPINNED = exports.PINNED = exports.MESSAGE = exports.ENDED = exports.CLOSED = exports.CONNECT = exports.OPEN = exports.CLOSE = exports.TIMEOUT = exports.ERROR = exports.SYSTEM_JS_COLLECTION = exports.SYSTEM_COMMAND_COLLECTION = exports.SYSTEM_USER_COLLECTION = exports.SYSTEM_PROFILE_COLLECTION = exports.SYSTEM_INDEX_COLLECTION = exports.SYSTEM_NAMESPACE_COLLECTION = void 0;
exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports.LEGACY_HELLO_COMMAND = exports.MONGO_CLIENT_EVENTS = exports.LOCAL_SERVER_EVENTS = exports.SERVER_RELAY_EVENTS = void 0;
exports.SYSTEM_NAMESPACE_COLLECTION = 'system.namespaces';
exports.SYSTEM_INDEX_COLLECTION = 'system.indexes';
exports.SYSTEM_PROFILE_COLLECTION = 'system.profile';
exports.SYSTEM_USER_COLLECTION = 'system.users';
exports.SYSTEM_COMMAND_COLLECTION = '$cmd';
exports.SYSTEM_JS_COLLECTION = 'system.js'; // events

exports.ERROR = 'error';
exports.TIMEOUT = 'timeout';
exports.CLOSE = 'close';
exports.OPEN = 'open';
exports.CONNECT = 'connect';
exports.CLOSED = 'closed';
exports.ENDED = 'ended';
exports.MESSAGE = 'message';
exports.PINNED = 'pinned';
exports.UNPINNED = 'unpinned';
exports.DESCRIPTION_RECEIVED = 'descriptionReceived';
exports.SERVER_OPENING = 'serverOpening';
exports.SERVER_CLOSED = 'serverClosed';
exports.SERVER_DESCRIPTION_CHANGED = 'serverDescriptionChanged';
exports.TOPOLOGY_OPENING = 'topologyOpening';
exports.TOPOLOGY_CLOSED = 'topologyClosed';
exports.TOPOLOGY_DESCRIPTION_CHANGED = 'topologyDescriptionChanged';
exports.CONNECTION_POOL_CREATED = 'connectionPoolCreated';
exports.CONNECTION_POOL_CLOSED = 'connectionPoolClosed';
exports.CONNECTION_POOL_CLEARED = 'connectionPoolCleared';
exports.CONNECTION_CREATED = 'connectionCreated';
exports.CONNECTION_READY = 'connectionReady';
exports.CONNECTION_CLOSED = 'connectionClosed';
exports.CONNECTION_CHECK_OUT_STARTED = 'connectionCheckOutStarted';
exports.CONNECTION_CHECK_OUT_FAILED = 'connectionCheckOutFailed';
exports.CONNECTION_CHECKED_OUT = 'connectionCheckedOut';
exports.CONNECTION_CHECKED_IN = 'connectionCheckedIn';
exports.CLUSTER_TIME_RECEIVED = 'clusterTimeReceived';
exports.COMMAND_STARTED = 'commandStarted';
exports.COMMAND_SUCCEEDED = 'commandSucceeded';
exports.COMMAND_FAILED = 'commandFailed';
exports.SERVER_HEARTBEAT_STARTED = 'serverHeartbeatStarted';
exports.SERVER_HEARTBEAT_SUCCEEDED = 'serverHeartbeatSucceeded';
exports.SERVER_HEARTBEAT_FAILED = 'serverHeartbeatFailed';
exports.RESPONSE = 'response';
exports.MORE = 'more';
exports.INIT = 'init';
exports.CHANGE = 'change';
exports.END = 'end';
exports.RESUME_TOKEN_CHANGED = 'resumeTokenChanged';
/** @public */

exports.HEARTBEAT_EVENTS = Object.freeze([exports.SERVER_HEARTBEAT_STARTED, exports.SERVER_HEARTBEAT_SUCCEEDED, exports.SERVER_HEARTBEAT_FAILED]);
/** @public */

exports.CMAP_EVENTS = Object.freeze([exports.CONNECTION_POOL_CREATED, exports.CONNECTION_POOL_CLOSED, exports.CONNECTION_CREATED, exports.CONNECTION_READY, exports.CONNECTION_CLOSED, exports.CONNECTION_CHECK_OUT_STARTED, exports.CONNECTION_CHECK_OUT_FAILED, exports.CONNECTION_CHECKED_OUT, exports.CONNECTION_CHECKED_IN, exports.CONNECTION_POOL_CLEARED]);
/** @public */

exports.TOPOLOGY_EVENTS = Object.freeze([exports.SERVER_OPENING, exports.SERVER_CLOSED, exports.SERVER_DESCRIPTION_CHANGED, exports.TOPOLOGY_OPENING, exports.TOPOLOGY_CLOSED, exports.TOPOLOGY_DESCRIPTION_CHANGED, exports.ERROR, exports.TIMEOUT, exports.CLOSE]);
/** @public */

exports.APM_EVENTS = Object.freeze([exports.COMMAND_STARTED, exports.COMMAND_SUCCEEDED, exports.COMMAND_FAILED]);
/**
 * All events that we relay to the `Topology`
 * @internal
 */

exports.SERVER_RELAY_EVENTS = Object.freeze([exports.SERVER_HEARTBEAT_STARTED, exports.SERVER_HEARTBEAT_SUCCEEDED, exports.SERVER_HEARTBEAT_FAILED, exports.COMMAND_STARTED, exports.COMMAND_SUCCEEDED, exports.COMMAND_FAILED].concat(_toConsumableArray(exports.CMAP_EVENTS)));
/**
 * All events we listen to from `Server` instances, but do not forward to the client
 * @internal
 */

exports.LOCAL_SERVER_EVENTS = Object.freeze([exports.CONNECT, exports.DESCRIPTION_RECEIVED, exports.CLOSED, exports.ENDED]);
/** @public */

exports.MONGO_CLIENT_EVENTS = Object.freeze([].concat(_toConsumableArray(exports.CMAP_EVENTS), _toConsumableArray(exports.APM_EVENTS), _toConsumableArray(exports.TOPOLOGY_EVENTS), _toConsumableArray(exports.HEARTBEAT_EVENTS)));
/**
 * @internal
 * The legacy hello command that was deprecated in MongoDB 5.0.
 */

exports.LEGACY_HELLO_COMMAND = 'ismaster';
/**
 * @internal
 * The legacy hello command that was deprecated in MongoDB 5.0.
 */

exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = 'isMaster';

/***/ }),

/***/ 3822:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertUninitialized = exports.next = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;

var stream_1 = __webpack_require__(2781);

var bson_1 = __webpack_require__(53);

var error_1 = __webpack_require__(9271);

var mongo_types_1 = __webpack_require__(3738);

var execute_operation_1 = __webpack_require__(7887);

var get_more_1 = __webpack_require__(944);

var kill_cursors_1 = __webpack_require__(262);

var read_concern_1 = __webpack_require__(2027);

var read_preference_1 = __webpack_require__(3985);

var sessions_1 = __webpack_require__(4408);

var utils_1 = __webpack_require__(4356);
/** @internal */


var kId = Symbol('id');
/** @internal */

var kDocuments = Symbol('documents');
/** @internal */

var kServer = Symbol('server');
/** @internal */

var kNamespace = Symbol('namespace');
/** @internal */

var kClient = Symbol('client');
/** @internal */

var kSession = Symbol('session');
/** @internal */

var kOptions = Symbol('options');
/** @internal */

var kTransform = Symbol('transform');
/** @internal */

var kInitialized = Symbol('initialized');
/** @internal */

var kClosed = Symbol('closed');
/** @internal */

var kKilled = Symbol('killed');
/** @internal */

var kInit = Symbol('kInit');
/** @public */

exports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];
/** @public */

var AbstractCursor = /*#__PURE__*/function (_mongo_types_1$TypedE, _Symbol$asyncIterator) {
  _inherits(AbstractCursor, _mongo_types_1$TypedE);

  var _super = _createSuper(AbstractCursor);

  /** @internal */
  function AbstractCursor(client, namespace) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, AbstractCursor);

    _this = _super.call(this);

    if (!client.s.isMongoClient) {
      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');
    }

    _this[kClient] = client;
    _this[kNamespace] = namespace;
    _this[kDocuments] = [];
    _this[kInitialized] = false;
    _this[kClosed] = false;
    _this[kKilled] = false;
    _this[kOptions] = _objectSpread({
      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary
    }, (0, bson_1.pluckBSONSerializeOptions)(options));
    var readConcern = read_concern_1.ReadConcern.fromOptions(options);

    if (readConcern) {
      _this[kOptions].readConcern = readConcern;
    }

    if (typeof options.batchSize === 'number') {
      _this[kOptions].batchSize = options.batchSize;
    } // we check for undefined specifically here to allow falsy values
    // eslint-disable-next-line no-restricted-syntax


    if (options.comment !== undefined) {
      _this[kOptions].comment = options.comment;
    }

    if (typeof options.maxTimeMS === 'number') {
      _this[kOptions].maxTimeMS = options.maxTimeMS;
    }

    if (typeof options.maxAwaitTimeMS === 'number') {
      _this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;
    }

    if (options.session instanceof sessions_1.ClientSession) {
      _this[kSession] = options.session;
    } else {
      _this[kSession] = _this[kClient].startSession({
        owner: _assertThisInitialized(_this),
        explicit: false
      });
    }

    return _this;
  }

  _createClass(AbstractCursor, [{
    key: "id",
    get: function get() {
      return this[kId];
    }
    /** @internal */

  }, {
    key: "client",
    get: function get() {
      return this[kClient];
    }
    /** @internal */

  }, {
    key: "server",
    get: function get() {
      return this[kServer];
    }
  }, {
    key: "namespace",
    get: function get() {
      return this[kNamespace];
    }
  }, {
    key: "readPreference",
    get: function get() {
      return this[kOptions].readPreference;
    }
  }, {
    key: "readConcern",
    get: function get() {
      return this[kOptions].readConcern;
    }
    /** @internal */

  }, {
    key: "session",
    get: function get() {
      return this[kSession];
    },
    set: function set(clientSession) {
      this[kSession] = clientSession;
    }
    /** @internal */

  }, {
    key: "cursorOptions",
    get: function get() {
      return this[kOptions];
    }
  }, {
    key: "closed",
    get: function get() {
      return this[kClosed];
    }
  }, {
    key: "killed",
    get: function get() {
      return this[kKilled];
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      var _a;

      return !!((_a = this[kClient].topology) === null || _a === void 0 ? void 0 : _a.loadBalanced);
    }
    /** Returns current buffered documents length */

  }, {
    key: "bufferedCount",
    value: function bufferedCount() {
      return this[kDocuments].length;
    }
    /** Returns current buffered documents */

  }, {
    key: "readBufferedDocuments",
    value: function readBufferedDocuments(number) {
      return this[kDocuments].splice(0, number !== null && number !== void 0 ? number : this[kDocuments].length);
    }
  }, {
    key: _Symbol$asyncIterator,
    value: function value() {
      var _this2 = this;

      return {
        next: function next() {
          return _this2.next().then(function (value) {
            return value != null ? {
              value: value,
              done: false
            } : {
              value: undefined,
              done: true
            };
          });
        }
      };
    }
  }, {
    key: "stream",
    value: function stream(options) {
      if (options === null || options === void 0 ? void 0 : options.transform) {
        var _transform = options.transform;
        var readable = new ReadableCursorStream(this);
        return readable.pipe(new stream_1.Transform({
          objectMode: true,
          highWaterMark: 1,
          transform: function transform(chunk, _, callback) {
            try {
              var transformed = _transform(chunk);

              callback(undefined, transformed);
            } catch (err) {
              callback(err);
            }
          }
        }));
      }

      return new ReadableCursorStream(this);
    }
  }, {
    key: "hasNext",
    value: function hasNext(callback) {
      var _this3 = this;

      return (0, utils_1.maybePromise)(callback, function (done) {
        if (_this3[kId] === bson_1.Long.ZERO) {
          return done(undefined, false);
        }

        if (_this3[kDocuments].length) {
          return done(undefined, true);
        }

        _next(_this3, true, function (err, doc) {
          if (err) return done(err);

          if (doc) {
            _this3[kDocuments].unshift(doc);

            done(undefined, true);
            return;
          }

          done(undefined, false);
        });
      });
    }
  }, {
    key: "next",
    value: function next(callback) {
      var _this4 = this;

      return (0, utils_1.maybePromise)(callback, function (done) {
        if (_this4[kId] === bson_1.Long.ZERO) {
          return done(new error_1.MongoCursorExhaustedError());
        }

        _next(_this4, true, done);
      });
    }
  }, {
    key: "tryNext",
    value: function tryNext(callback) {
      var _this5 = this;

      return (0, utils_1.maybePromise)(callback, function (done) {
        if (_this5[kId] === bson_1.Long.ZERO) {
          return done(new error_1.MongoCursorExhaustedError());
        }

        _next(_this5, false, done);
      });
    }
  }, {
    key: "forEach",
    value: function forEach(iterator, callback) {
      var _this6 = this;

      if (typeof iterator !== 'function') {
        throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
      }

      return (0, utils_1.maybePromise)(callback, function (done) {
        var transform = _this6[kTransform];

        var fetchDocs = function fetchDocs() {
          _next(_this6, true, function (err, doc) {
            if (err || doc == null) return done(err);
            var result; // NOTE: no need to transform because `next` will do this automatically

            try {
              result = iterator(doc); // TODO(NODE-3283): Improve transform typing
            } catch (error) {
              return done(error);
            }

            if (result === false) return done(); // these do need to be transformed since they are copying the rest of the batch

            var internalDocs = _this6[kDocuments].splice(0, _this6[kDocuments].length);

            for (var i = 0; i < internalDocs.length; ++i) {
              try {
                result = iterator(transform ? transform(internalDocs[i]) : internalDocs[i] // TODO(NODE-3283): Improve transform typing
                );
              } catch (error) {
                return done(error);
              }

              if (result === false) return done();
            }

            fetchDocs();
          });
        };

        fetchDocs();
      });
    }
  }, {
    key: "close",
    value: function close(options, callback) {
      var _this7 = this;

      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      var needsToEmitClosed = !this[kClosed];
      this[kClosed] = true;
      return (0, utils_1.maybePromise)(callback, function (done) {
        return cleanupCursor(_this7, {
          needsToEmitClosed: needsToEmitClosed
        }, done);
      });
    }
  }, {
    key: "toArray",
    value: function toArray(callback) {
      var _this8 = this;

      return (0, utils_1.maybePromise)(callback, function (done) {
        var docs = [];
        var transform = _this8[kTransform];

        var fetchDocs = function fetchDocs() {
          // NOTE: if we add a `nextBatch` then we should use it here
          _next(_this8, true, function (err, doc) {
            if (err) return done(err);
            if (doc == null) return done(undefined, docs); // NOTE: no need to transform because `next` will do this automatically

            docs.push(doc); // these do need to be transformed since they are copying the rest of the batch

            var internalDocs = transform ? _this8[kDocuments].splice(0, _this8[kDocuments].length).map(transform) : _this8[kDocuments].splice(0, _this8[kDocuments].length); // TODO(NODE-3283): Improve transform typing

            if (internalDocs) {
              docs.push.apply(docs, _toConsumableArray(internalDocs));
            }

            fetchDocs();
          });
        };

        fetchDocs();
      });
    }
    /**
     * Add a cursor flag to the cursor
     *
     * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.
     * @param value - The flag boolean value.
     */

  }, {
    key: "addCursorFlag",
    value: function addCursorFlag(flag, value) {
      assertUninitialized(this);

      if (!exports.CURSOR_FLAGS.includes(flag)) {
        throw new error_1.MongoInvalidArgumentError("Flag ".concat(flag, " is not one of ").concat(exports.CURSOR_FLAGS));
      }

      if (typeof value !== 'boolean') {
        throw new error_1.MongoInvalidArgumentError("Flag ".concat(flag, " must be a boolean value"));
      }

      this[kOptions][flag] = value;
      return this;
    }
    /**
     * Map all documents using the provided function
     * If there is a transform set on the cursor, that will be called first and the result passed to
     * this function's transform.
     *
     * @remarks
     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
     * it **does not** return a new instance of a cursor. This means when calling map,
     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
     * Take note of the following example:
     *
     * @example
     * ```typescript
     * const cursor: FindCursor<Document> = coll.find();
     * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);
     * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]
     * ```
     * @param transform - The mapping transformation method.
     */

  }, {
    key: "map",
    value: function map(transform) {
      assertUninitialized(this);
      var oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing

      if (oldTransform) {
        this[kTransform] = function (doc) {
          return transform(oldTransform(doc));
        };
      } else {
        this[kTransform] = transform;
      }

      return this;
    }
    /**
     * Set the ReadPreference for the cursor.
     *
     * @param readPreference - The new read preference for the cursor.
     */

  }, {
    key: "withReadPreference",
    value: function withReadPreference(readPreference) {
      assertUninitialized(this);

      if (readPreference instanceof read_preference_1.ReadPreference) {
        this[kOptions].readPreference = readPreference;
      } else if (typeof readPreference === 'string') {
        this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);
      } else {
        throw new error_1.MongoInvalidArgumentError("Invalid read preference: ".concat(readPreference));
      }

      return this;
    }
    /**
     * Set the ReadPreference for the cursor.
     *
     * @param readPreference - The new read preference for the cursor.
     */

  }, {
    key: "withReadConcern",
    value: function withReadConcern(readConcern) {
      assertUninitialized(this);
      var resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({
        readConcern: readConcern
      });

      if (resolvedReadConcern) {
        this[kOptions].readConcern = resolvedReadConcern;
      }

      return this;
    }
    /**
     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
     *
     * @param value - Number of milliseconds to wait before aborting the query.
     */

  }, {
    key: "maxTimeMS",
    value: function maxTimeMS(value) {
      assertUninitialized(this);

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');
      }

      this[kOptions].maxTimeMS = value;
      return this;
    }
    /**
     * Set the batch size for the cursor.
     *
     * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.
     */

  }, {
    key: "batchSize",
    value: function batchSize(value) {
      assertUninitialized(this);

      if (this[kOptions].tailable) {
        throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');
      }

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
      }

      this[kOptions].batchSize = value;
      return this;
    }
    /**
     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
     * if the resultant data has already been retrieved by this cursor.
     */

  }, {
    key: "rewind",
    value: function rewind() {
      if (!this[kInitialized]) {
        return;
      }

      this[kId] = undefined;
      this[kDocuments] = [];
      this[kClosed] = false;
      this[kKilled] = false;
      this[kInitialized] = false;
      var session = this[kSession];

      if (session) {
        // We only want to end this session if we created it, and it hasn't ended yet
        if (session.explicit === false) {
          if (!session.hasEnded) {
            session.endSession()["catch"](function () {
              return null;
            });
          }

          this[kSession] = this.client.startSession({
            owner: this,
            explicit: false
          });
        }
      }
    }
    /** @internal */

  }, {
    key: "_getMore",
    value: function _getMore(batchSize, callback) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], _objectSpread(_objectSpread({}, this[kOptions]), {}, {
        session: this[kSession],
        batchSize: batchSize
      }));
      (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);
    }
    /**
     * @internal
     *
     * This function is exposed for the unified test runner's createChangeStream
     * operation.  We cannot refactor to use the abstract _initialize method without
     * a significant refactor.
     */

  }, {
    key: kInit,
    value: function value(callback) {
      var _this9 = this;

      this._initialize(this[kSession], function (err, state) {
        if (state) {
          var response = state.response;
          _this9[kServer] = state.server;

          if (response.cursor) {
            // TODO(NODE-2674): Preserve int64 sent from MongoDB
            _this9[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;

            if (response.cursor.ns) {
              _this9[kNamespace] = (0, utils_1.ns)(response.cursor.ns);
            }

            _this9[kDocuments] = response.cursor.firstBatch;
          } // When server responses return without a cursor document, we close this cursor
          // and return the raw server response. This is often the case for explain commands
          // for example


          if (_this9[kId] == null) {
            _this9[kId] = bson_1.Long.ZERO; // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter

            _this9[kDocuments] = [state.response];
          }
        } // the cursor is now initialized, even if an error occurred or it is dead


        _this9[kInitialized] = true;

        if (err || cursorIsDead(_this9)) {
          return cleanupCursor(_this9, {
            error: err
          }, function () {
            return callback(err, nextDocument(_this9));
          });
        }

        callback();
      });
    }
  }]);

  return AbstractCursor;
}(mongo_types_1.TypedEventEmitter, Symbol.asyncIterator);

exports.AbstractCursor = AbstractCursor;
/** @event */

AbstractCursor.CLOSE = 'close';

function nextDocument(cursor) {
  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {
    return null;
  }

  var doc = cursor[kDocuments].shift();

  if (doc) {
    var transform = cursor[kTransform];

    if (transform) {
      return transform(doc);
    }

    return doc;
  }

  return null;
}
/**
 * @param cursor - the cursor on which to call `next`
 * @param blocking - a boolean indicating whether or not the cursor should `block` until data
 *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,
 *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and
 *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does
 *     not indicate the end of the cursor.
 * @param callback - callback to return the result to the caller
 * @returns
 */


function _next(cursor, blocking, callback) {
  var cursorId = cursor[kId];

  if (cursor.closed) {
    return callback(undefined, null);
  }

  if (cursor[kDocuments] && cursor[kDocuments].length) {
    callback(undefined, nextDocument(cursor));
    return;
  }

  if (cursorId == null) {
    // All cursors must operate within a session, one must be made implicitly if not explicitly provided
    cursor[kInit](function (err, value) {
      if (err) return callback(err);

      if (value) {
        return callback(undefined, value);
      }

      return _next(cursor, blocking, callback);
    });
    return;
  }

  if (cursorIsDead(cursor)) {
    return cleanupCursor(cursor, undefined, function () {
      return callback(undefined, null);
    });
  } // otherwise need to call getMore


  var batchSize = cursor[kOptions].batchSize || 1000;

  cursor._getMore(batchSize, function (err, response) {
    if (response) {
      var _cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;

      cursor[kDocuments] = response.cursor.nextBatch;
      cursor[kId] = _cursorId;
    }

    if (err || cursorIsDead(cursor)) {
      return cleanupCursor(cursor, {
        error: err
      }, function () {
        return callback(err, nextDocument(cursor));
      });
    }

    if (cursor[kDocuments].length === 0 && blocking === false) {
      return callback(undefined, null);
    }

    _next(cursor, blocking, callback);
  });
}

exports.next = _next;

function cursorIsDead(cursor) {
  var cursorId = cursor[kId];
  return !!cursorId && cursorId.isZero();
}

function cleanupCursor(cursor, options, callback) {
  var _a;

  var cursorId = cursor[kId];
  var cursorNs = cursor[kNamespace];
  var server = cursor[kServer];
  var session = cursor[kSession];
  var error = options === null || options === void 0 ? void 0 : options.error;
  var needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;

  if (error) {
    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {
      return completeCleanup();
    }
  }

  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {
    if (needsToEmitClosed) {
      cursor[kClosed] = true;
      cursor[kId] = bson_1.Long.ZERO;
      cursor.emit(AbstractCursor.CLOSE);
    }

    if (session) {
      if (session.owner === cursor) {
        return session.endSession({
          error: error
        }, callback);
      }

      if (!session.inTransaction()) {
        (0, sessions_1.maybeClearPinnedConnection)(session, {
          error: error
        });
      }
    }

    return callback();
  }

  function completeCleanup() {
    if (session) {
      if (session.owner === cursor) {
        return session.endSession({
          error: error
        }, function () {
          cursor.emit(AbstractCursor.CLOSE);
          callback();
        });
      }

      if (!session.inTransaction()) {
        (0, sessions_1.maybeClearPinnedConnection)(session, {
          error: error
        });
      }
    }

    cursor.emit(AbstractCursor.CLOSE);
    return callback();
  }

  cursor[kKilled] = true;
  return (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, {
    session: session
  }), completeCleanup);
}
/** @internal */


function assertUninitialized(cursor) {
  if (cursor[kInitialized]) {
    throw new error_1.MongoCursorInUseError();
  }
}

exports.assertUninitialized = assertUninitialized;

var ReadableCursorStream = /*#__PURE__*/function (_stream_1$Readable) {
  _inherits(ReadableCursorStream, _stream_1$Readable);

  var _super2 = _createSuper(ReadableCursorStream);

  function ReadableCursorStream(cursor) {
    var _this10;

    _classCallCheck(this, ReadableCursorStream);

    _this10 = _super2.call(this, {
      objectMode: true,
      autoDestroy: false,
      highWaterMark: 1
    });
    _this10._readInProgress = false;
    _this10._cursor = cursor;
    return _this10;
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _createClass(ReadableCursorStream, [{
    key: "_read",
    value: function _read(size) {
      if (!this._readInProgress) {
        this._readInProgress = true;

        this._readNext();
      }
    }
  }, {
    key: "_destroy",
    value: function _destroy(error, callback) {
      this._cursor.close(function (err) {
        return process.nextTick(callback, err || error);
      });
    }
  }, {
    key: "_readNext",
    value: function _readNext() {
      var _this11 = this;

      _next(this._cursor, true, function (err, result) {
        if (err) {
          // NOTE: This is questionable, but we have a test backing the behavior. It seems the
          //       desired behavior is that a stream ends cleanly when a user explicitly closes
          //       a client during iteration. Alternatively, we could do the "right" thing and
          //       propagate the error message by removing this special case.
          if (err.message.match(/server is closed/)) {
            _this11._cursor.close()["catch"](function () {
              return null;
            });

            return _this11.push(null);
          } // NOTE: This is also perhaps questionable. The rationale here is that these errors tend
          //       to be "operation interrupted", where a cursor has been closed but there is an
          //       active getMore in-flight. This used to check if the cursor was killed but once
          //       that changed to happen in cleanup legitimate errors would not destroy the
          //       stream. There are change streams test specifically test these cases.


          if (err.message.match(/interrupted/)) {
            return _this11.push(null);
          }

          return _this11.destroy(err);
        }

        if (result == null) {
          _this11.push(null);
        } else if (_this11.destroyed) {
          _this11._cursor.close()["catch"](function () {
            return null;
          });
        } else {
          if (_this11.push(result)) {
            return _this11._readNext();
          }

          _this11._readInProgress = false;
        }
      });
    }
  }]);

  return ReadableCursorStream;
}(stream_1.Readable);

/***/ }),

/***/ 5983:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AggregationCursor = void 0;

var aggregate_1 = __webpack_require__(17);

var execute_operation_1 = __webpack_require__(7887);

var utils_1 = __webpack_require__(4356);

var abstract_cursor_1 = __webpack_require__(3822);
/** @internal */


var kPipeline = Symbol('pipeline');
/** @internal */

var kOptions = Symbol('options');
/**
 * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
 * allowing for iteration over the results returned from the underlying query. It supports
 * one by one document iteration, conversion to an array or can be iterated as a Node 4.X
 * or higher stream
 * @public
 */

var AggregationCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(AggregationCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(AggregationCursor);

  /** @internal */
  function AggregationCursor(client, namespace) {
    var _this;

    var pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, AggregationCursor);

    _this = _super.call(this, client, namespace, options);
    _this[kPipeline] = pipeline;
    _this[kOptions] = options;
    return _this;
  }

  _createClass(AggregationCursor, [{
    key: "pipeline",
    get: function get() {
      return this[kPipeline];
    }
  }, {
    key: "clone",
    value: function clone() {
      var clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);
      delete clonedOptions.session;
      return new AggregationCursor(this.client, this.namespace, this[kPipeline], _objectSpread({}, clonedOptions));
    }
  }, {
    key: "map",
    value: function map(transform) {
      return _get(_getPrototypeOf(AggregationCursor.prototype), "map", this).call(this, transform);
    }
    /** @internal */

  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], _objectSpread(_objectSpread(_objectSpread({}, this[kOptions]), this.cursorOptions), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, function (err, response) {
        if (err || response == null) return callback(err); // TODO: NODE-2882

        callback(undefined, {
          server: aggregateOperation.server,
          session: session,
          response: response
        });
      });
    }
  }, {
    key: "explain",
    value: function explain(verbosity, callback) {
      if (typeof verbosity === 'function') callback = verbosity, verbosity = true;
      if (verbosity == null) verbosity = true;
      return (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], _objectSpread(_objectSpread(_objectSpread({}, this[kOptions]), this.cursorOptions), {}, {
        explain: verbosity
      })), callback);
    }
  }, {
    key: "group",
    value: function group($group) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $group: $group
      });
      return this;
    }
    /** Add a limit stage to the aggregation pipeline */

  }, {
    key: "limit",
    value: function limit($limit) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $limit: $limit
      });
      return this;
    }
    /** Add a match stage to the aggregation pipeline */

  }, {
    key: "match",
    value: function match($match) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $match: $match
      });
      return this;
    }
    /** Add an out stage to the aggregation pipeline */

  }, {
    key: "out",
    value: function out($out) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $out: $out
      });
      return this;
    }
    /**
     * Add a project stage to the aggregation pipeline
     *
     * @remarks
     * In order to strictly type this function you must provide an interface
     * that represents the effect of your projection on the result documents.
     *
     * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.
     * You should specify a parameterized type to have assertions on your final results.
     *
     * @example
     * ```typescript
     * // Best way
     * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
     * // Flexible way
     * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });
     * ```
     *
     * @remarks
     * In order to strictly type this function you must provide an interface
     * that represents the effect of your projection on the result documents.
     *
     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
     * it **does not** return a new instance of a cursor. This means when calling project,
     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
     * Take note of the following example:
     *
     * @example
     * ```typescript
     * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);
     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
     *
     * // or always use chaining and save the final cursor
     *
     * const cursor = coll.aggregate().project<{ a: string }>({
     *   _id: 0,
     *   a: { $convert: { input: '$a', to: 'string' }
     * }});
     * ```
     */

  }, {
    key: "project",
    value: function project($project) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $project: $project
      });
      return this;
    }
    /** Add a lookup stage to the aggregation pipeline */

  }, {
    key: "lookup",
    value: function lookup($lookup) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $lookup: $lookup
      });
      return this;
    }
    /** Add a redact stage to the aggregation pipeline */

  }, {
    key: "redact",
    value: function redact($redact) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $redact: $redact
      });
      return this;
    }
    /** Add a skip stage to the aggregation pipeline */

  }, {
    key: "skip",
    value: function skip($skip) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $skip: $skip
      });
      return this;
    }
    /** Add a sort stage to the aggregation pipeline */

  }, {
    key: "sort",
    value: function sort($sort) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $sort: $sort
      });
      return this;
    }
    /** Add a unwind stage to the aggregation pipeline */

  }, {
    key: "unwind",
    value: function unwind($unwind) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $unwind: $unwind
      });
      return this;
    } // deprecated methods

    /** @deprecated Add a geoNear stage to the aggregation pipeline */

  }, {
    key: "geoNear",
    value: function geoNear($geoNear) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({
        $geoNear: $geoNear
      });
      return this;
    }
  }]);

  return AggregationCursor;
}(abstract_cursor_1.AbstractCursor);

exports.AggregationCursor = AggregationCursor;

/***/ }),

/***/ 1564:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ChangeStreamCursor = void 0;

var change_stream_1 = __webpack_require__(4672);

var constants_1 = __webpack_require__(1254);

var aggregate_1 = __webpack_require__(17);

var execute_operation_1 = __webpack_require__(7887);

var utils_1 = __webpack_require__(4356);

var abstract_cursor_1 = __webpack_require__(3822);
/** @internal */


var ChangeStreamCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(ChangeStreamCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(ChangeStreamCursor);

  function ChangeStreamCursor(client, namespace) {
    var _this;

    var pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, ChangeStreamCursor);

    _this = _super.call(this, client, namespace, options);
    _this.pipeline = pipeline;
    _this.options = options;
    _this._resumeToken = null;
    _this.startAtOperationTime = options.startAtOperationTime;

    if (options.startAfter) {
      _this.resumeToken = options.startAfter;
    } else if (options.resumeAfter) {
      _this.resumeToken = options.resumeAfter;
    }

    return _this;
  }

  _createClass(ChangeStreamCursor, [{
    key: "resumeToken",
    get: function get() {
      return this._resumeToken;
    },
    set: function set(token) {
      this._resumeToken = token;
      this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
    }
  }, {
    key: "resumeOptions",
    get: function get() {
      var options = _objectSpread({}, this.options);

      for (var _i = 0, _arr = ['resumeAfter', 'startAfter', 'startAtOperationTime']; _i < _arr.length; _i++) {
        var key = _arr[_i];
        delete options[key];
      }

      if (this.resumeToken != null) {
        if (this.options.startAfter && !this.hasReceived) {
          options.startAfter = this.resumeToken;
        } else {
          options.resumeAfter = this.resumeToken;
        }
      } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
        options.startAtOperationTime = this.startAtOperationTime;
      }

      return options;
    }
  }, {
    key: "cacheResumeToken",
    value: function cacheResumeToken(resumeToken) {
      if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
        this.resumeToken = this.postBatchResumeToken;
      } else {
        this.resumeToken = resumeToken;
      }

      this.hasReceived = true;
    }
  }, {
    key: "_processBatch",
    value: function _processBatch(response) {
      var cursor = response.cursor;

      if (cursor.postBatchResumeToken) {
        this.postBatchResumeToken = response.cursor.postBatchResumeToken;
        var batch = 'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;

        if (batch.length === 0) {
          this.resumeToken = cursor.postBatchResumeToken;
        }
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, _objectSpread({}, this.cursorOptions));
    }
  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var _this2 = this;

      var aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, _objectSpread(_objectSpread(_objectSpread({}, this.cursorOptions), this.options), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, function (err, response) {
        if (err || response == null) {
          return callback(err);
        }

        var server = aggregateOperation.server;
        _this2.maxWireVersion = (0, utils_1.maxWireVersion)(server);

        if (_this2.startAtOperationTime == null && _this2.resumeAfter == null && _this2.startAfter == null && _this2.maxWireVersion >= 7) {
          _this2.startAtOperationTime = response.operationTime;
        }

        _this2._processBatch(response);

        _this2.emit(constants_1.INIT, response);

        _this2.emit(constants_1.RESPONSE); // TODO: NODE-2882


        callback(undefined, {
          server: server,
          session: session,
          response: response
        });
      });
    }
  }, {
    key: "_getMore",
    value: function _getMore(batchSize, callback) {
      var _this3 = this;

      _get(_getPrototypeOf(ChangeStreamCursor.prototype), "_getMore", this).call(this, batchSize, function (err, response) {
        if (err) {
          return callback(err);
        }

        _this3.maxWireVersion = (0, utils_1.maxWireVersion)(_this3.server);

        _this3._processBatch(response);

        _this3.emit(change_stream_1.ChangeStream.MORE, response);

        _this3.emit(change_stream_1.ChangeStream.RESPONSE);

        callback(err, response);
      });
    }
  }]);

  return ChangeStreamCursor;
}(abstract_cursor_1.AbstractCursor);

exports.ChangeStreamCursor = ChangeStreamCursor;

/***/ }),

/***/ 1284:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FindCursor = exports.FLAGS = void 0;

var error_1 = __webpack_require__(9271);

var count_1 = __webpack_require__(2307);

var execute_operation_1 = __webpack_require__(7887);

var find_1 = __webpack_require__(8012);

var sort_1 = __webpack_require__(7462);

var utils_1 = __webpack_require__(4356);

var abstract_cursor_1 = __webpack_require__(3822);
/** @internal */


var kFilter = Symbol('filter');
/** @internal */

var kNumReturned = Symbol('numReturned');
/** @internal */

var kBuiltOptions = Symbol('builtOptions');
/** @public Flags allowed for cursor */

exports.FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];
/** @public */

var FindCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(FindCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(FindCursor);

  /** @internal */
  function FindCursor(client, namespace, filter) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, FindCursor);

    _this = _super.call(this, client, namespace, options);
    _this[kFilter] = filter || {};
    _this[kBuiltOptions] = options;

    if (options.sort != null) {
      _this[kBuiltOptions].sort = (0, sort_1.formatSort)(options.sort);
    }

    return _this;
  }

  _createClass(FindCursor, [{
    key: "clone",
    value: function clone() {
      var clonedOptions = (0, utils_1.mergeOptions)({}, this[kBuiltOptions]);
      delete clonedOptions.session;
      return new FindCursor(this.client, this.namespace, this[kFilter], _objectSpread({}, clonedOptions));
    }
  }, {
    key: "map",
    value: function map(transform) {
      return _get(_getPrototypeOf(FindCursor.prototype), "map", this).call(this, transform);
    }
    /** @internal */

  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var _this2 = this;

      var findOperation = new find_1.FindOperation(undefined, this.namespace, this[kFilter], _objectSpread(_objectSpread(_objectSpread({}, this[kBuiltOptions]), this.cursorOptions), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(this.client, findOperation, function (err, response) {
        if (err || response == null) return callback(err); // TODO: We only need this for legacy queries that do not support `limit`, maybe
        //       the value should only be saved in those cases.

        if (response.cursor) {
          _this2[kNumReturned] = response.cursor.firstBatch.length;
        } else {
          _this2[kNumReturned] = response.documents ? response.documents.length : 0;
        } // TODO: NODE-2882


        callback(undefined, {
          server: findOperation.server,
          session: session,
          response: response
        });
      });
    }
    /** @internal */

  }, {
    key: "_getMore",
    value: function _getMore(batchSize, callback) {
      var _this3 = this;

      // NOTE: this is to support client provided limits in pre-command servers
      var numReturned = this[kNumReturned];

      if (numReturned) {
        var limit = this[kBuiltOptions].limit;
        batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;

        if (batchSize <= 0) {
          return this.close(callback);
        }
      }

      _get(_getPrototypeOf(FindCursor.prototype), "_getMore", this).call(this, batchSize, function (err, response) {
        if (err) return callback(err); // TODO: wrap this in some logic to prevent it from happening if we don't need this support

        if (response) {
          _this3[kNumReturned] = _this3[kNumReturned] + response.cursor.nextBatch.length;
        }

        callback(undefined, response);
      });
    }
  }, {
    key: "count",
    value: function count(options, callback) {
      (0, utils_1.emitWarningOnce)('cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ');

      if (typeof options === 'boolean') {
        throw new error_1.MongoInvalidArgumentError('Invalid first parameter to count');
      }

      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};
      return (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this[kFilter], _objectSpread(_objectSpread(_objectSpread({}, this[kBuiltOptions]), this.cursorOptions), options)), callback);
    }
  }, {
    key: "explain",
    value: function explain(verbosity, callback) {
      if (typeof verbosity === 'function') callback = verbosity, verbosity = true;
      if (verbosity == null) verbosity = true;
      return (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(undefined, this.namespace, this[kFilter], _objectSpread(_objectSpread(_objectSpread({}, this[kBuiltOptions]), this.cursorOptions), {}, {
        explain: verbosity
      })), callback);
    }
    /** Set the cursor query */

  }, {
    key: "filter",
    value: function filter(_filter) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kFilter] = _filter;
      return this;
    }
    /**
     * Set the cursor hint
     *
     * @param hint - If specified, then the query system will only consider plans using the hinted index.
     */

  }, {
    key: "hint",
    value: function hint(_hint) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].hint = _hint;
      return this;
    }
    /**
     * Set the cursor min
     *
     * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.
     */

  }, {
    key: "min",
    value: function min(_min) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].min = _min;
      return this;
    }
    /**
     * Set the cursor max
     *
     * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.
     */

  }, {
    key: "max",
    value: function max(_max) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].max = _max;
      return this;
    }
    /**
     * Set the cursor returnKey.
     * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.
     * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.
     *
     * @param value - the returnKey value.
     */

  }, {
    key: "returnKey",
    value: function returnKey(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].returnKey = value;
      return this;
    }
    /**
     * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.
     *
     * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.
     */

  }, {
    key: "showRecordId",
    value: function showRecordId(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].showRecordId = value;
      return this;
    }
    /**
     * Add a query modifier to the cursor query
     *
     * @param name - The query modifier (must start with $, such as $orderby etc)
     * @param value - The modifier value.
     */

  }, {
    key: "addQueryModifier",
    value: function addQueryModifier(name, value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (name[0] !== '$') {
        throw new error_1.MongoInvalidArgumentError("".concat(name, " is not a valid query modifier"));
      } // Strip of the $


      var field = name.substr(1); // NOTE: consider some TS magic for this

      switch (field) {
        case 'comment':
          this[kBuiltOptions].comment = value;
          break;

        case 'explain':
          this[kBuiltOptions].explain = value;
          break;

        case 'hint':
          this[kBuiltOptions].hint = value;
          break;

        case 'max':
          this[kBuiltOptions].max = value;
          break;

        case 'maxTimeMS':
          this[kBuiltOptions].maxTimeMS = value;
          break;

        case 'min':
          this[kBuiltOptions].min = value;
          break;

        case 'orderby':
          this[kBuiltOptions].sort = (0, sort_1.formatSort)(value);
          break;

        case 'query':
          this[kFilter] = value;
          break;

        case 'returnKey':
          this[kBuiltOptions].returnKey = value;
          break;

        case 'showDiskLoc':
          this[kBuiltOptions].showRecordId = value;
          break;

        default:
          throw new error_1.MongoInvalidArgumentError("Invalid query modifier: ".concat(name));
      }

      return this;
    }
    /**
     * Add a comment to the cursor query allowing for tracking the comment in the log.
     *
     * @param value - The comment attached to this query.
     */

  }, {
    key: "comment",
    value: function comment(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].comment = value;
      return this;
    }
    /**
     * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)
     *
     * @param value - Number of milliseconds to wait before aborting the tailed query.
     */

  }, {
    key: "maxAwaitTimeMS",
    value: function maxAwaitTimeMS(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Argument for maxAwaitTimeMS must be a number');
      }

      this[kBuiltOptions].maxAwaitTimeMS = value;
      return this;
    }
    /**
     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
     *
     * @param value - Number of milliseconds to wait before aborting the query.
     */

  }, {
    key: "maxTimeMS",
    value: function maxTimeMS(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');
      }

      this[kBuiltOptions].maxTimeMS = value;
      return this;
    }
    /**
     * Add a project stage to the aggregation pipeline
     *
     * @remarks
     * In order to strictly type this function you must provide an interface
     * that represents the effect of your projection on the result documents.
     *
     * By default chaining a projection to your cursor changes the returned type to the generic
     * {@link Document} type.
     * You should specify a parameterized type to have assertions on your final results.
     *
     * @example
     * ```typescript
     * // Best way
     * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
     * // Flexible way
     * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });
     * ```
     *
     * @remarks
     *
     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
     * it **does not** return a new instance of a cursor. This means when calling project,
     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
     * Take note of the following example:
     *
     * @example
     * ```typescript
     * const cursor: FindCursor<{ a: number; b: string }> = coll.find();
     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
     *
     * // or always use chaining and save the final cursor
     *
     * const cursor = coll.find().project<{ a: string }>({
     *   _id: 0,
     *   a: { $convert: { input: '$a', to: 'string' }
     * }});
     * ```
     */

  }, {
    key: "project",
    value: function project(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].projection = value;
      return this;
    }
    /**
     * Sets the sort order of the cursor query.
     *
     * @param sort - The key or keys set for the sort.
     * @param direction - The direction of the sorting (1 or -1).
     */

  }, {
    key: "sort",
    value: function sort(_sort, direction) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError('Tailable cursor does not support sorting');
      }

      this[kBuiltOptions].sort = (0, sort_1.formatSort)(_sort, direction);
      return this;
    }
    /**
     * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)
     *
     * @remarks
     * {@link https://docs.mongodb.com/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}
     */

  }, {
    key: "allowDiskUse",
    value: function allowDiskUse() {
      var allow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (!this[kBuiltOptions].sort) {
        throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
      } // As of 6.0 the default is true. This allows users to get back to the old behaviour.


      if (!allow) {
        this[kBuiltOptions].allowDiskUse = false;
        return this;
      }

      this[kBuiltOptions].allowDiskUse = true;
      return this;
    }
    /**
     * Set the collation options for the cursor.
     *
     * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
     */

  }, {
    key: "collation",
    value: function collation(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].collation = value;
      return this;
    }
    /**
     * Set the limit for the cursor.
     *
     * @param value - The limit for the cursor query.
     */

  }, {
    key: "limit",
    value: function limit(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError('Tailable cursor does not support limit');
      }

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
      }

      this[kBuiltOptions].limit = value;
      return this;
    }
    /**
     * Set the skip for the cursor.
     *
     * @param value - The skip for the cursor query.
     */

  }, {
    key: "skip",
    value: function skip(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);

      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError('Tailable cursor does not support skip');
      }

      if (typeof value !== 'number') {
        throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
      }

      this[kBuiltOptions].skip = value;
      return this;
    }
  }]);

  return FindCursor;
}(abstract_cursor_1.AbstractCursor);

exports.FindCursor = FindCursor;

/***/ }),

/***/ 7940:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ListCollectionsCursor = void 0;

var execute_operation_1 = __webpack_require__(7887);

var list_collections_1 = __webpack_require__(3949);

var abstract_cursor_1 = __webpack_require__(3822);
/** @public */


var ListCollectionsCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(ListCollectionsCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(ListCollectionsCursor);

  function ListCollectionsCursor(db, filter, options) {
    var _this;

    _classCallCheck(this, ListCollectionsCursor);

    _this = _super.call(this, db.s.client, db.s.namespace, options);
    _this.parent = db;
    _this.filter = filter;
    _this.options = options;
    return _this;
  }

  _createClass(ListCollectionsCursor, [{
    key: "clone",
    value: function clone() {
      return new ListCollectionsCursor(this.parent, this.filter, _objectSpread(_objectSpread({}, this.options), this.cursorOptions));
    }
    /** @internal */

  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, _objectSpread(_objectSpread(_objectSpread({}, this.cursorOptions), this.options), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(this.parent.s.client, operation, function (err, response) {
        if (err || response == null) return callback(err); // TODO: NODE-2882

        callback(undefined, {
          server: operation.server,
          session: session,
          response: response
        });
      });
    }
  }]);

  return ListCollectionsCursor;
}(abstract_cursor_1.AbstractCursor);

exports.ListCollectionsCursor = ListCollectionsCursor;

/***/ }),

/***/ 668:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ListIndexesCursor = void 0;

var execute_operation_1 = __webpack_require__(7887);

var indexes_1 = __webpack_require__(6338);

var abstract_cursor_1 = __webpack_require__(3822);
/** @public */


var ListIndexesCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {
  _inherits(ListIndexesCursor, _abstract_cursor_1$Ab);

  var _super = _createSuper(ListIndexesCursor);

  function ListIndexesCursor(collection, options) {
    var _this;

    _classCallCheck(this, ListIndexesCursor);

    _this = _super.call(this, collection.s.db.s.client, collection.s.namespace, options);
    _this.parent = collection;
    _this.options = options;
    return _this;
  }

  _createClass(ListIndexesCursor, [{
    key: "clone",
    value: function clone() {
      return new ListIndexesCursor(this.parent, _objectSpread(_objectSpread({}, this.options), this.cursorOptions));
    }
    /** @internal */

  }, {
    key: "_initialize",
    value: function _initialize(session, callback) {
      var operation = new indexes_1.ListIndexesOperation(this.parent, _objectSpread(_objectSpread(_objectSpread({}, this.cursorOptions), this.options), {}, {
        session: session
      }));
      (0, execute_operation_1.executeOperation)(this.parent.s.db.s.client, operation, function (err, response) {
        if (err || response == null) return callback(err); // TODO: NODE-2882

        callback(undefined, {
          server: operation.server,
          session: session,
          response: response
        });
      });
    }
  }]);

  return ListIndexesCursor;
}(abstract_cursor_1.AbstractCursor);

exports.ListIndexesCursor = ListIndexesCursor;

/***/ }),

/***/ 9828:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Db = void 0;

var admin_1 = __webpack_require__(2563);

var bson_1 = __webpack_require__(53);

var change_stream_1 = __webpack_require__(4672);

var collection_1 = __webpack_require__(9730);

var CONSTANTS = __webpack_require__(1254);

var aggregation_cursor_1 = __webpack_require__(5983);

var list_collections_cursor_1 = __webpack_require__(7940);

var error_1 = __webpack_require__(9271);

var logger_1 = __webpack_require__(295);

var add_user_1 = __webpack_require__(8115);

var collections_1 = __webpack_require__(1119);

var create_collection_1 = __webpack_require__(1348);

var drop_1 = __webpack_require__(406);

var execute_operation_1 = __webpack_require__(7887);

var indexes_1 = __webpack_require__(6338);

var profiling_level_1 = __webpack_require__(3215);

var remove_user_1 = __webpack_require__(2560);

var rename_1 = __webpack_require__(8851);

var run_command_1 = __webpack_require__(5367);

var set_profiling_level_1 = __webpack_require__(7230);

var stats_1 = __webpack_require__(9073);

var read_concern_1 = __webpack_require__(2027);

var read_preference_1 = __webpack_require__(3985);

var utils_1 = __webpack_require__(4356);

var write_concern_1 = __webpack_require__(1473); // Allowed parameters


var DB_OPTIONS_ALLOW_LIST = ['writeConcern', 'readPreference', 'readPreferenceTags', 'native_parser', 'forceServerObjectId', 'pkFactory', 'serializeFunctions', 'raw', 'authSource', 'ignoreUndefined', 'readConcern', 'retryMiliSeconds', 'numberOfRetries', 'loggerLevel', 'logger', 'promoteBuffers', 'promoteLongs', 'bsonRegExp', 'enableUtf8Validation', 'promoteValues', 'compression', 'retryWrites'];
/**
 * The **Db** class is a class that represents a MongoDB Database.
 * @public
 *
 * @example
 * ```js
 * const { MongoClient } = require('mongodb');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) {
 *   // Select the database by name
 *   const testDb = client.db(dbName);
 *   client.close();
 * });
 * ```
 */

var Db = /*#__PURE__*/function () {
  /**
   * Creates a new Db instance
   *
   * @param client - The MongoClient for the database.
   * @param databaseName - The name of the database this instance represents.
   * @param options - Optional settings for Db construction
   */
  function Db(client, databaseName, options) {
    _classCallCheck(this, Db);

    var _a;

    options = options !== null && options !== void 0 ? options : {}; // Filter the options

    options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST); // Ensure we have a valid db name

    validateDatabaseName(databaseName); // Internal state of the db object

    this.s = {
      // Client
      client: client,
      // Options
      options: options,
      // Logger instance
      logger: new logger_1.Logger('Db', options),
      // Unpack read preference
      readPreference: read_preference_1.ReadPreference.fromOptions(options),
      // Merge bson options
      bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),
      // Set up the primary key factory or fallback to ObjectId
      pkFactory: (_a = options === null || options === void 0 ? void 0 : options.pkFactory) !== null && _a !== void 0 ? _a : utils_1.DEFAULT_PK_FACTORY,
      // ReadConcern
      readConcern: read_concern_1.ReadConcern.fromOptions(options),
      writeConcern: write_concern_1.WriteConcern.fromOptions(options),
      // Namespace
      namespace: new utils_1.MongoDBNamespace(databaseName)
    };
  }

  _createClass(Db, [{
    key: "databaseName",
    get: function get() {
      return this.s.namespace.db;
    } // Options

  }, {
    key: "options",
    get: function get() {
      return this.s.options;
    }
    /**
     * slaveOk specified
     * @deprecated Use secondaryOk instead
     */

  }, {
    key: "slaveOk",
    get: function get() {
      return this.secondaryOk;
    }
    /**
     * Check if a secondary can be used (because the read preference is *not* set to primary)
     */

  }, {
    key: "secondaryOk",
    get: function get() {
      var _a;

      return ((_a = this.s.readPreference) === null || _a === void 0 ? void 0 : _a.preference) !== 'primary' || false;
    }
  }, {
    key: "readConcern",
    get: function get() {
      return this.s.readConcern;
    }
    /**
     * The current readPreference of the Db. If not explicitly defined for
     * this Db, will be inherited from the parent MongoClient
     */

  }, {
    key: "readPreference",
    get: function get() {
      if (this.s.readPreference == null) {
        return this.s.client.readPreference;
      }

      return this.s.readPreference;
    }
  }, {
    key: "bsonOptions",
    get: function get() {
      return this.s.bsonOptions;
    } // get the write Concern

  }, {
    key: "writeConcern",
    get: function get() {
      return this.s.writeConcern;
    }
  }, {
    key: "namespace",
    get: function get() {
      return this.s.namespace.toString();
    }
  }, {
    key: "createCollection",
    value: function createCollection(name, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "command",
    value: function command(_command, options, callback) {
      if (typeof options === 'function') callback = options, options = {}; // Intentionally, we do not inherit options from parent for this operation.

      return (0, execute_operation_1.executeOperation)(this.s.client, new run_command_1.RunCommandOperation(this, _command, options !== null && options !== void 0 ? options : {}), callback);
    }
    /**
     * Execute an aggregation framework pipeline against the database, needs MongoDB \>= 3.6
     *
     * @param pipeline - An array of aggregation stages to be executed
     * @param options - Optional settings for the command
     */

  }, {
    key: "aggregate",
    value: function aggregate() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 ? arguments[1] : undefined;

      if (arguments.length > 2) {
        throw new error_1.MongoInvalidArgumentError('Method "db.aggregate()" accepts at most two arguments');
      }

      if (typeof pipeline === 'function') {
        throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must not be function');
      }

      if (typeof options === 'function') {
        throw new error_1.MongoInvalidArgumentError('Argument "options" must not be function');
      }

      return new aggregation_cursor_1.AggregationCursor(this.s.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    /** Return the Admin db instance */

  }, {
    key: "admin",
    value: function admin() {
      return new admin_1.Admin(this);
    }
    /**
     * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.
     *
     * @param name - the collection name we wish to access.
     * @returns return the new Collection instance
     */

  }, {
    key: "collection",
    value: function collection(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (typeof options === 'function') {
        throw new error_1.MongoInvalidArgumentError('The callback form of this helper has been removed.');
      }

      var finalOptions = (0, utils_1.resolveOptions)(this, options);
      return new collection_1.Collection(this, name, finalOptions);
    }
  }, {
    key: "stats",
    value: function stats(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "listCollections",
    value: function listCollections() {
      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));
    }
  }, {
    key: "renameCollection",
    value: function renameCollection(fromCollection, toCollection, options, callback) {
      if (typeof options === 'function') callback = options, options = {}; // Intentionally, we do not inherit options from parent for this operation.

      options = _objectSpread(_objectSpread({}, options), {}, {
        readPreference: read_preference_1.ReadPreference.PRIMARY
      }); // Add return new collection

      options.new_collection = true;
      return (0, execute_operation_1.executeOperation)(this.s.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, options), callback);
    }
  }, {
    key: "dropCollection",
    value: function dropCollection(name, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "dropDatabase",
    value: function dropDatabase(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "collections",
    value: function collections(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "createIndex",
    value: function createIndex(name, indexSpec, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new indexes_1.CreateIndexOperation(this, name, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "addUser",
    value: function addUser(username, password, options, callback) {
      if (typeof password === 'function') {
        callback = password, password = undefined, options = {};
      } else if (typeof password !== 'string') {
        if (typeof options === 'function') {
          callback = options, options = password, password = undefined;
        } else {
          options = password, callback = undefined, password = undefined;
        }
      } else {
        if (typeof options === 'function') callback = options, options = {};
      }

      return (0, execute_operation_1.executeOperation)(this.s.client, new add_user_1.AddUserOperation(this, username, password, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "removeUser",
    value: function removeUser(username, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "setProfilingLevel",
    value: function setProfilingLevel(level, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "profilingLevel",
    value: function profilingLevel(options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
    }
  }, {
    key: "indexInformation",
    value: function indexInformation(name, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      return (0, execute_operation_1.executeOperation)(this.s.client, new indexes_1.IndexInformationOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);
    }
    /**
     * Unref all sockets
     * @deprecated This function is deprecated and will be removed in the next major version.
     */

  }, {
    key: "unref",
    value: function unref() {
      (0, utils_1.getTopology)(this).unref();
    }
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates,
     * replacements, deletions, and invalidations) in this database. Will ignore all
     * changes to system collections.
     *
     * @remarks
     * watch() accepts two generic arguments for distinct usecases:
     * - The first is to provide the schema that may be defined for all the collections within this database
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     *
     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     * @typeParam TSchema - Type of the data being detected by the change stream
     * @typeParam TChange - Type of the whole change stream document emitted
     */

  }, {
    key: "watch",
    value: function watch() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Allow optionally not specifying a pipeline
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }

      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    /** Return the db logger */

  }, {
    key: "getLogger",
    value: function getLogger() {
      return this.s.logger;
    }
  }, {
    key: "logger",
    get: function get() {
      return this.s.logger;
    }
  }]);

  return Db;
}();

exports.Db = Db;
Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION; // TODO(NODE-3484): Refactor into MongoDBNamespace
// Validate the database name

function validateDatabaseName(databaseName) {
  if (typeof databaseName !== 'string') throw new error_1.MongoInvalidArgumentError('Database name must be a string');
  if (databaseName.length === 0) throw new error_1.MongoInvalidArgumentError('Database name cannot be the empty string');
  if (databaseName === '$external') return;
  var invalidChars = [' ', '.', '$', '/', '\\'];

  for (var i = 0; i < invalidChars.length; i++) {
    if (databaseName.indexOf(invalidChars[i]) !== -1) throw new error_1.MongoAPIError("database names cannot contain the character '".concat(invalidChars[i], "'"));
  }
}

/***/ }),

/***/ 2524:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AutoEncryptionLoggerLevel = exports.aws4 = exports.saslprep = exports.Snappy = exports.ZStandard = exports.Kerberos = exports.PKG_VERSION = void 0;

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

exports.PKG_VERSION = Symbol('kPkgVersion');

function makeErrorModule(error) {
  var props = error ? {
    kModuleError: error
  } : {};
  return new Proxy(props, {
    get: function get(_, key) {
      if (key === 'kModuleError') {
        return error;
      }

      throw error;
    },
    set: function set() {
      throw error;
    }
  });
}

exports.Kerberos = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `kerberos` not found. Please install it to enable kerberos authentication'));

try {
  // Ensure you always wrap an optional require in the try block NODE-3199
  exports.Kerberos = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'kerberos'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
} catch (_unused) {} // eslint-disable-line


exports.ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression'));

try {
  exports.ZStandard = Object(function webpackMissingModule() { var e = new Error("Cannot find module '@mongodb-js/zstd'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
} catch (_unused2) {} // eslint-disable-line


exports.Snappy = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `snappy` not found. Please install it to enable snappy compression'));

try {
  // Ensure you always wrap an optional require in the try block NODE-3199
  exports.Snappy = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'snappy'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

  try {
    exports.Snappy[exports.PKG_VERSION] = (0, utils_1.parsePackageVersion)(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'snappy/package.json'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
  } catch (_unused3) {} // eslint-disable-line

} catch (_unused4) {} // eslint-disable-line


exports.saslprep = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `saslprep` not found.' + ' Please install it to enable Stringprep Profile for User Names and Passwords'));

try {
  // Ensure you always wrap an optional require in the try block NODE-3199
  exports.saslprep = __webpack_require__(2066);
} catch (_unused5) {} // eslint-disable-line


exports.aws4 = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `aws4` not found. Please install it to enable AWS authentication'));

try {
  // Ensure you always wrap an optional require in the try block NODE-3199
  exports.aws4 = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'aws4'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
} catch (_unused6) {} // eslint-disable-line

/** @public */


exports.AutoEncryptionLoggerLevel = Object.freeze({
  FatalError: 0,
  Error: 1,
  Warning: 2,
  Info: 3,
  Trace: 4
});

/***/ }),

/***/ 353:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Encrypter = void 0;
/* eslint-disable @typescript-eslint/no-var-requires */

var bson_1 = __webpack_require__(53);

var constants_1 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var mongo_client_1 = __webpack_require__(9635);

var utils_1 = __webpack_require__(4356);

var AutoEncrypterClass;
/** @internal */

var kInternalClient = Symbol('internalClient');
/** @internal */

var Encrypter = /*#__PURE__*/function () {
  function Encrypter(client, uri, options) {
    _classCallCheck(this, Encrypter);

    if (_typeof(options.autoEncryption) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
    } // initialize to null, if we call getInternalClient, we may set this it is important to not overwrite those function calls.


    this[kInternalClient] = null;
    this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
    this.needsConnecting = false;

    if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
      options.autoEncryption.keyVaultClient = client;
    } else if (options.autoEncryption.keyVaultClient == null) {
      options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options);
    }

    if (this.bypassAutoEncryption) {
      options.autoEncryption.metadataClient = undefined;
    } else if (options.maxPoolSize === 0) {
      options.autoEncryption.metadataClient = client;
    } else {
      options.autoEncryption.metadataClient = this.getInternalClient(client, uri, options);
    }

    if (options.proxyHost) {
      options.autoEncryption.proxyOptions = {
        proxyHost: options.proxyHost,
        proxyPort: options.proxyPort,
        proxyUsername: options.proxyUsername,
        proxyPassword: options.proxyPassword
      };
    }

    options.autoEncryption.bson = Object.create(null); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    options.autoEncryption.bson.serialize = bson_1.serialize; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    options.autoEncryption.bson.deserialize = bson_1.deserialize;
    this.autoEncrypter = new AutoEncrypterClass(client, options.autoEncryption);
  }

  _createClass(Encrypter, [{
    key: "getInternalClient",
    value: function getInternalClient(client, uri, options) {
      // TODO(NODE-4144): Remove new variable for type narrowing
      var internalClient = this[kInternalClient];

      if (internalClient == null) {
        var clonedOptions = {};

        for (var _i = 0, _arr = [].concat(_toConsumableArray(Object.getOwnPropertyNames(options)), _toConsumableArray(Object.getOwnPropertySymbols(options))); _i < _arr.length; _i++) {
          var key = _arr[_i];
          if (['autoEncryption', 'minPoolSize', 'servers', 'caseTranslate', 'dbName'].includes(key)) continue;
          Reflect.set(clonedOptions, key, Reflect.get(options, key));
        }

        clonedOptions.minPoolSize = 0;
        internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
        this[kInternalClient] = internalClient;

        var _iterator = _createForOfIteratorHelper(constants_1.MONGO_CLIENT_EVENTS),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var eventName = _step.value;

            var _iterator2 = _createForOfIteratorHelper(client.listeners(eventName)),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var listener = _step2.value;
                internalClient.on(eventName, listener);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        client.on('newListener', function (eventName, listener) {
          internalClient === null || internalClient === void 0 ? void 0 : internalClient.on(eventName, listener);
        });
        this.needsConnecting = true;
      }

      return internalClient;
    }
  }, {
    key: "connectInternalClient",
    value: function connectInternalClient(callback) {
      // TODO(NODE-4144): Remove new variable for type narrowing
      var internalClient = this[kInternalClient];

      if (this.needsConnecting && internalClient != null) {
        this.needsConnecting = false;
        return internalClient.connect(callback);
      }

      return callback();
    }
  }, {
    key: "close",
    value: function close(client, force, callback) {
      var _this = this;

      this.autoEncrypter.teardown(!!force, function (e) {
        var internalClient = _this[kInternalClient];

        if (internalClient != null && client !== internalClient) {
          return internalClient.close(force, callback);
        }

        callback(e);
      });
    }
  }], [{
    key: "checkForMongoCrypt",
    value: function checkForMongoCrypt() {
      var mongodbClientEncryption = (0, utils_1.getMongoDBClientEncryption)();

      if (mongodbClientEncryption == null) {
        throw new error_1.MongoMissingDependencyError('Auto-encryption requested, but the module is not installed. ' + 'Please add `mongodb-client-encryption` as a dependency of your project');
      }

      AutoEncrypterClass = mongodbClientEncryption.extension(__webpack_require__(4515)).AutoEncrypter;
    }
  }]);

  return Encrypter;
}();

exports.Encrypter = Encrypter;

/***/ }),

/***/ 9271:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isResumableError = exports.isNetworkTimeoutError = exports.isSDAMUnrecoverableError = exports.isNodeShuttingDownError = exports.isRetryableReadError = exports.isRetryableWriteError = exports.needsRetryableWriteLabel = exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoSystemError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoCompatibilityError = exports.MongoInvalidArgumentError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.isNetworkErrorBeforeHandshake = exports.MongoTopologyClosedError = exports.MongoCursorExhaustedError = exports.MongoServerClosedError = exports.MongoCursorInUseError = exports.MongoUnexpectedServerResponseError = exports.MongoGridFSChunkError = exports.MongoGridFSStreamError = exports.MongoTailableCursorError = exports.MongoChangeStreamError = exports.MongoAWSError = exports.MongoKerberosError = exports.MongoExpiredSessionError = exports.MongoTransactionError = exports.MongoNotConnectedError = exports.MongoDecompressionError = exports.MongoBatchReExecutionError = exports.MongoRuntimeError = exports.MongoAPIError = exports.MongoDriverError = exports.MongoServerError = exports.MongoError = exports.MongoErrorLabel = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = exports.NODE_IS_RECOVERING_ERROR_MESSAGE = exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = void 0;
/** @internal */

var kErrorLabels = Symbol('errorLabels');
/**
 * @internal
 * The legacy error message from the server that indicates the node is not a writable primary
 * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering
 */

exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp('not master', 'i');
/**
 * @internal
 * The legacy error message from the server that indicates the node is not a primary or secondary
 * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering
 */

exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp('not master or secondary', 'i');
/**
 * @internal
 * The error message from the server that indicates the node is recovering
 * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering
 */

exports.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp('node is recovering', 'i');
/** @internal MongoDB Error Codes */

exports.MONGODB_ERROR_CODES = Object.freeze({
  HostUnreachable: 6,
  HostNotFound: 7,
  NetworkTimeout: 89,
  ShutdownInProgress: 91,
  PrimarySteppedDown: 189,
  ExceededTimeLimit: 262,
  SocketException: 9001,
  NotWritablePrimary: 10107,
  InterruptedAtShutdown: 11600,
  InterruptedDueToReplStateChange: 11602,
  NotPrimaryNoSecondaryOk: 13435,
  NotPrimaryOrSecondary: 13436,
  StaleShardVersion: 63,
  StaleEpoch: 150,
  StaleConfig: 13388,
  RetryChangeStream: 234,
  FailedToSatisfyReadPreference: 133,
  CursorNotFound: 43,
  LegacyNotPrimary: 10058,
  WriteConcernFailed: 64,
  NamespaceNotFound: 26,
  IllegalOperation: 20,
  MaxTimeMSExpired: 50,
  UnknownReplWriteConcern: 79,
  UnsatisfiableWriteConcern: 100
}); // From spec@https://github.com/mongodb/specifications/blob/f93d78191f3db2898a59013a7ed5650352ef6da8/source/change-streams/change-streams.rst#resumable-error

exports.GET_MORE_RESUMABLE_CODES = new Set([exports.MONGODB_ERROR_CODES.HostUnreachable, exports.MONGODB_ERROR_CODES.HostNotFound, exports.MONGODB_ERROR_CODES.NetworkTimeout, exports.MONGODB_ERROR_CODES.ShutdownInProgress, exports.MONGODB_ERROR_CODES.PrimarySteppedDown, exports.MONGODB_ERROR_CODES.ExceededTimeLimit, exports.MONGODB_ERROR_CODES.SocketException, exports.MONGODB_ERROR_CODES.NotWritablePrimary, exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange, exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk, exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary, exports.MONGODB_ERROR_CODES.StaleShardVersion, exports.MONGODB_ERROR_CODES.StaleEpoch, exports.MONGODB_ERROR_CODES.StaleConfig, exports.MONGODB_ERROR_CODES.RetryChangeStream, exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference, exports.MONGODB_ERROR_CODES.CursorNotFound]);
/** @public */

exports.MongoErrorLabel = Object.freeze({
  RetryableWriteError: 'RetryableWriteError',
  TransientTransactionError: 'TransientTransactionError',
  UnknownTransactionCommitResult: 'UnknownTransactionCommitResult',
  ResumableChangeStreamError: 'ResumableChangeStreamError',
  HandshakeError: 'HandshakeError'
});
/**
 * @public
 * @category Error
 *
 * @privateRemarks
 * CSFLE has a dependency on this error, it uses the constructor with a string argument
 */

var MongoError = /*#__PURE__*/function (_Error) {
  _inherits(MongoError, _Error);

  var _super = _createSuper(MongoError);

  function MongoError(message) {
    var _this;

    _classCallCheck(this, MongoError);

    if (message instanceof Error) {
      _this = _super.call(this, message.message);
    } else {
      _this = _super.call(this, message);
    }

    _this[kErrorLabels] = new Set();
    return _possibleConstructorReturn(_this);
  }

  _createClass(MongoError, [{
    key: "name",
    get: function get() {
      return 'MongoError';
    }
    /** Legacy name for server error responses */

  }, {
    key: "errmsg",
    get: function get() {
      return this.message;
    }
    /**
     * Checks the error to see if it has an error label
     *
     * @param label - The error label to check for
     * @returns returns true if the error has the provided error label
     */

  }, {
    key: "hasErrorLabel",
    value: function hasErrorLabel(label) {
      return this[kErrorLabels].has(label);
    }
  }, {
    key: "addErrorLabel",
    value: function addErrorLabel(label) {
      this[kErrorLabels].add(label);
    }
  }, {
    key: "errorLabels",
    get: function get() {
      return Array.from(this[kErrorLabels]);
    }
  }]);

  return MongoError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports.MongoError = MongoError;
/**
 * An error coming from the mongo server
 *
 * @public
 * @category Error
 */

var MongoServerError = /*#__PURE__*/function (_MongoError) {
  _inherits(MongoServerError, _MongoError);

  var _super2 = _createSuper(MongoServerError);

  function MongoServerError(message) {
    var _this2;

    _classCallCheck(this, MongoServerError);

    _this2 = _super2.call(this, message.message || message.errmsg || message.$err || 'n/a');

    if (message.errorLabels) {
      _this2[kErrorLabels] = new Set(message.errorLabels);
    }

    for (var name in message) {
      if (name !== 'errorLabels' && name !== 'errmsg' && name !== 'message') _this2[name] = message[name];
    }

    return _this2;
  }

  _createClass(MongoServerError, [{
    key: "name",
    get: function get() {
      return 'MongoServerError';
    }
  }]);

  return MongoServerError;
}(MongoError);

exports.MongoServerError = MongoServerError;
/**
 * An error generated by the driver
 *
 * @public
 * @category Error
 */

var MongoDriverError = /*#__PURE__*/function (_MongoError2) {
  _inherits(MongoDriverError, _MongoError2);

  var _super3 = _createSuper(MongoDriverError);

  function MongoDriverError(message) {
    _classCallCheck(this, MongoDriverError);

    return _super3.call(this, message);
  }

  _createClass(MongoDriverError, [{
    key: "name",
    get: function get() {
      return 'MongoDriverError';
    }
  }]);

  return MongoDriverError;
}(MongoError);

exports.MongoDriverError = MongoDriverError;
/**
 * An error generated when the driver API is used incorrectly
 *
 * @privateRemarks
 * Should **never** be directly instantiated
 *
 * @public
 * @category Error
 */

var MongoAPIError = /*#__PURE__*/function (_MongoDriverError) {
  _inherits(MongoAPIError, _MongoDriverError);

  var _super4 = _createSuper(MongoAPIError);

  function MongoAPIError(message) {
    _classCallCheck(this, MongoAPIError);

    return _super4.call(this, message);
  }

  _createClass(MongoAPIError, [{
    key: "name",
    get: function get() {
      return 'MongoAPIError';
    }
  }]);

  return MongoAPIError;
}(MongoDriverError);

exports.MongoAPIError = MongoAPIError;
/**
 * An error generated when the driver encounters unexpected input
 * or reaches an unexpected/invalid internal state
 *
 * @privateRemarks
 * Should **never** be directly instantiated.
 *
 * @public
 * @category Error
 */

var MongoRuntimeError = /*#__PURE__*/function (_MongoDriverError2) {
  _inherits(MongoRuntimeError, _MongoDriverError2);

  var _super5 = _createSuper(MongoRuntimeError);

  function MongoRuntimeError(message) {
    _classCallCheck(this, MongoRuntimeError);

    return _super5.call(this, message);
  }

  _createClass(MongoRuntimeError, [{
    key: "name",
    get: function get() {
      return 'MongoRuntimeError';
    }
  }]);

  return MongoRuntimeError;
}(MongoDriverError);

exports.MongoRuntimeError = MongoRuntimeError;
/**
 * An error generated when a batch command is re-executed after one of the commands in the batch
 * has failed
 *
 * @public
 * @category Error
 */

var MongoBatchReExecutionError = /*#__PURE__*/function (_MongoAPIError) {
  _inherits(MongoBatchReExecutionError, _MongoAPIError);

  var _super6 = _createSuper(MongoBatchReExecutionError);

  function MongoBatchReExecutionError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'This batch has already been executed, create new batch to execute';

    _classCallCheck(this, MongoBatchReExecutionError);

    return _super6.call(this, message);
  }

  _createClass(MongoBatchReExecutionError, [{
    key: "name",
    get: function get() {
      return 'MongoBatchReExecutionError';
    }
  }]);

  return MongoBatchReExecutionError;
}(MongoAPIError);

exports.MongoBatchReExecutionError = MongoBatchReExecutionError;
/**
 * An error generated when the driver fails to decompress
 * data received from the server.
 *
 * @public
 * @category Error
 */

var MongoDecompressionError = /*#__PURE__*/function (_MongoRuntimeError) {
  _inherits(MongoDecompressionError, _MongoRuntimeError);

  var _super7 = _createSuper(MongoDecompressionError);

  function MongoDecompressionError(message) {
    _classCallCheck(this, MongoDecompressionError);

    return _super7.call(this, message);
  }

  _createClass(MongoDecompressionError, [{
    key: "name",
    get: function get() {
      return 'MongoDecompressionError';
    }
  }]);

  return MongoDecompressionError;
}(MongoRuntimeError);

exports.MongoDecompressionError = MongoDecompressionError;
/**
 * An error thrown when the user attempts to operate on a database or collection through a MongoClient
 * that has not yet successfully called the "connect" method
 *
 * @public
 * @category Error
 */

var MongoNotConnectedError = /*#__PURE__*/function (_MongoAPIError2) {
  _inherits(MongoNotConnectedError, _MongoAPIError2);

  var _super8 = _createSuper(MongoNotConnectedError);

  function MongoNotConnectedError(message) {
    _classCallCheck(this, MongoNotConnectedError);

    return _super8.call(this, message);
  }

  _createClass(MongoNotConnectedError, [{
    key: "name",
    get: function get() {
      return 'MongoNotConnectedError';
    }
  }]);

  return MongoNotConnectedError;
}(MongoAPIError);

exports.MongoNotConnectedError = MongoNotConnectedError;
/**
 * An error generated when the user makes a mistake in the usage of transactions.
 * (e.g. attempting to commit a transaction with a readPreference other than primary)
 *
 * @public
 * @category Error
 */

var MongoTransactionError = /*#__PURE__*/function (_MongoAPIError3) {
  _inherits(MongoTransactionError, _MongoAPIError3);

  var _super9 = _createSuper(MongoTransactionError);

  function MongoTransactionError(message) {
    _classCallCheck(this, MongoTransactionError);

    return _super9.call(this, message);
  }

  _createClass(MongoTransactionError, [{
    key: "name",
    get: function get() {
      return 'MongoTransactionError';
    }
  }]);

  return MongoTransactionError;
}(MongoAPIError);

exports.MongoTransactionError = MongoTransactionError;
/**
 * An error generated when the user attempts to operate
 * on a session that has expired or has been closed.
 *
 * @public
 * @category Error
 */

var MongoExpiredSessionError = /*#__PURE__*/function (_MongoAPIError4) {
  _inherits(MongoExpiredSessionError, _MongoAPIError4);

  var _super10 = _createSuper(MongoExpiredSessionError);

  function MongoExpiredSessionError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Cannot use a session that has ended';

    _classCallCheck(this, MongoExpiredSessionError);

    return _super10.call(this, message);
  }

  _createClass(MongoExpiredSessionError, [{
    key: "name",
    get: function get() {
      return 'MongoExpiredSessionError';
    }
  }]);

  return MongoExpiredSessionError;
}(MongoAPIError);

exports.MongoExpiredSessionError = MongoExpiredSessionError;
/**
 * A error generated when the user attempts to authenticate
 * via Kerberos, but fails to connect to the Kerberos client.
 *
 * @public
 * @category Error
 */

var MongoKerberosError = /*#__PURE__*/function (_MongoRuntimeError2) {
  _inherits(MongoKerberosError, _MongoRuntimeError2);

  var _super11 = _createSuper(MongoKerberosError);

  function MongoKerberosError(message) {
    _classCallCheck(this, MongoKerberosError);

    return _super11.call(this, message);
  }

  _createClass(MongoKerberosError, [{
    key: "name",
    get: function get() {
      return 'MongoKerberosError';
    }
  }]);

  return MongoKerberosError;
}(MongoRuntimeError);

exports.MongoKerberosError = MongoKerberosError;
/**
 * A error generated when the user attempts to authenticate
 * via AWS, but fails
 *
 * @public
 * @category Error
 */

var MongoAWSError = /*#__PURE__*/function (_MongoRuntimeError3) {
  _inherits(MongoAWSError, _MongoRuntimeError3);

  var _super12 = _createSuper(MongoAWSError);

  function MongoAWSError(message) {
    _classCallCheck(this, MongoAWSError);

    return _super12.call(this, message);
  }

  _createClass(MongoAWSError, [{
    key: "name",
    get: function get() {
      return 'MongoAWSError';
    }
  }]);

  return MongoAWSError;
}(MongoRuntimeError);

exports.MongoAWSError = MongoAWSError;
/**
 * An error generated when a ChangeStream operation fails to execute.
 *
 * @public
 * @category Error
 */

var MongoChangeStreamError = /*#__PURE__*/function (_MongoRuntimeError4) {
  _inherits(MongoChangeStreamError, _MongoRuntimeError4);

  var _super13 = _createSuper(MongoChangeStreamError);

  function MongoChangeStreamError(message) {
    _classCallCheck(this, MongoChangeStreamError);

    return _super13.call(this, message);
  }

  _createClass(MongoChangeStreamError, [{
    key: "name",
    get: function get() {
      return 'MongoChangeStreamError';
    }
  }]);

  return MongoChangeStreamError;
}(MongoRuntimeError);

exports.MongoChangeStreamError = MongoChangeStreamError;
/**
 * An error thrown when the user calls a function or method not supported on a tailable cursor
 *
 * @public
 * @category Error
 */

var MongoTailableCursorError = /*#__PURE__*/function (_MongoAPIError5) {
  _inherits(MongoTailableCursorError, _MongoAPIError5);

  var _super14 = _createSuper(MongoTailableCursorError);

  function MongoTailableCursorError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Tailable cursor does not support this operation';

    _classCallCheck(this, MongoTailableCursorError);

    return _super14.call(this, message);
  }

  _createClass(MongoTailableCursorError, [{
    key: "name",
    get: function get() {
      return 'MongoTailableCursorError';
    }
  }]);

  return MongoTailableCursorError;
}(MongoAPIError);

exports.MongoTailableCursorError = MongoTailableCursorError;
/** An error generated when a GridFSStream operation fails to execute.
 *
 * @public
 * @category Error
 */

var MongoGridFSStreamError = /*#__PURE__*/function (_MongoRuntimeError5) {
  _inherits(MongoGridFSStreamError, _MongoRuntimeError5);

  var _super15 = _createSuper(MongoGridFSStreamError);

  function MongoGridFSStreamError(message) {
    _classCallCheck(this, MongoGridFSStreamError);

    return _super15.call(this, message);
  }

  _createClass(MongoGridFSStreamError, [{
    key: "name",
    get: function get() {
      return 'MongoGridFSStreamError';
    }
  }]);

  return MongoGridFSStreamError;
}(MongoRuntimeError);

exports.MongoGridFSStreamError = MongoGridFSStreamError;
/**
 * An error generated when a malformed or invalid chunk is
 * encountered when reading from a GridFSStream.
 *
 * @public
 * @category Error
 */

var MongoGridFSChunkError = /*#__PURE__*/function (_MongoRuntimeError6) {
  _inherits(MongoGridFSChunkError, _MongoRuntimeError6);

  var _super16 = _createSuper(MongoGridFSChunkError);

  function MongoGridFSChunkError(message) {
    _classCallCheck(this, MongoGridFSChunkError);

    return _super16.call(this, message);
  }

  _createClass(MongoGridFSChunkError, [{
    key: "name",
    get: function get() {
      return 'MongoGridFSChunkError';
    }
  }]);

  return MongoGridFSChunkError;
}(MongoRuntimeError);

exports.MongoGridFSChunkError = MongoGridFSChunkError;
/**
 * An error generated when a **parsable** unexpected response comes from the server.
 * This is generally an error where the driver in a state expecting a certain behavior to occur in
 * the next message from MongoDB but it receives something else.
 * This error **does not** represent an issue with wire message formatting.
 *
 * #### Example
 * When an operation fails, it is the driver's job to retry it. It must perform serverSelection
 * again to make sure that it attempts the operation against a server in a good state. If server
 * selection returns a server that does not support retryable operations, this error is used.
 * This scenario is unlikely as retryable support would also have been determined on the first attempt
 * but it is possible the state change could report a selectable server that does not support retries.
 *
 * @public
 * @category Error
 */

var MongoUnexpectedServerResponseError = /*#__PURE__*/function (_MongoRuntimeError7) {
  _inherits(MongoUnexpectedServerResponseError, _MongoRuntimeError7);

  var _super17 = _createSuper(MongoUnexpectedServerResponseError);

  function MongoUnexpectedServerResponseError(message) {
    _classCallCheck(this, MongoUnexpectedServerResponseError);

    return _super17.call(this, message);
  }

  _createClass(MongoUnexpectedServerResponseError, [{
    key: "name",
    get: function get() {
      return 'MongoUnexpectedServerResponseError';
    }
  }]);

  return MongoUnexpectedServerResponseError;
}(MongoRuntimeError);

exports.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;
/**
 * An error thrown when the user attempts to add options to a cursor that has already been
 * initialized
 *
 * @public
 * @category Error
 */

var MongoCursorInUseError = /*#__PURE__*/function (_MongoAPIError6) {
  _inherits(MongoCursorInUseError, _MongoAPIError6);

  var _super18 = _createSuper(MongoCursorInUseError);

  function MongoCursorInUseError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Cursor is already initialized';

    _classCallCheck(this, MongoCursorInUseError);

    return _super18.call(this, message);
  }

  _createClass(MongoCursorInUseError, [{
    key: "name",
    get: function get() {
      return 'MongoCursorInUseError';
    }
  }]);

  return MongoCursorInUseError;
}(MongoAPIError);

exports.MongoCursorInUseError = MongoCursorInUseError;
/**
 * An error generated when an attempt is made to operate
 * on a closed/closing server.
 *
 * @public
 * @category Error
 */

var MongoServerClosedError = /*#__PURE__*/function (_MongoAPIError7) {
  _inherits(MongoServerClosedError, _MongoAPIError7);

  var _super19 = _createSuper(MongoServerClosedError);

  function MongoServerClosedError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Server is closed';

    _classCallCheck(this, MongoServerClosedError);

    return _super19.call(this, message);
  }

  _createClass(MongoServerClosedError, [{
    key: "name",
    get: function get() {
      return 'MongoServerClosedError';
    }
  }]);

  return MongoServerClosedError;
}(MongoAPIError);

exports.MongoServerClosedError = MongoServerClosedError;
/**
 * An error thrown when an attempt is made to read from a cursor that has been exhausted
 *
 * @public
 * @category Error
 */

var MongoCursorExhaustedError = /*#__PURE__*/function (_MongoAPIError8) {
  _inherits(MongoCursorExhaustedError, _MongoAPIError8);

  var _super20 = _createSuper(MongoCursorExhaustedError);

  function MongoCursorExhaustedError(message) {
    _classCallCheck(this, MongoCursorExhaustedError);

    return _super20.call(this, message || 'Cursor is exhausted');
  }

  _createClass(MongoCursorExhaustedError, [{
    key: "name",
    get: function get() {
      return 'MongoCursorExhaustedError';
    }
  }]);

  return MongoCursorExhaustedError;
}(MongoAPIError);

exports.MongoCursorExhaustedError = MongoCursorExhaustedError;
/**
 * An error generated when an attempt is made to operate on a
 * dropped, or otherwise unavailable, database.
 *
 * @public
 * @category Error
 */

var MongoTopologyClosedError = /*#__PURE__*/function (_MongoAPIError9) {
  _inherits(MongoTopologyClosedError, _MongoAPIError9);

  var _super21 = _createSuper(MongoTopologyClosedError);

  function MongoTopologyClosedError() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Topology is closed';

    _classCallCheck(this, MongoTopologyClosedError);

    return _super21.call(this, message);
  }

  _createClass(MongoTopologyClosedError, [{
    key: "name",
    get: function get() {
      return 'MongoTopologyClosedError';
    }
  }]);

  return MongoTopologyClosedError;
}(MongoAPIError);

exports.MongoTopologyClosedError = MongoTopologyClosedError;
/** @internal */

var kBeforeHandshake = Symbol('beforeHandshake');

function isNetworkErrorBeforeHandshake(err) {
  return err[kBeforeHandshake] === true;
}

exports.isNetworkErrorBeforeHandshake = isNetworkErrorBeforeHandshake;
/**
 * An error indicating an issue with the network, including TCP errors and timeouts.
 * @public
 * @category Error
 */

var MongoNetworkError = /*#__PURE__*/function (_MongoError3) {
  _inherits(MongoNetworkError, _MongoError3);

  var _super22 = _createSuper(MongoNetworkError);

  function MongoNetworkError(message, options) {
    var _this3;

    _classCallCheck(this, MongoNetworkError);

    _this3 = _super22.call(this, message);

    if (options && typeof options.beforeHandshake === 'boolean') {
      _this3[kBeforeHandshake] = options.beforeHandshake;
    }

    return _this3;
  }

  _createClass(MongoNetworkError, [{
    key: "name",
    get: function get() {
      return 'MongoNetworkError';
    }
  }]);

  return MongoNetworkError;
}(MongoError);

exports.MongoNetworkError = MongoNetworkError;
/**
 * An error indicating a network timeout occurred
 * @public
 * @category Error
 *
 * @privateRemarks
 * CSFLE has a dependency on this error with an instanceof check
 */

var MongoNetworkTimeoutError = /*#__PURE__*/function (_MongoNetworkError) {
  _inherits(MongoNetworkTimeoutError, _MongoNetworkError);

  var _super23 = _createSuper(MongoNetworkTimeoutError);

  function MongoNetworkTimeoutError(message, options) {
    _classCallCheck(this, MongoNetworkTimeoutError);

    return _super23.call(this, message, options);
  }

  _createClass(MongoNetworkTimeoutError, [{
    key: "name",
    get: function get() {
      return 'MongoNetworkTimeoutError';
    }
  }]);

  return MongoNetworkTimeoutError;
}(MongoNetworkError);

exports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;
/**
 * An error used when attempting to parse a value (like a connection string)
 * @public
 * @category Error
 */

var MongoParseError = /*#__PURE__*/function (_MongoDriverError3) {
  _inherits(MongoParseError, _MongoDriverError3);

  var _super24 = _createSuper(MongoParseError);

  function MongoParseError(message) {
    _classCallCheck(this, MongoParseError);

    return _super24.call(this, message);
  }

  _createClass(MongoParseError, [{
    key: "name",
    get: function get() {
      return 'MongoParseError';
    }
  }]);

  return MongoParseError;
}(MongoDriverError);

exports.MongoParseError = MongoParseError;
/**
 * An error generated when the user supplies malformed or unexpected arguments
 * or when a required argument or field is not provided.
 *
 *
 * @public
 * @category Error
 */

var MongoInvalidArgumentError = /*#__PURE__*/function (_MongoAPIError10) {
  _inherits(MongoInvalidArgumentError, _MongoAPIError10);

  var _super25 = _createSuper(MongoInvalidArgumentError);

  function MongoInvalidArgumentError(message) {
    _classCallCheck(this, MongoInvalidArgumentError);

    return _super25.call(this, message);
  }

  _createClass(MongoInvalidArgumentError, [{
    key: "name",
    get: function get() {
      return 'MongoInvalidArgumentError';
    }
  }]);

  return MongoInvalidArgumentError;
}(MongoAPIError);

exports.MongoInvalidArgumentError = MongoInvalidArgumentError;
/**
 * An error generated when a feature that is not enabled or allowed for the current server
 * configuration is used
 *
 *
 * @public
 * @category Error
 */

var MongoCompatibilityError = /*#__PURE__*/function (_MongoAPIError11) {
  _inherits(MongoCompatibilityError, _MongoAPIError11);

  var _super26 = _createSuper(MongoCompatibilityError);

  function MongoCompatibilityError(message) {
    _classCallCheck(this, MongoCompatibilityError);

    return _super26.call(this, message);
  }

  _createClass(MongoCompatibilityError, [{
    key: "name",
    get: function get() {
      return 'MongoCompatibilityError';
    }
  }]);

  return MongoCompatibilityError;
}(MongoAPIError);

exports.MongoCompatibilityError = MongoCompatibilityError;
/**
 * An error generated when the user fails to provide authentication credentials before attempting
 * to connect to a mongo server instance.
 *
 *
 * @public
 * @category Error
 */

var MongoMissingCredentialsError = /*#__PURE__*/function (_MongoAPIError12) {
  _inherits(MongoMissingCredentialsError, _MongoAPIError12);

  var _super27 = _createSuper(MongoMissingCredentialsError);

  function MongoMissingCredentialsError(message) {
    _classCallCheck(this, MongoMissingCredentialsError);

    return _super27.call(this, message);
  }

  _createClass(MongoMissingCredentialsError, [{
    key: "name",
    get: function get() {
      return 'MongoMissingCredentialsError';
    }
  }]);

  return MongoMissingCredentialsError;
}(MongoAPIError);

exports.MongoMissingCredentialsError = MongoMissingCredentialsError;
/**
 * An error generated when a required module or dependency is not present in the local environment
 *
 * @public
 * @category Error
 */

var MongoMissingDependencyError = /*#__PURE__*/function (_MongoAPIError13) {
  _inherits(MongoMissingDependencyError, _MongoAPIError13);

  var _super28 = _createSuper(MongoMissingDependencyError);

  function MongoMissingDependencyError(message) {
    _classCallCheck(this, MongoMissingDependencyError);

    return _super28.call(this, message);
  }

  _createClass(MongoMissingDependencyError, [{
    key: "name",
    get: function get() {
      return 'MongoMissingDependencyError';
    }
  }]);

  return MongoMissingDependencyError;
}(MongoAPIError);

exports.MongoMissingDependencyError = MongoMissingDependencyError;
/**
 * An error signifying a general system issue
 * @public
 * @category Error
 */

var MongoSystemError = /*#__PURE__*/function (_MongoError4) {
  _inherits(MongoSystemError, _MongoError4);

  var _super29 = _createSuper(MongoSystemError);

  function MongoSystemError(message, reason) {
    var _this4;

    _classCallCheck(this, MongoSystemError);

    var _a;

    if (reason && reason.error) {
      _this4 = _super29.call(this, reason.error.message || reason.error);
    } else {
      _this4 = _super29.call(this, message);
    }

    if (reason) {
      _this4.reason = reason;
    }

    _this4.code = (_a = reason.error) === null || _a === void 0 ? void 0 : _a.code;
    return _possibleConstructorReturn(_this4);
  }

  _createClass(MongoSystemError, [{
    key: "name",
    get: function get() {
      return 'MongoSystemError';
    }
  }]);

  return MongoSystemError;
}(MongoError);

exports.MongoSystemError = MongoSystemError;
/**
 * An error signifying a client-side server selection error
 * @public
 * @category Error
 */

var MongoServerSelectionError = /*#__PURE__*/function (_MongoSystemError) {
  _inherits(MongoServerSelectionError, _MongoSystemError);

  var _super30 = _createSuper(MongoServerSelectionError);

  function MongoServerSelectionError(message, reason) {
    _classCallCheck(this, MongoServerSelectionError);

    return _super30.call(this, message, reason);
  }

  _createClass(MongoServerSelectionError, [{
    key: "name",
    get: function get() {
      return 'MongoServerSelectionError';
    }
  }]);

  return MongoServerSelectionError;
}(MongoSystemError);

exports.MongoServerSelectionError = MongoServerSelectionError;

function makeWriteConcernResultObject(input) {
  var output = Object.assign({}, input);

  if (output.ok === 0) {
    output.ok = 1;
    delete output.errmsg;
    delete output.code;
    delete output.codeName;
  }

  return output;
}
/**
 * An error thrown when the server reports a writeConcernError
 * @public
 * @category Error
 */


var MongoWriteConcernError = /*#__PURE__*/function (_MongoServerError) {
  _inherits(MongoWriteConcernError, _MongoServerError);

  var _super31 = _createSuper(MongoWriteConcernError);

  function MongoWriteConcernError(message, result) {
    var _this5;

    _classCallCheck(this, MongoWriteConcernError);

    if (result && Array.isArray(result.errorLabels)) {
      message.errorLabels = result.errorLabels;
    }

    _this5 = _super31.call(this, message);
    _this5.errInfo = message.errInfo;

    if (result != null) {
      _this5.result = makeWriteConcernResultObject(result);
    }

    return _this5;
  }

  _createClass(MongoWriteConcernError, [{
    key: "name",
    get: function get() {
      return 'MongoWriteConcernError';
    }
  }]);

  return MongoWriteConcernError;
}(MongoServerError);

exports.MongoWriteConcernError = MongoWriteConcernError; // https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.rst#retryable-error

var RETRYABLE_READ_ERROR_CODES = new Set([exports.MONGODB_ERROR_CODES.HostUnreachable, exports.MONGODB_ERROR_CODES.HostNotFound, exports.MONGODB_ERROR_CODES.NetworkTimeout, exports.MONGODB_ERROR_CODES.ShutdownInProgress, exports.MONGODB_ERROR_CODES.PrimarySteppedDown, exports.MONGODB_ERROR_CODES.SocketException, exports.MONGODB_ERROR_CODES.NotWritablePrimary, exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange, exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk, exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary]); // see: https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.rst#terms

var RETRYABLE_WRITE_ERROR_CODES = new Set([].concat(_toConsumableArray(RETRYABLE_READ_ERROR_CODES), [exports.MONGODB_ERROR_CODES.ExceededTimeLimit]));

function needsRetryableWriteLabel(error, maxWireVersion) {
  var _a, _b, _c; // pre-4.4 server, then the driver adds an error label for every valid case
  // execute operation will only inspect the label, code/message logic is handled here


  if (error instanceof MongoNetworkError) {
    return true;
  }

  if (error instanceof MongoError) {
    if ((maxWireVersion >= 9 || error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError)) && !error.hasErrorLabel(exports.MongoErrorLabel.HandshakeError)) {
      // If we already have the error label no need to add it again. 4.4+ servers add the label.
      // In the case where we have a handshake error, need to fall down to the logic checking
      // the codes.
      return false;
    }
  }

  if (error instanceof MongoWriteConcernError) {
    return RETRYABLE_WRITE_ERROR_CODES.has((_c = (_b = (_a = error.result) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : error.code) !== null && _c !== void 0 ? _c : 0);
  }

  if (error instanceof MongoError && typeof error.code === 'number') {
    return RETRYABLE_WRITE_ERROR_CODES.has(error.code);
  }

  var isNotWritablePrimaryError = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);

  if (isNotWritablePrimaryError) {
    return true;
  }

  var isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);

  if (isNodeIsRecoveringError) {
    return true;
  }

  return false;
}

exports.needsRetryableWriteLabel = needsRetryableWriteLabel;

function isRetryableWriteError(error) {
  return error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError);
}

exports.isRetryableWriteError = isRetryableWriteError;
/** Determines whether an error is something the driver should attempt to retry */

function isRetryableReadError(error) {
  var hasRetryableErrorCode = typeof error.code === 'number' ? RETRYABLE_READ_ERROR_CODES.has(error.code) : false;

  if (hasRetryableErrorCode) {
    return true;
  }

  if (error instanceof MongoNetworkError) {
    return true;
  }

  var isNotWritablePrimaryError = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);

  if (isNotWritablePrimaryError) {
    return true;
  }

  var isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);

  if (isNodeIsRecoveringError) {
    return true;
  }

  return false;
}

exports.isRetryableReadError = isRetryableReadError;
var SDAM_RECOVERING_CODES = new Set([exports.MONGODB_ERROR_CODES.ShutdownInProgress, exports.MONGODB_ERROR_CODES.PrimarySteppedDown, exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange, exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary]);
var SDAM_NOT_PRIMARY_CODES = new Set([exports.MONGODB_ERROR_CODES.NotWritablePrimary, exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk, exports.MONGODB_ERROR_CODES.LegacyNotPrimary]);
var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.ShutdownInProgress]);

function isRecoveringError(err) {
  if (typeof err.code === 'number') {
    // If any error code exists, we ignore the error.message
    return SDAM_RECOVERING_CODES.has(err.code);
  }

  return exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) || exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message);
}

function isNotWritablePrimaryError(err) {
  if (typeof err.code === 'number') {
    // If any error code exists, we ignore the error.message
    return SDAM_NOT_PRIMARY_CODES.has(err.code);
  }

  if (isRecoveringError(err)) {
    return false;
  }

  return exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
}

function isNodeShuttingDownError(err) {
  return !!(typeof err.code === 'number' && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
}

exports.isNodeShuttingDownError = isNodeShuttingDownError;
/**
 * Determines whether SDAM can recover from a given error. If it cannot
 * then the pool will be cleared, and server state will completely reset
 * locally.
 *
 * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-master-and-node-is-recovering
 */

function isSDAMUnrecoverableError(error) {
  // NOTE: null check is here for a strictly pre-CMAP world, a timeout or
  //       close event are considered unrecoverable
  if (error instanceof MongoParseError || error == null) {
    return true;
  }

  return isRecoveringError(error) || isNotWritablePrimaryError(error);
}

exports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;

function isNetworkTimeoutError(err) {
  return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
}

exports.isNetworkTimeoutError = isNetworkTimeoutError;

function isResumableError(error, wireVersion) {
  if (error == null || !(error instanceof MongoError)) {
    return false;
  }

  if (error instanceof MongoNetworkError) {
    return true;
  }

  if (wireVersion != null && wireVersion >= 9) {
    // DRIVERS-1308: For 4.4 drivers running against 4.4 servers, drivers will add a special case to treat the CursorNotFound error code as resumable
    if (error.code === exports.MONGODB_ERROR_CODES.CursorNotFound) {
      return true;
    }

    return error.hasErrorLabel(exports.MongoErrorLabel.ResumableChangeStreamError);
  }

  if (typeof error.code === 'number') {
    return exports.GET_MORE_RESUMABLE_CODES.has(error.code);
  }

  return false;
}

exports.isResumableError = isResumableError;

/***/ }),

/***/ 3480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Explain = exports.ExplainVerbosity = void 0;

var error_1 = __webpack_require__(9271);
/** @public */


exports.ExplainVerbosity = Object.freeze({
  queryPlanner: 'queryPlanner',
  queryPlannerExtended: 'queryPlannerExtended',
  executionStats: 'executionStats',
  allPlansExecution: 'allPlansExecution'
});
/** @internal */

var Explain = /*#__PURE__*/function () {
  function Explain(verbosity) {
    _classCallCheck(this, Explain);

    if (typeof verbosity === 'boolean') {
      this.verbosity = verbosity ? exports.ExplainVerbosity.allPlansExecution : exports.ExplainVerbosity.queryPlanner;
    } else {
      this.verbosity = verbosity;
    }
  }

  _createClass(Explain, null, [{
    key: "fromOptions",
    value: function fromOptions(options) {
      if ((options === null || options === void 0 ? void 0 : options.explain) == null) return;
      var explain = options.explain;

      if (typeof explain === 'boolean' || typeof explain === 'string') {
        return new Explain(explain);
      }

      throw new error_1.MongoInvalidArgumentError('Field "explain" must be a string or a boolean');
    }
  }]);

  return Explain;
}();

exports.Explain = Explain;

/***/ }),

/***/ 5313:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GridFSBucketReadStream = void 0;

var stream_1 = __webpack_require__(2781);

var error_1 = __webpack_require__(9271);
/**
 * A readable stream that enables you to read buffers from GridFS.
 *
 * Do not instantiate this class directly. Use `openDownloadStream()` instead.
 * @public
 */


var GridFSBucketReadStream = /*#__PURE__*/function (_stream_1$Readable) {
  _inherits(GridFSBucketReadStream, _stream_1$Readable);

  var _super = _createSuper(GridFSBucketReadStream);

  /** @internal
   * @param chunks - Handle for chunks collection
   * @param files - Handle for files collection
   * @param readPreference - The read preference to use
   * @param filter - The filter to use to find the file document
   */
  function GridFSBucketReadStream(chunks, files, readPreference, filter, options) {
    var _this;

    _classCallCheck(this, GridFSBucketReadStream);

    _this = _super.call(this);
    _this.s = {
      bytesToTrim: 0,
      bytesToSkip: 0,
      bytesRead: 0,
      chunks: chunks,
      expected: 0,
      files: files,
      filter: filter,
      init: false,
      expectedEnd: 0,
      options: _objectSpread({
        start: 0,
        end: 0
      }, options),
      readPreference: readPreference
    };
    return _this;
  }
  /**
   * Reads from the cursor and pushes to the stream.
   * Private Impl, do not call directly
   * @internal
   */


  _createClass(GridFSBucketReadStream, [{
    key: "_read",
    value: function _read() {
      var _this2 = this;

      if (this.destroyed) return;
      waitForFile(this, function () {
        return doRead(_this2);
      });
    }
    /**
     * Sets the 0-based offset in bytes to start streaming from. Throws
     * an error if this stream has entered flowing mode
     * (e.g. if you've already called `on('data')`)
     *
     * @param start - 0-based offset in bytes to start streaming from
     */

  }, {
    key: "start",
    value: function start() {
      var _start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      throwIfInitialized(this);
      this.s.options.start = _start;
      return this;
    }
    /**
     * Sets the 0-based offset in bytes to start streaming from. Throws
     * an error if this stream has entered flowing mode
     * (e.g. if you've already called `on('data')`)
     *
     * @param end - Offset in bytes to stop reading at
     */

  }, {
    key: "end",
    value: function end() {
      var _end = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      throwIfInitialized(this);
      this.s.options.end = _end;
      return this;
    }
    /**
     * Marks this stream as aborted (will never push another `data` event)
     * and kills the underlying cursor. Will emit the 'end' event, and then
     * the 'close' event once the cursor is successfully killed.
     *
     * @param callback - called when the cursor is successfully closed or an error occurred.
     */

  }, {
    key: "abort",
    value: function abort(callback) {
      var _this3 = this;

      this.push(null);
      this.destroyed = true;

      if (this.s.cursor) {
        this.s.cursor.close(function (error) {
          _this3.emit(GridFSBucketReadStream.CLOSE);

          callback && callback(error);
        });
      } else {
        if (!this.s.init) {
          // If not initialized, fire close event because we will never
          // get a cursor
          this.emit(GridFSBucketReadStream.CLOSE);
        }

        callback && callback();
      }
    }
  }]);

  return GridFSBucketReadStream;
}(stream_1.Readable);

exports.GridFSBucketReadStream = GridFSBucketReadStream;
/**
 * An error occurred
 * @event
 */

GridFSBucketReadStream.ERROR = 'error';
/**
 * Fires when the stream loaded the file document corresponding to the provided id.
 * @event
 */

GridFSBucketReadStream.FILE = 'file';
/**
 * Emitted when a chunk of data is available to be consumed.
 * @event
 */

GridFSBucketReadStream.DATA = 'data';
/**
 * Fired when the stream is exhausted (no more data events).
 * @event
 */

GridFSBucketReadStream.END = 'end';
/**
 * Fired when the stream is exhausted and the underlying cursor is killed
 * @event
 */

GridFSBucketReadStream.CLOSE = 'close';

function throwIfInitialized(stream) {
  if (stream.s.init) {
    throw new error_1.MongoGridFSStreamError('Options cannot be changed after the stream is initialized');
  }
}

function doRead(stream) {
  if (stream.destroyed) return;
  if (!stream.s.cursor) return;
  if (!stream.s.file) return;
  stream.s.cursor.next(function (error, doc) {
    if (stream.destroyed) {
      return;
    }

    if (error) {
      stream.emit(GridFSBucketReadStream.ERROR, error);
      return;
    }

    if (!doc) {
      stream.push(null);
      process.nextTick(function () {
        if (!stream.s.cursor) return;
        stream.s.cursor.close(function (error) {
          if (error) {
            stream.emit(GridFSBucketReadStream.ERROR, error);
            return;
          }

          stream.emit(GridFSBucketReadStream.CLOSE);
        });
      });
      return;
    }

    if (!stream.s.file) return;
    var bytesRemaining = stream.s.file.length - stream.s.bytesRead;
    var expectedN = stream.s.expected++;
    var expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);

    if (doc.n > expectedN) {
      return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError("ChunkIsMissing: Got unexpected n: ".concat(doc.n, ", expected: ").concat(expectedN)));
    }

    if (doc.n < expectedN) {
      return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError("ExtraChunk: Got unexpected n: ".concat(doc.n, ", expected: ").concat(expectedN)));
    }

    var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;

    if (buf.byteLength !== expectedLength) {
      if (bytesRemaining <= 0) {
        return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError("ExtraChunk: Got unexpected n: ".concat(doc.n, ", expected file length ").concat(stream.s.file.length, " bytes but already read ").concat(stream.s.bytesRead, " bytes")));
      }

      return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError("ChunkIsWrongSize: Got unexpected length: ".concat(buf.byteLength, ", expected: ").concat(expectedLength)));
    }

    stream.s.bytesRead += buf.byteLength;

    if (buf.byteLength === 0) {
      return stream.push(null);
    }

    var sliceStart = null;
    var sliceEnd = null;

    if (stream.s.bytesToSkip != null) {
      sliceStart = stream.s.bytesToSkip;
      stream.s.bytesToSkip = 0;
    }

    var atEndOfStream = expectedN === stream.s.expectedEnd - 1;
    var bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;

    if (atEndOfStream && stream.s.bytesToTrim != null) {
      sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;
    } else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {
      sliceEnd = bytesLeftToRead;
    }

    if (sliceStart != null || sliceEnd != null) {
      buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
    }

    stream.push(buf);
    return;
  });
}

function init(stream) {
  var findOneOptions = {};

  if (stream.s.readPreference) {
    findOneOptions.readPreference = stream.s.readPreference;
  }

  if (stream.s.options && stream.s.options.sort) {
    findOneOptions.sort = stream.s.options.sort;
  }

  if (stream.s.options && stream.s.options.skip) {
    findOneOptions.skip = stream.s.options.skip;
  }

  stream.s.files.findOne(stream.s.filter, findOneOptions, function (error, doc) {
    if (error) {
      return stream.emit(GridFSBucketReadStream.ERROR, error);
    }

    if (!doc) {
      var identifier = stream.s.filter._id ? stream.s.filter._id.toString() : stream.s.filter.filename;
      var errmsg = "FileNotFound: file ".concat(identifier, " was not found"); // TODO(NODE-3483)

      var err = new error_1.MongoRuntimeError(errmsg);
      err.code = 'ENOENT'; // TODO: NODE-3338 set property as part of constructor

      return stream.emit(GridFSBucketReadStream.ERROR, err);
    } // If document is empty, kill the stream immediately and don't
    // execute any reads


    if (doc.length <= 0) {
      stream.push(null);
      return;
    }

    if (stream.destroyed) {
      // If user destroys the stream before we have a cursor, wait
      // until the query is done to say we're 'closed' because we can't
      // cancel a query.
      stream.emit(GridFSBucketReadStream.CLOSE);
      return;
    }

    try {
      stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);
    } catch (error) {
      return stream.emit(GridFSBucketReadStream.ERROR, error);
    }

    var filter = {
      files_id: doc._id
    }; // Currently (MongoDB 3.4.4) skip function does not support the index,
    // it needs to retrieve all the documents first and then skip them. (CS-25811)
    // As work around we use $gte on the "n" field.

    if (stream.s.options && stream.s.options.start != null) {
      var skip = Math.floor(stream.s.options.start / doc.chunkSize);

      if (skip > 0) {
        filter['n'] = {
          $gte: skip
        };
      }
    }

    stream.s.cursor = stream.s.chunks.find(filter).sort({
      n: 1
    });

    if (stream.s.readPreference) {
      stream.s.cursor.withReadPreference(stream.s.readPreference);
    }

    stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
    stream.s.file = doc;

    try {
      stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);
    } catch (error) {
      return stream.emit(GridFSBucketReadStream.ERROR, error);
    }

    stream.emit(GridFSBucketReadStream.FILE, doc);
    return;
  });
}

function waitForFile(stream, callback) {
  if (stream.s.file) {
    return callback();
  }

  if (!stream.s.init) {
    init(stream);
    stream.s.init = true;
  }

  stream.once('file', function () {
    callback();
  });
}

function handleStartOption(stream, doc, options) {
  if (options && options.start != null) {
    if (options.start > doc.length) {
      throw new error_1.MongoInvalidArgumentError("Stream start (".concat(options.start, ") must not be more than the length of the file (").concat(doc.length, ")"));
    }

    if (options.start < 0) {
      throw new error_1.MongoInvalidArgumentError("Stream start (".concat(options.start, ") must not be negative"));
    }

    if (options.end != null && options.end < options.start) {
      throw new error_1.MongoInvalidArgumentError("Stream start (".concat(options.start, ") must not be greater than stream end (").concat(options.end, ")"));
    }

    stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
    stream.s.expected = Math.floor(options.start / doc.chunkSize);
    return options.start - stream.s.bytesRead;
  }

  throw new error_1.MongoInvalidArgumentError('Start option must be defined');
}

function handleEndOption(stream, doc, cursor, options) {
  if (options && options.end != null) {
    if (options.end > doc.length) {
      throw new error_1.MongoInvalidArgumentError("Stream end (".concat(options.end, ") must not be more than the length of the file (").concat(doc.length, ")"));
    }

    if (options.start == null || options.start < 0) {
      throw new error_1.MongoInvalidArgumentError("Stream end (".concat(options.end, ") must not be negative"));
    }

    var start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
    cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
    stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
    return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
  }

  throw new error_1.MongoInvalidArgumentError('End option must be defined');
}

/***/ }),

/***/ 4406:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GridFSBucket = void 0;

var error_1 = __webpack_require__(9271);

var mongo_types_1 = __webpack_require__(3738);

var utils_1 = __webpack_require__(4356);

var write_concern_1 = __webpack_require__(1473);

var download_1 = __webpack_require__(5313);

var upload_1 = __webpack_require__(8039);

var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
  bucketName: 'fs',
  chunkSizeBytes: 255 * 1024
};
/**
 * Constructor for a streaming GridFS interface
 * @public
 */

var GridFSBucket = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(GridFSBucket, _mongo_types_1$TypedE);

  var _super = _createSuper(GridFSBucket);

  function GridFSBucket(db, options) {
    var _this;

    _classCallCheck(this, GridFSBucket);

    _this = _super.call(this);

    _this.setMaxListeners(0);

    var privateOptions = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_GRIDFS_BUCKET_OPTIONS), options), {}, {
      writeConcern: write_concern_1.WriteConcern.fromOptions(options)
    });

    _this.s = {
      db: db,
      options: privateOptions,
      _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),
      _filesCollection: db.collection(privateOptions.bucketName + '.files'),
      checkedIndexes: false,
      calledOpenUploadStream: false
    };
    return _this;
  }
  /**
   * Returns a writable stream (GridFSBucketWriteStream) for writing
   * buffers to GridFS. The stream's 'id' property contains the resulting
   * file's id.
   *
   * @param filename - The value of the 'filename' key in the files doc
   * @param options - Optional settings.
   */


  _createClass(GridFSBucket, [{
    key: "openUploadStream",
    value: function openUploadStream(filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, options);
    }
    /**
     * Returns a writable stream (GridFSBucketWriteStream) for writing
     * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting
     * file's id.
     */

  }, {
    key: "openUploadStreamWithId",
    value: function openUploadStreamWithId(id, filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, _objectSpread(_objectSpread({}, options), {}, {
        id: id
      }));
    }
    /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */

  }, {
    key: "openDownloadStream",
    value: function openDownloadStream(id, options) {
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {
        _id: id
      }, options);
    }
  }, {
    key: "delete",
    value: function _delete(id, callback) {
      var _this2 = this;

      return (0, utils_1.maybePromise)(callback, function (callback) {
        return _this2.s._filesCollection.deleteOne({
          _id: id
        }, function (error, res) {
          if (error) {
            return callback(error);
          }

          return _this2.s._chunksCollection.deleteMany({
            files_id: id
          }, function (error) {
            if (error) {
              return callback(error);
            } // Delete orphaned chunks before returning FileNotFound


            if (!(res === null || res === void 0 ? void 0 : res.deletedCount)) {
              // TODO(NODE-3483): Replace with more appropriate error
              // Consider creating new error MongoGridFSFileNotFoundError
              return callback(new error_1.MongoRuntimeError("File not found for id ".concat(id)));
            }

            return callback();
          });
        });
      });
    }
    /** Convenience wrapper around find on the files collection */

  }, {
    key: "find",
    value: function find(filter, options) {
      filter !== null && filter !== void 0 ? filter : filter = {};
      options = options !== null && options !== void 0 ? options : {};
      return this.s._filesCollection.find(filter, options);
    }
    /**
     * Returns a readable stream (GridFSBucketReadStream) for streaming the
     * file with the given name from GridFS. If there are multiple files with
     * the same name, this will stream the most recent file with the given name
     * (as determined by the `uploadDate` field). You can set the `revision`
     * option to change this behavior.
     */

  }, {
    key: "openDownloadStreamByName",
    value: function openDownloadStreamByName(filename, options) {
      var sort = {
        uploadDate: -1
      };
      var skip = undefined;

      if (options && options.revision != null) {
        if (options.revision >= 0) {
          sort = {
            uploadDate: 1
          };
          skip = options.revision;
        } else {
          skip = -options.revision - 1;
        }
      }

      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {
        filename: filename
      }, _objectSpread(_objectSpread({}, options), {}, {
        sort: sort,
        skip: skip
      }));
    }
  }, {
    key: "rename",
    value: function rename(id, filename, callback) {
      var _this3 = this;

      return (0, utils_1.maybePromise)(callback, function (callback) {
        var filter = {
          _id: id
        };
        var update = {
          $set: {
            filename: filename
          }
        };
        return _this3.s._filesCollection.updateOne(filter, update, function (error, res) {
          if (error) {
            return callback(error);
          }

          if (!(res === null || res === void 0 ? void 0 : res.matchedCount)) {
            return callback(new error_1.MongoRuntimeError("File with id ".concat(id, " not found")));
          }

          return callback();
        });
      });
    }
  }, {
    key: "drop",
    value: function drop(callback) {
      var _this4 = this;

      return (0, utils_1.maybePromise)(callback, function (callback) {
        return _this4.s._filesCollection.drop(function (error) {
          if (error) {
            return callback(error);
          }

          return _this4.s._chunksCollection.drop(function (error) {
            if (error) {
              return callback(error);
            }

            return callback();
          });
        });
      });
    }
    /** Get the Db scoped logger. */

  }, {
    key: "getLogger",
    value: function getLogger() {
      return this.s.db.s.logger;
    }
  }]);

  return GridFSBucket;
}(mongo_types_1.TypedEventEmitter);

exports.GridFSBucket = GridFSBucket;
/**
 * When the first call to openUploadStream is made, the upload stream will
 * check to see if it needs to create the proper indexes on the chunks and
 * files collections. This event is fired either when 1) it determines that
 * no index creation is necessary, 2) when it successfully creates the
 * necessary indexes.
 * @event
 */

GridFSBucket.INDEX = 'index';

/***/ }),

/***/ 8039:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GridFSBucketWriteStream = void 0;

var stream_1 = __webpack_require__(2781);

var bson_1 = __webpack_require__(53);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var write_concern_1 = __webpack_require__(1473);
/**
 * A writable stream that enables you to write buffers to GridFS.
 *
 * Do not instantiate this class directly. Use `openUploadStream()` instead.
 * @public
 */


var GridFSBucketWriteStream = /*#__PURE__*/function (_stream_1$Writable) {
  _inherits(GridFSBucketWriteStream, _stream_1$Writable);

  var _super = _createSuper(GridFSBucketWriteStream);

  /** @internal
   * @param bucket - Handle for this stream's corresponding bucket
   * @param filename - The value of the 'filename' key in the files doc
   * @param options - Optional settings.
   */
  function GridFSBucketWriteStream(bucket, filename, options) {
    var _this;

    _classCallCheck(this, GridFSBucketWriteStream);

    _this = _super.call(this);
    options = options !== null && options !== void 0 ? options : {};
    _this.bucket = bucket;
    _this.chunks = bucket.s._chunksCollection;
    _this.filename = filename;
    _this.files = bucket.s._filesCollection;
    _this.options = options;
    _this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern; // Signals the write is all done

    _this.done = false;
    _this.id = options.id ? options.id : new bson_1.ObjectId(); // properly inherit the default chunksize from parent

    _this.chunkSizeBytes = options.chunkSizeBytes || _this.bucket.s.options.chunkSizeBytes;
    _this.bufToStore = Buffer.alloc(_this.chunkSizeBytes);
    _this.length = 0;
    _this.n = 0;
    _this.pos = 0;
    _this.state = {
      streamEnd: false,
      outstandingRequests: 0,
      errored: false,
      aborted: false
    };

    if (!_this.bucket.s.calledOpenUploadStream) {
      _this.bucket.s.calledOpenUploadStream = true;
      checkIndexes(_assertThisInitialized(_this), function () {
        _this.bucket.s.checkedIndexes = true;

        _this.bucket.emit('index');
      });
    }

    return _this;
  }

  _createClass(GridFSBucketWriteStream, [{
    key: "write",
    value: function write(chunk, encodingOrCallback, callback) {
      var _this2 = this;

      var encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;
      callback = typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;
      return waitForIndexes(this, function () {
        return doWrite(_this2, chunk, encoding, callback);
      });
    }
  }, {
    key: "abort",
    value: function abort(callback) {
      var _this3 = this;

      return (0, utils_1.maybePromise)(callback, function (callback) {
        if (_this3.state.streamEnd) {
          // TODO(NODE-3485): Replace with MongoGridFSStreamClosed
          return callback(new error_1.MongoAPIError('Cannot abort a stream that has already completed'));
        }

        if (_this3.state.aborted) {
          // TODO(NODE-3485): Replace with MongoGridFSStreamClosed
          return callback(new error_1.MongoAPIError('Cannot call abort() on a stream twice'));
        }

        _this3.state.aborted = true;

        _this3.chunks.deleteMany({
          files_id: _this3.id
        }, function (error) {
          return callback(error);
        });
      });
    }
  }, {
    key: "end",
    value: function end(chunkOrCallback, encodingOrCallback, callback) {
      var _this4 = this;

      var chunk = typeof chunkOrCallback === 'function' ? undefined : chunkOrCallback;
      var encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;
      callback = typeof chunkOrCallback === 'function' ? chunkOrCallback : typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;
      if (this.state.streamEnd || checkAborted(this, callback)) return this;
      this.state.streamEnd = true;

      if (callback) {
        this.once(GridFSBucketWriteStream.FINISH, function (result) {
          if (callback) callback(undefined, result);
        });
      }

      if (!chunk) {
        waitForIndexes(this, function () {
          return !!writeRemnant(_this4);
        });
        return this;
      }

      this.write(chunk, encoding, function () {
        writeRemnant(_this4);
      });
      return this;
    }
  }]);

  return GridFSBucketWriteStream;
}(stream_1.Writable);

exports.GridFSBucketWriteStream = GridFSBucketWriteStream;
/** @event */

GridFSBucketWriteStream.CLOSE = 'close';
/** @event */

GridFSBucketWriteStream.ERROR = 'error';
/**
 * `end()` was called and the write stream successfully wrote the file metadata and all the chunks to MongoDB.
 * @event
 */

GridFSBucketWriteStream.FINISH = 'finish';

function __handleError(stream, error, callback) {
  if (stream.state.errored) {
    return;
  }

  stream.state.errored = true;

  if (callback) {
    return callback(error);
  }

  stream.emit(GridFSBucketWriteStream.ERROR, error);
}

function createChunkDoc(filesId, n, data) {
  return {
    _id: new bson_1.ObjectId(),
    files_id: filesId,
    n: n,
    data: data
  };
}

function checkChunksIndex(stream, callback) {
  stream.chunks.listIndexes().toArray(function (error, indexes) {
    var index;

    if (error) {
      // Collection doesn't exist so create index
      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
        index = {
          files_id: 1,
          n: 1
        };
        stream.chunks.createIndex(index, {
          background: false,
          unique: true
        }, function (error) {
          if (error) {
            return callback(error);
          }

          callback();
        });
        return;
      }

      return callback(error);
    }

    var hasChunksIndex = false;

    if (indexes) {
      indexes.forEach(function (index) {
        if (index.key) {
          var keys = Object.keys(index.key);

          if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {
            hasChunksIndex = true;
          }
        }
      });
    }

    if (hasChunksIndex) {
      callback();
    } else {
      index = {
        files_id: 1,
        n: 1
      };
      var writeConcernOptions = getWriteOptions(stream);
      stream.chunks.createIndex(index, _objectSpread(_objectSpread({}, writeConcernOptions), {}, {
        background: true,
        unique: true
      }), callback);
    }
  });
}

function checkDone(stream, callback) {
  if (stream.done) return true;

  if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {
    // Set done so we do not trigger duplicate createFilesDoc
    stream.done = true; // Create a new files doc

    var filesDoc = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);

    if (checkAborted(stream, callback)) {
      return false;
    }

    stream.files.insertOne(filesDoc, getWriteOptions(stream), function (error) {
      if (error) {
        return __handleError(stream, error, callback);
      }

      stream.emit(GridFSBucketWriteStream.FINISH, filesDoc);
      stream.emit(GridFSBucketWriteStream.CLOSE);
    });
    return true;
  }

  return false;
}

function checkIndexes(stream, callback) {
  stream.files.findOne({}, {
    projection: {
      _id: 1
    }
  }, function (error, doc) {
    if (error) {
      return callback(error);
    }

    if (doc) {
      return callback();
    }

    stream.files.listIndexes().toArray(function (error, indexes) {
      var index;

      if (error) {
        // Collection doesn't exist so create index
        if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
          index = {
            filename: 1,
            uploadDate: 1
          };
          stream.files.createIndex(index, {
            background: false
          }, function (error) {
            if (error) {
              return callback(error);
            }

            checkChunksIndex(stream, callback);
          });
          return;
        }

        return callback(error);
      }

      var hasFileIndex = false;

      if (indexes) {
        indexes.forEach(function (index) {
          var keys = Object.keys(index.key);

          if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {
            hasFileIndex = true;
          }
        });
      }

      if (hasFileIndex) {
        checkChunksIndex(stream, callback);
      } else {
        index = {
          filename: 1,
          uploadDate: 1
        };
        var writeConcernOptions = getWriteOptions(stream);
        stream.files.createIndex(index, _objectSpread(_objectSpread({}, writeConcernOptions), {}, {
          background: false
        }), function (error) {
          if (error) {
            return callback(error);
          }

          checkChunksIndex(stream, callback);
        });
      }
    });
  });
}

function createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {
  var ret = {
    _id: _id,
    length: length,
    chunkSize: chunkSize,
    uploadDate: new Date(),
    filename: filename
  };

  if (contentType) {
    ret.contentType = contentType;
  }

  if (aliases) {
    ret.aliases = aliases;
  }

  if (metadata) {
    ret.metadata = metadata;
  }

  return ret;
}

function doWrite(stream, chunk, encoding, callback) {
  if (checkAborted(stream, callback)) {
    return false;
  }

  var inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
  stream.length += inputBuf.length; // Input is small enough to fit in our buffer

  if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {
    inputBuf.copy(stream.bufToStore, stream.pos);
    stream.pos += inputBuf.length;
    callback && callback(); // Note that we reverse the typical semantics of write's return value
    // to be compatible with node's `.pipe()` function.
    // True means client can keep writing.

    return true;
  } // Otherwise, buffer is too big for current chunk, so we need to flush
  // to MongoDB.


  var inputBufRemaining = inputBuf.length;
  var spaceRemaining = stream.chunkSizeBytes - stream.pos;
  var numToCopy = Math.min(spaceRemaining, inputBuf.length);
  var outstandingRequests = 0;

  var _loop = function _loop() {
    var inputBufPos = inputBuf.length - inputBufRemaining;
    inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);
    stream.pos += numToCopy;
    spaceRemaining -= numToCopy;
    var doc = void 0;

    if (spaceRemaining === 0) {
      doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));
      ++stream.state.outstandingRequests;
      ++outstandingRequests;

      if (checkAborted(stream, callback)) {
        return {
          v: false
        };
      }

      stream.chunks.insertOne(doc, getWriteOptions(stream), function (error) {
        if (error) {
          return __handleError(stream, error);
        }

        --stream.state.outstandingRequests;
        --outstandingRequests;

        if (!outstandingRequests) {
          stream.emit('drain', doc);
          callback && callback();
          checkDone(stream);
        }
      });
      spaceRemaining = stream.chunkSizeBytes;
      stream.pos = 0;
      ++stream.n;
    }

    inputBufRemaining -= numToCopy;
    numToCopy = Math.min(spaceRemaining, inputBufRemaining);
  };

  while (inputBufRemaining > 0) {
    var _ret = _loop();

    if (_typeof(_ret) === "object") return _ret.v;
  } // Note that we reverse the typical semantics of write's return value
  // to be compatible with node's `.pipe()` function.
  // False means the client should wait for the 'drain' event.


  return false;
}

function getWriteOptions(stream) {
  var obj = {};

  if (stream.writeConcern) {
    obj.writeConcern = {
      w: stream.writeConcern.w,
      wtimeout: stream.writeConcern.wtimeout,
      j: stream.writeConcern.j
    };
  }

  return obj;
}

function waitForIndexes(stream, callback) {
  if (stream.bucket.s.checkedIndexes) {
    return callback(false);
  }

  stream.bucket.once('index', function () {
    callback(true);
  });
  return true;
}

function writeRemnant(stream, callback) {
  // Buffer is empty, so don't bother to insert
  if (stream.pos === 0) {
    return checkDone(stream, callback);
  }

  ++stream.state.outstandingRequests; // Create a new buffer to make sure the buffer isn't bigger than it needs
  // to be.

  var remnant = Buffer.alloc(stream.pos);
  stream.bufToStore.copy(remnant, 0, 0, stream.pos);
  var doc = createChunkDoc(stream.id, stream.n, remnant); // If the stream was aborted, do not write remnant

  if (checkAborted(stream, callback)) {
    return false;
  }

  stream.chunks.insertOne(doc, getWriteOptions(stream), function (error) {
    if (error) {
      return __handleError(stream, error);
    }

    --stream.state.outstandingRequests;
    checkDone(stream);
  });
  return true;
}

function checkAborted(stream, callback) {
  if (stream.state.aborted) {
    if (typeof callback === 'function') {
      // TODO(NODE-3485): Replace with MongoGridFSStreamClosedError
      callback(new error_1.MongoAPIError('Stream has been aborted'));
    }

    return true;
  }

  return false;
}

/***/ }),

/***/ 4515:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AbstractCursor = exports.MongoWriteConcernError = exports.MongoUnexpectedServerResponseError = exports.MongoTransactionError = exports.MongoTopologyClosedError = exports.MongoTailableCursorError = exports.MongoSystemError = exports.MongoServerSelectionError = exports.MongoServerError = exports.MongoServerClosedError = exports.MongoRuntimeError = exports.MongoParseError = exports.MongoNotConnectedError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoKerberosError = exports.MongoInvalidArgumentError = exports.MongoGridFSStreamError = exports.MongoGridFSChunkError = exports.MongoExpiredSessionError = exports.MongoError = exports.MongoDriverError = exports.MongoDecompressionError = exports.MongoCursorInUseError = exports.MongoCursorExhaustedError = exports.MongoCompatibilityError = exports.MongoChangeStreamError = exports.MongoBatchReExecutionError = exports.MongoAWSError = exports.MongoAPIError = exports.MongoBulkWriteError = exports.ObjectID = exports.ChangeStreamCursor = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Map = exports.Long = exports.Int32 = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONSymbol = exports.BSONRegExp = exports.Binary = exports.BSON = void 0;
exports.ServerHeartbeatFailedEvent = exports.ServerDescriptionChangedEvent = exports.ServerClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionPoolMonitoringEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolClearedEvent = exports.ConnectionCreatedEvent = exports.ConnectionClosedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckedInEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = exports.CommandFailedEvent = exports.WriteConcern = exports.ReadPreference = exports.ReadConcern = exports.TopologyType = exports.ServerType = exports.ReadPreferenceMode = exports.ReadConcernLevel = exports.ProfilingLevel = exports.ReturnDocument = exports.BSONType = exports.ServerApiVersion = exports.LoggerLevel = exports.ExplainVerbosity = exports.MongoErrorLabel = exports.AutoEncryptionLoggerLevel = exports.CURSOR_FLAGS = exports.Compressor = exports.AuthMechanism = exports.GSSAPICanonicalizationValue = exports.BatchType = exports.Promise = exports.MongoClient = exports.Logger = exports.ListIndexesCursor = exports.ListCollectionsCursor = exports.GridFSBucket = exports.FindCursor = exports.Db = exports.Collection = exports.ChangeStream = exports.CancellationToken = exports.AggregationCursor = exports.Admin = void 0;
exports.SrvPollingEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.TopologyClosedEvent = exports.ServerOpeningEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = void 0;

var admin_1 = __webpack_require__(2563);

Object.defineProperty(exports, "Admin", ({
  enumerable: true,
  get: function get() {
    return admin_1.Admin;
  }
}));

var bson_1 = __webpack_require__(53);

var change_stream_1 = __webpack_require__(4672);

Object.defineProperty(exports, "ChangeStream", ({
  enumerable: true,
  get: function get() {
    return change_stream_1.ChangeStream;
  }
}));

var collection_1 = __webpack_require__(9730);

Object.defineProperty(exports, "Collection", ({
  enumerable: true,
  get: function get() {
    return collection_1.Collection;
  }
}));

var abstract_cursor_1 = __webpack_require__(3822);

Object.defineProperty(exports, "AbstractCursor", ({
  enumerable: true,
  get: function get() {
    return abstract_cursor_1.AbstractCursor;
  }
}));

var aggregation_cursor_1 = __webpack_require__(5983);

Object.defineProperty(exports, "AggregationCursor", ({
  enumerable: true,
  get: function get() {
    return aggregation_cursor_1.AggregationCursor;
  }
}));

var find_cursor_1 = __webpack_require__(1284);

Object.defineProperty(exports, "FindCursor", ({
  enumerable: true,
  get: function get() {
    return find_cursor_1.FindCursor;
  }
}));

var list_collections_cursor_1 = __webpack_require__(7940);

Object.defineProperty(exports, "ListCollectionsCursor", ({
  enumerable: true,
  get: function get() {
    return list_collections_cursor_1.ListCollectionsCursor;
  }
}));

var list_indexes_cursor_1 = __webpack_require__(668);

Object.defineProperty(exports, "ListIndexesCursor", ({
  enumerable: true,
  get: function get() {
    return list_indexes_cursor_1.ListIndexesCursor;
  }
}));

var db_1 = __webpack_require__(9828);

Object.defineProperty(exports, "Db", ({
  enumerable: true,
  get: function get() {
    return db_1.Db;
  }
}));

var gridfs_1 = __webpack_require__(4406);

Object.defineProperty(exports, "GridFSBucket", ({
  enumerable: true,
  get: function get() {
    return gridfs_1.GridFSBucket;
  }
}));

var logger_1 = __webpack_require__(295);

Object.defineProperty(exports, "Logger", ({
  enumerable: true,
  get: function get() {
    return logger_1.Logger;
  }
}));

var mongo_client_1 = __webpack_require__(9635);

Object.defineProperty(exports, "MongoClient", ({
  enumerable: true,
  get: function get() {
    return mongo_client_1.MongoClient;
  }
}));

var mongo_types_1 = __webpack_require__(3738);

Object.defineProperty(exports, "CancellationToken", ({
  enumerable: true,
  get: function get() {
    return mongo_types_1.CancellationToken;
  }
}));

var promise_provider_1 = __webpack_require__(8912);

Object.defineProperty(exports, "Promise", ({
  enumerable: true,
  get: function get() {
    return promise_provider_1.PromiseProvider;
  }
}));
/** @internal */

var bson_2 = __webpack_require__(53);

Object.defineProperty(exports, "BSON", ({
  enumerable: true,
  get: function get() {
    return bson_2.BSON;
  }
}));

var bson_3 = __webpack_require__(53);

Object.defineProperty(exports, "Binary", ({
  enumerable: true,
  get: function get() {
    return bson_3.Binary;
  }
}));
Object.defineProperty(exports, "BSONRegExp", ({
  enumerable: true,
  get: function get() {
    return bson_3.BSONRegExp;
  }
}));
Object.defineProperty(exports, "BSONSymbol", ({
  enumerable: true,
  get: function get() {
    return bson_3.BSONSymbol;
  }
}));
Object.defineProperty(exports, "Code", ({
  enumerable: true,
  get: function get() {
    return bson_3.Code;
  }
}));
Object.defineProperty(exports, "DBRef", ({
  enumerable: true,
  get: function get() {
    return bson_3.DBRef;
  }
}));
Object.defineProperty(exports, "Decimal128", ({
  enumerable: true,
  get: function get() {
    return bson_3.Decimal128;
  }
}));
Object.defineProperty(exports, "Double", ({
  enumerable: true,
  get: function get() {
    return bson_3.Double;
  }
}));
Object.defineProperty(exports, "Int32", ({
  enumerable: true,
  get: function get() {
    return bson_3.Int32;
  }
}));
Object.defineProperty(exports, "Long", ({
  enumerable: true,
  get: function get() {
    return bson_3.Long;
  }
}));
Object.defineProperty(exports, "Map", ({
  enumerable: true,
  get: function get() {
    return bson_3.Map;
  }
}));
Object.defineProperty(exports, "MaxKey", ({
  enumerable: true,
  get: function get() {
    return bson_3.MaxKey;
  }
}));
Object.defineProperty(exports, "MinKey", ({
  enumerable: true,
  get: function get() {
    return bson_3.MinKey;
  }
}));
Object.defineProperty(exports, "ObjectId", ({
  enumerable: true,
  get: function get() {
    return bson_3.ObjectId;
  }
}));
Object.defineProperty(exports, "Timestamp", ({
  enumerable: true,
  get: function get() {
    return bson_3.Timestamp;
  }
}));

var change_stream_cursor_1 = __webpack_require__(1564);

Object.defineProperty(exports, "ChangeStreamCursor", ({
  enumerable: true,
  get: function get() {
    return change_stream_cursor_1.ChangeStreamCursor;
  }
}));
/**
 * @public
 * @deprecated Please use `ObjectId`
 */

exports.ObjectID = bson_1.ObjectId;

var common_1 = __webpack_require__(1447);

Object.defineProperty(exports, "MongoBulkWriteError", ({
  enumerable: true,
  get: function get() {
    return common_1.MongoBulkWriteError;
  }
}));

var error_1 = __webpack_require__(9271);

Object.defineProperty(exports, "MongoAPIError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoAPIError;
  }
}));
Object.defineProperty(exports, "MongoAWSError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoAWSError;
  }
}));
Object.defineProperty(exports, "MongoBatchReExecutionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoBatchReExecutionError;
  }
}));
Object.defineProperty(exports, "MongoChangeStreamError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoChangeStreamError;
  }
}));
Object.defineProperty(exports, "MongoCompatibilityError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoCompatibilityError;
  }
}));
Object.defineProperty(exports, "MongoCursorExhaustedError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoCursorExhaustedError;
  }
}));
Object.defineProperty(exports, "MongoCursorInUseError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoCursorInUseError;
  }
}));
Object.defineProperty(exports, "MongoDecompressionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoDecompressionError;
  }
}));
Object.defineProperty(exports, "MongoDriverError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoDriverError;
  }
}));
Object.defineProperty(exports, "MongoError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoError;
  }
}));
Object.defineProperty(exports, "MongoExpiredSessionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoExpiredSessionError;
  }
}));
Object.defineProperty(exports, "MongoGridFSChunkError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoGridFSChunkError;
  }
}));
Object.defineProperty(exports, "MongoGridFSStreamError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoGridFSStreamError;
  }
}));
Object.defineProperty(exports, "MongoInvalidArgumentError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoInvalidArgumentError;
  }
}));
Object.defineProperty(exports, "MongoKerberosError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoKerberosError;
  }
}));
Object.defineProperty(exports, "MongoMissingCredentialsError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoMissingCredentialsError;
  }
}));
Object.defineProperty(exports, "MongoMissingDependencyError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoMissingDependencyError;
  }
}));
Object.defineProperty(exports, "MongoNetworkError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoNetworkError;
  }
}));
Object.defineProperty(exports, "MongoNetworkTimeoutError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoNetworkTimeoutError;
  }
}));
Object.defineProperty(exports, "MongoNotConnectedError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoNotConnectedError;
  }
}));
Object.defineProperty(exports, "MongoParseError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoParseError;
  }
}));
Object.defineProperty(exports, "MongoRuntimeError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoRuntimeError;
  }
}));
Object.defineProperty(exports, "MongoServerClosedError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoServerClosedError;
  }
}));
Object.defineProperty(exports, "MongoServerError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoServerError;
  }
}));
Object.defineProperty(exports, "MongoServerSelectionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoServerSelectionError;
  }
}));
Object.defineProperty(exports, "MongoSystemError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoSystemError;
  }
}));
Object.defineProperty(exports, "MongoTailableCursorError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoTailableCursorError;
  }
}));
Object.defineProperty(exports, "MongoTopologyClosedError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoTopologyClosedError;
  }
}));
Object.defineProperty(exports, "MongoTransactionError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoTransactionError;
  }
}));
Object.defineProperty(exports, "MongoUnexpectedServerResponseError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoUnexpectedServerResponseError;
  }
}));
Object.defineProperty(exports, "MongoWriteConcernError", ({
  enumerable: true,
  get: function get() {
    return error_1.MongoWriteConcernError;
  }
})); // enums

var common_2 = __webpack_require__(1447);

Object.defineProperty(exports, "BatchType", ({
  enumerable: true,
  get: function get() {
    return common_2.BatchType;
  }
}));

var gssapi_1 = __webpack_require__(8211);

Object.defineProperty(exports, "GSSAPICanonicalizationValue", ({
  enumerable: true,
  get: function get() {
    return gssapi_1.GSSAPICanonicalizationValue;
  }
}));

var providers_1 = __webpack_require__(2581);

Object.defineProperty(exports, "AuthMechanism", ({
  enumerable: true,
  get: function get() {
    return providers_1.AuthMechanism;
  }
}));

var compression_1 = __webpack_require__(2501);

Object.defineProperty(exports, "Compressor", ({
  enumerable: true,
  get: function get() {
    return compression_1.Compressor;
  }
}));

var abstract_cursor_2 = __webpack_require__(3822);

Object.defineProperty(exports, "CURSOR_FLAGS", ({
  enumerable: true,
  get: function get() {
    return abstract_cursor_2.CURSOR_FLAGS;
  }
}));

var deps_1 = __webpack_require__(2524);

Object.defineProperty(exports, "AutoEncryptionLoggerLevel", ({
  enumerable: true,
  get: function get() {
    return deps_1.AutoEncryptionLoggerLevel;
  }
}));

var error_2 = __webpack_require__(9271);

Object.defineProperty(exports, "MongoErrorLabel", ({
  enumerable: true,
  get: function get() {
    return error_2.MongoErrorLabel;
  }
}));

var explain_1 = __webpack_require__(3480);

Object.defineProperty(exports, "ExplainVerbosity", ({
  enumerable: true,
  get: function get() {
    return explain_1.ExplainVerbosity;
  }
}));

var logger_2 = __webpack_require__(295);

Object.defineProperty(exports, "LoggerLevel", ({
  enumerable: true,
  get: function get() {
    return logger_2.LoggerLevel;
  }
}));

var mongo_client_2 = __webpack_require__(9635);

Object.defineProperty(exports, "ServerApiVersion", ({
  enumerable: true,
  get: function get() {
    return mongo_client_2.ServerApiVersion;
  }
}));

var mongo_types_2 = __webpack_require__(3738);

Object.defineProperty(exports, "BSONType", ({
  enumerable: true,
  get: function get() {
    return mongo_types_2.BSONType;
  }
}));

var find_and_modify_1 = __webpack_require__(2016);

Object.defineProperty(exports, "ReturnDocument", ({
  enumerable: true,
  get: function get() {
    return find_and_modify_1.ReturnDocument;
  }
}));

var set_profiling_level_1 = __webpack_require__(7230);

Object.defineProperty(exports, "ProfilingLevel", ({
  enumerable: true,
  get: function get() {
    return set_profiling_level_1.ProfilingLevel;
  }
}));

var read_concern_1 = __webpack_require__(2027);

Object.defineProperty(exports, "ReadConcernLevel", ({
  enumerable: true,
  get: function get() {
    return read_concern_1.ReadConcernLevel;
  }
}));

var read_preference_1 = __webpack_require__(3985);

Object.defineProperty(exports, "ReadPreferenceMode", ({
  enumerable: true,
  get: function get() {
    return read_preference_1.ReadPreferenceMode;
  }
}));

var common_3 = __webpack_require__(4118);

Object.defineProperty(exports, "ServerType", ({
  enumerable: true,
  get: function get() {
    return common_3.ServerType;
  }
}));
Object.defineProperty(exports, "TopologyType", ({
  enumerable: true,
  get: function get() {
    return common_3.TopologyType;
  }
})); // Helper classes

var read_concern_2 = __webpack_require__(2027);

Object.defineProperty(exports, "ReadConcern", ({
  enumerable: true,
  get: function get() {
    return read_concern_2.ReadConcern;
  }
}));

var read_preference_2 = __webpack_require__(3985);

Object.defineProperty(exports, "ReadPreference", ({
  enumerable: true,
  get: function get() {
    return read_preference_2.ReadPreference;
  }
}));

var write_concern_1 = __webpack_require__(1473);

Object.defineProperty(exports, "WriteConcern", ({
  enumerable: true,
  get: function get() {
    return write_concern_1.WriteConcern;
  }
})); // events

var command_monitoring_events_1 = __webpack_require__(8884);

Object.defineProperty(exports, "CommandFailedEvent", ({
  enumerable: true,
  get: function get() {
    return command_monitoring_events_1.CommandFailedEvent;
  }
}));
Object.defineProperty(exports, "CommandStartedEvent", ({
  enumerable: true,
  get: function get() {
    return command_monitoring_events_1.CommandStartedEvent;
  }
}));
Object.defineProperty(exports, "CommandSucceededEvent", ({
  enumerable: true,
  get: function get() {
    return command_monitoring_events_1.CommandSucceededEvent;
  }
}));

var connection_pool_events_1 = __webpack_require__(640);

Object.defineProperty(exports, "ConnectionCheckedInEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCheckedInEvent;
  }
}));
Object.defineProperty(exports, "ConnectionCheckedOutEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCheckedOutEvent;
  }
}));
Object.defineProperty(exports, "ConnectionCheckOutFailedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCheckOutFailedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionCheckOutStartedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCheckOutStartedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionClosedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionClosedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionCreatedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionCreatedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionPoolClearedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionPoolClearedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionPoolClosedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionPoolClosedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionPoolCreatedEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionPoolCreatedEvent;
  }
}));
Object.defineProperty(exports, "ConnectionPoolMonitoringEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionPoolMonitoringEvent;
  }
}));
Object.defineProperty(exports, "ConnectionReadyEvent", ({
  enumerable: true,
  get: function get() {
    return connection_pool_events_1.ConnectionReadyEvent;
  }
}));

var events_1 = __webpack_require__(9874);

Object.defineProperty(exports, "ServerClosedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerClosedEvent;
  }
}));
Object.defineProperty(exports, "ServerDescriptionChangedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerDescriptionChangedEvent;
  }
}));
Object.defineProperty(exports, "ServerHeartbeatFailedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerHeartbeatFailedEvent;
  }
}));
Object.defineProperty(exports, "ServerHeartbeatStartedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerHeartbeatStartedEvent;
  }
}));
Object.defineProperty(exports, "ServerHeartbeatSucceededEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerHeartbeatSucceededEvent;
  }
}));
Object.defineProperty(exports, "ServerOpeningEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.ServerOpeningEvent;
  }
}));
Object.defineProperty(exports, "TopologyClosedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.TopologyClosedEvent;
  }
}));
Object.defineProperty(exports, "TopologyDescriptionChangedEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.TopologyDescriptionChangedEvent;
  }
}));
Object.defineProperty(exports, "TopologyOpeningEvent", ({
  enumerable: true,
  get: function get() {
    return events_1.TopologyOpeningEvent;
  }
}));

var srv_polling_1 = __webpack_require__(9654);

Object.defineProperty(exports, "SrvPollingEvent", ({
  enumerable: true,
  get: function get() {
    return srv_polling_1.SrvPollingEvent;
  }
}));

/***/ }),

/***/ 295:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Logger = exports.LoggerLevel = void 0;

var util_1 = __webpack_require__(3837);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356); // Filters for classes


var classFilters = {};
var filteredClasses = {};
var level; // Save the process id

var pid = process.pid; // current logger
// eslint-disable-next-line no-console

var _currentLogger = console.warn;
/** @public */

exports.LoggerLevel = Object.freeze({
  ERROR: 'error',
  WARN: 'warn',
  INFO: 'info',
  DEBUG: 'debug',
  error: 'error',
  warn: 'warn',
  info: 'info',
  debug: 'debug'
});
/**
 * @public
 */

var Logger = /*#__PURE__*/function () {
  /**
   * Creates a new Logger instance
   *
   * @param className - The Class name associated with the logging instance
   * @param options - Optional logging settings
   */
  function Logger(className, options) {
    _classCallCheck(this, Logger);

    options = options !== null && options !== void 0 ? options : {}; // Current reference

    this.className = className; // Current logger

    if (!(options.logger instanceof Logger) && typeof options.logger === 'function') {
      _currentLogger = options.logger;
    } // Set level of logging, default is error


    if (options.loggerLevel) {
      level = options.loggerLevel || exports.LoggerLevel.ERROR;
    } // Add all class names


    if (filteredClasses[this.className] == null) {
      classFilters[this.className] = true;
    }
  }
  /**
   * Log a message at the debug level
   *
   * @param message - The message to log
   * @param object - Additional meta data to log
   */


  _createClass(Logger, [{
    key: "debug",
    value: function debug(message, object) {
      if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = (0, util_1.format)('[%s-%s:%s] %s %s', 'DEBUG', this.className, pid, dateTime, message);
        var state = {
          type: exports.LoggerLevel.DEBUG,
          message: message,
          className: this.className,
          pid: pid,
          date: dateTime
        };
        if (object) state.meta = object;

        _currentLogger(msg, state);
      }
    }
    /**
     * Log a message at the warn level
     *
     * @param message - The message to log
     * @param object - Additional meta data to log
     */

  }, {
    key: "warn",
    value: function warn(message, object) {
      if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = (0, util_1.format)('[%s-%s:%s] %s %s', 'WARN', this.className, pid, dateTime, message);
        var state = {
          type: exports.LoggerLevel.WARN,
          message: message,
          className: this.className,
          pid: pid,
          date: dateTime
        };
        if (object) state.meta = object;

        _currentLogger(msg, state);
      }
    }
    /**
     * Log a message at the info level
     *
     * @param message - The message to log
     * @param object - Additional meta data to log
     */

  }, {
    key: "info",
    value: function info(message, object) {
      if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = (0, util_1.format)('[%s-%s:%s] %s %s', 'INFO', this.className, pid, dateTime, message);
        var state = {
          type: exports.LoggerLevel.INFO,
          message: message,
          className: this.className,
          pid: pid,
          date: dateTime
        };
        if (object) state.meta = object;

        _currentLogger(msg, state);
      }
    }
    /**
     * Log a message at the error level
     *
     * @param message - The message to log
     * @param object - Additional meta data to log
     */

  }, {
    key: "error",
    value: function error(message, object) {
      if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = (0, util_1.format)('[%s-%s:%s] %s %s', 'ERROR', this.className, pid, dateTime, message);
        var state = {
          type: exports.LoggerLevel.ERROR,
          message: message,
          className: this.className,
          pid: pid,
          date: dateTime
        };
        if (object) state.meta = object;

        _currentLogger(msg, state);
      }
    }
    /** Is the logger set at info level */

  }, {
    key: "isInfo",
    value: function isInfo() {
      return level === exports.LoggerLevel.INFO || level === exports.LoggerLevel.DEBUG;
    }
    /** Is the logger set at error level */

  }, {
    key: "isError",
    value: function isError() {
      return level === exports.LoggerLevel.ERROR || level === exports.LoggerLevel.INFO || level === exports.LoggerLevel.DEBUG;
    }
    /** Is the logger set at error level */

  }, {
    key: "isWarn",
    value: function isWarn() {
      return level === exports.LoggerLevel.ERROR || level === exports.LoggerLevel.WARN || level === exports.LoggerLevel.INFO || level === exports.LoggerLevel.DEBUG;
    }
    /** Is the logger set at debug level */

  }, {
    key: "isDebug",
    value: function isDebug() {
      return level === exports.LoggerLevel.DEBUG;
    }
    /** Resets the logger to default settings, error and no filtered classes */

  }], [{
    key: "reset",
    value: function reset() {
      level = exports.LoggerLevel.ERROR;
      filteredClasses = {};
    }
    /** Get the current logger function */

  }, {
    key: "currentLogger",
    value: function currentLogger() {
      return _currentLogger;
    }
    /**
     * Set the current logger function
     *
     * @param logger - Custom logging function
     */

  }, {
    key: "setCurrentLogger",
    value: function setCurrentLogger(logger) {
      if (typeof logger !== 'function') {
        throw new error_1.MongoInvalidArgumentError('Current logger must be a function');
      }

      _currentLogger = logger;
    }
    /**
     * Filter log messages for a particular class
     *
     * @param type - The type of filter (currently only class)
     * @param values - The filters to apply
     */

  }, {
    key: "filter",
    value: function filter(type, values) {
      if (type === 'class' && Array.isArray(values)) {
        filteredClasses = {};
        values.forEach(function (x) {
          return filteredClasses[x] = true;
        });
      }
    }
    /**
     * Set the current log level
     *
     * @param newLevel - Set current log level (debug, warn, info, error)
     */

  }, {
    key: "setLevel",
    value: function setLevel(newLevel) {
      if (newLevel !== exports.LoggerLevel.INFO && newLevel !== exports.LoggerLevel.ERROR && newLevel !== exports.LoggerLevel.DEBUG && newLevel !== exports.LoggerLevel.WARN) {
        throw new error_1.MongoInvalidArgumentError("Argument \"newLevel\" should be one of ".concat((0, utils_1.enumToString)(exports.LoggerLevel)));
      }

      level = newLevel;
    }
  }]);

  return Logger;
}();

exports.Logger = Logger;

/***/ }),

/***/ 9635:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MongoClient = exports.ServerApiVersion = void 0;

var bson_1 = __webpack_require__(53);

var change_stream_1 = __webpack_require__(4672);

var connection_string_1 = __webpack_require__(6964);

var db_1 = __webpack_require__(9828);

var error_1 = __webpack_require__(9271);

var mongo_types_1 = __webpack_require__(3738);

var connect_1 = __webpack_require__(9355);

var promise_provider_1 = __webpack_require__(8912);

var read_preference_1 = __webpack_require__(3985);

var server_selection_1 = __webpack_require__(2557);

var sessions_1 = __webpack_require__(4408);

var utils_1 = __webpack_require__(4356);
/** @public */


exports.ServerApiVersion = Object.freeze({
  v1: '1'
});
/** @internal */

var kOptions = Symbol('options');
/**
 * The **MongoClient** class is a class that allows for making Connections to MongoDB.
 * @public
 *
 * @remarks
 * The programmatically provided options take precedence over the URI options.
 *
 * @example
 * ```js
 * // Connect using a MongoClient instance
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * const mongoClient = new MongoClient(url);
 * mongoClient.connect(function(err, client) {
 *   const db = client.db(dbName);
 *   client.close();
 * });
 * ```
 *
 * @example
 * ```js
 * // Connect using the MongoClient.connect static method
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) {
 *   const db = client.db(dbName);
 *   client.close();
 * });
 * ```
 */

var MongoClient = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(MongoClient, _mongo_types_1$TypedE);

  var _super = _createSuper(MongoClient);

  function MongoClient(url, options) {
    var _this;

    _classCallCheck(this, MongoClient);

    _this = _super.call(this);
    _this[kOptions] = (0, connection_string_1.parseOptions)(url, _assertThisInitialized(_this), options); // eslint-disable-next-line @typescript-eslint/no-this-alias

    var client = _assertThisInitialized(_this); // The internal state


    _this.s = {
      url: url,
      bsonOptions: (0, bson_1.resolveBSONOptions)(_this[kOptions]),
      namespace: (0, utils_1.ns)('admin'),
      hasBeenClosed: false,
      sessionPool: new sessions_1.ServerSessionPool(_assertThisInitialized(_this)),
      activeSessions: new Set(),

      get options() {
        return client[kOptions];
      },

      get readConcern() {
        return client[kOptions].readConcern;
      },

      get writeConcern() {
        return client[kOptions].writeConcern;
      },

      get readPreference() {
        return client[kOptions].readPreference;
      },

      get logger() {
        return client[kOptions].logger;
      },

      get isMongoClient() {
        return true;
      }

    };
    return _this;
  }

  _createClass(MongoClient, [{
    key: "options",
    get: function get() {
      return Object.freeze(_objectSpread({}, this[kOptions]));
    }
  }, {
    key: "serverApi",
    get: function get() {
      return this[kOptions].serverApi && Object.freeze(_objectSpread({}, this[kOptions].serverApi));
    }
    /**
     * Intended for APM use only
     * @internal
     */

  }, {
    key: "monitorCommands",
    get: function get() {
      return this[kOptions].monitorCommands;
    },
    set: function set(value) {
      this[kOptions].monitorCommands = value;
    }
  }, {
    key: "autoEncrypter",
    get: function get() {
      return this[kOptions].autoEncrypter;
    }
  }, {
    key: "readConcern",
    get: function get() {
      return this.s.readConcern;
    }
  }, {
    key: "writeConcern",
    get: function get() {
      return this.s.writeConcern;
    }
  }, {
    key: "readPreference",
    get: function get() {
      return this.s.readPreference;
    }
  }, {
    key: "bsonOptions",
    get: function get() {
      return this.s.bsonOptions;
    }
  }, {
    key: "logger",
    get: function get() {
      return this.s.logger;
    }
  }, {
    key: "connect",
    value: function connect(callback) {
      var _this2 = this;

      if (callback && typeof callback !== 'function') {
        throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');
      }

      return (0, utils_1.maybePromise)(callback, function (cb) {
        (0, connect_1.connect)(_this2, _this2[kOptions], function (err) {
          if (err) return cb(err);
          cb(undefined, _this2);
        });
      });
    }
  }, {
    key: "close",
    value: function close(forceOrCallback, callback) {
      var _this3 = this;

      // There's no way to set hasBeenClosed back to false
      Object.defineProperty(this.s, 'hasBeenClosed', {
        value: true,
        enumerable: true,
        configurable: false,
        writable: false
      });

      if (typeof forceOrCallback === 'function') {
        callback = forceOrCallback;
      }

      var force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;
      return (0, utils_1.maybePromise)(callback, function (callback) {
        if (_this3.topology == null) {
          // Do not connect just to end sessions
          return callback();
        }

        var activeSessionEnds = Array.from(_this3.s.activeSessions, function (session) {
          return session.endSession();
        });

        _this3.s.activeSessions.clear();

        Promise.all(activeSessionEnds).then(function () {
          if (_this3.topology == null) {
            return;
          } // If we would attempt to select a server and get nothing back we short circuit
          // to avoid the server selection timeout.


          var selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
          var topologyDescription = _this3.topology.description;
          var serverDescriptions = Array.from(topologyDescription.servers.values());
          var servers = selector(topologyDescription, serverDescriptions);

          if (servers.length === 0) {
            return;
          }

          var endSessions = Array.from(_this3.s.sessionPool.sessions, function (_ref) {
            var id = _ref.id;
            return id;
          });
          if (endSessions.length === 0) return;
          return _this3.db('admin').command({
            endSessions: endSessions
          }, {
            readPreference: read_preference_1.ReadPreference.primaryPreferred,
            noResponse: true
          })["catch"](function () {
            return null;
          }); // outcome does not matter
        }).then(function () {
          if (_this3.topology == null) {
            return;
          } // clear out references to old topology


          var topology = _this3.topology;
          _this3.topology = undefined;
          return new Promise(function (resolve, reject) {
            topology.close({
              force: force
            }, function (error) {
              if (error) return reject(error);
              var encrypter = _this3[kOptions].encrypter;

              if (encrypter) {
                return encrypter.close(_this3, force, function (error) {
                  if (error) return reject(error);
                  resolve();
                });
              }

              resolve();
            });
          });
        }).then(function () {
          return callback();
        }, function (error) {
          return callback(error);
        });
      });
    }
    /**
     * Create a new Db instance sharing the current socket connections.
     *
     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.
     * @param options - Optional settings for Db construction
     */

  }, {
    key: "db",
    value: function db(dbName, options) {
      options = options !== null && options !== void 0 ? options : {}; // Default to db from connection string if not provided

      if (!dbName) {
        dbName = this.options.dbName;
      } // Copy the options and add out internal override of the not shared flag


      var finalOptions = Object.assign({}, this[kOptions], options); // Return the db object

      var db = new db_1.Db(this, dbName, finalOptions); // Return the database

      return db;
    }
  }, {
    key: "startSession",
    value: function startSession(options) {
      var _this4 = this;

      var session = new sessions_1.ClientSession(this, this.s.sessionPool, _objectSpread({
        explicit: true
      }, options), this[kOptions]);
      this.s.activeSessions.add(session);
      session.once('ended', function () {
        _this4.s.activeSessions["delete"](session);
      });
      return session;
    }
  }, {
    key: "withSession",
    value: function withSession(optionsOrOperation, callback) {
      var options = _objectSpread({
        // Always define an owner
        owner: Symbol()
      }, _typeof(optionsOrOperation) === 'object' ? optionsOrOperation : {});

      var withSessionCallback = typeof optionsOrOperation === 'function' ? optionsOrOperation : callback;

      if (withSessionCallback == null) {
        throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');
      }

      var session = this.startSession(options);
      var Promise = promise_provider_1.PromiseProvider.get();
      return Promise.resolve().then(function () {
        return withSessionCallback(session);
      }).then(function () {// Do not return the result of callback
      })["finally"](function () {
        session.endSession()["catch"](function () {
          return null;
        });
      });
    }
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates,
     * replacements, deletions, and invalidations) in this cluster. Will ignore all
     * changes to system collections, as well as the local, admin, and config databases.
     *
     * @remarks
     * watch() accepts two generic arguments for distinct usecases:
     * - The first is to provide the schema that may be defined for all the data within the current cluster
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     *
     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     * @typeParam TSchema - Type of the data being detected by the change stream
     * @typeParam TChange - Type of the whole change stream document emitted
     */

  }, {
    key: "watch",
    value: function watch() {
      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Allow optionally not specifying a pipeline
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }

      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    /** Return the mongo client logger */

  }, {
    key: "getLogger",
    value: function getLogger() {
      return this.s.logger;
    }
  }], [{
    key: "connect",
    value: function connect(url, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};

      try {
        // Create client
        var mongoClient = new MongoClient(url, options); // Execute the connect method

        if (callback) {
          return mongoClient.connect(callback);
        } else {
          return mongoClient.connect();
        }
      } catch (error) {
        if (callback) return callback(error);else return promise_provider_1.PromiseProvider.get().reject(error);
      }
    }
  }]);

  return MongoClient;
}(mongo_types_1.TypedEventEmitter);

exports.MongoClient = MongoClient;

/***/ }),

/***/ 3738:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CancellationToken = exports.TypedEventEmitter = exports.BSONType = void 0;

var events_1 = __webpack_require__(1239);
/** @public */


exports.BSONType = Object.freeze({
  "double": 1,
  string: 2,
  object: 3,
  array: 4,
  binData: 5,
  undefined: 6,
  objectId: 7,
  bool: 8,
  date: 9,
  "null": 10,
  regex: 11,
  dbPointer: 12,
  javascript: 13,
  symbol: 14,
  javascriptWithScope: 15,
  "int": 16,
  timestamp: 17,
  "long": 18,
  decimal: 19,
  minKey: -1,
  maxKey: 127
});
/**
 * Typescript type safe event emitter
 * @public
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars

var TypedEventEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(TypedEventEmitter, _events_1$EventEmitte);

  var _super = _createSuper(TypedEventEmitter);

  function TypedEventEmitter() {
    _classCallCheck(this, TypedEventEmitter);

    return _super.apply(this, arguments);
  }

  return _createClass(TypedEventEmitter);
}(events_1.EventEmitter);

exports.TypedEventEmitter = TypedEventEmitter;
/** @public */

var CancellationToken = /*#__PURE__*/function (_TypedEventEmitter) {
  _inherits(CancellationToken, _TypedEventEmitter);

  var _super2 = _createSuper(CancellationToken);

  function CancellationToken() {
    _classCallCheck(this, CancellationToken);

    return _super2.apply(this, arguments);
  }

  return _createClass(CancellationToken);
}(TypedEventEmitter);

exports.CancellationToken = CancellationToken;

/***/ }),

/***/ 8115:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AddUserOperation = void 0;

var crypto = __webpack_require__(6113);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


var AddUserOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(AddUserOperation, _command_1$CommandOpe);

  var _super = _createSuper(AddUserOperation);

  function AddUserOperation(db, username, password, options) {
    var _this;

    _classCallCheck(this, AddUserOperation);

    _this = _super.call(this, db, options);
    _this.db = db;
    _this.username = username;
    _this.password = password;
    _this.options = options !== null && options !== void 0 ? options : {};
    return _this;
  }

  _createClass(AddUserOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var db = this.db;
      var username = this.username;
      var password = this.password;
      var options = this.options; // Error out if digestPassword set

      if (options.digestPassword != null) {
        return callback(new error_1.MongoInvalidArgumentError('Option "digestPassword" not supported via addUser, use db.command(...) instead'));
      }

      var roles;

      if (!options.roles || Array.isArray(options.roles) && options.roles.length === 0) {
        (0, utils_1.emitWarningOnce)('Creating a user without roles is deprecated. Defaults to "root" if db is "admin" or "dbOwner" otherwise');

        if (db.databaseName.toLowerCase() === 'admin') {
          roles = ['root'];
        } else {
          roles = ['dbOwner'];
        }
      } else {
        roles = Array.isArray(options.roles) ? options.roles : [options.roles];
      }

      var topology;

      try {
        topology = (0, utils_1.getTopology)(db);
      } catch (error) {
        return callback(error);
      }

      var digestPassword = topology.lastHello().maxWireVersion >= 7;
      var userPassword = password;

      if (!digestPassword) {
        // Use node md5 generator
        var md5 = crypto.createHash('md5'); // Generate keys used for authentication

        md5.update("".concat(username, ":mongo:").concat(password));
        userPassword = md5.digest('hex');
      } // Build the command to execute


      var command = {
        createUser: username,
        customData: options.customData || {},
        roles: roles,
        digestPassword: digestPassword
      }; // No password

      if (typeof password === 'string') {
        command.pwd = userPassword;
      }

      _get(_getPrototypeOf(AddUserOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return AddUserOperation;
}(command_1.CommandOperation);

exports.AddUserOperation = AddUserOperation;
(0, operation_1.defineAspects)(AddUserOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 17:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


exports.DB_AGGREGATE_COLLECTION = 1;
var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
/** @internal */

var AggregateOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(AggregateOperation, _command_1$CommandOpe);

  var _super = _createSuper(AggregateOperation);

  function AggregateOperation(ns, pipeline, options) {
    var _this;

    _classCallCheck(this, AggregateOperation);

    _this = _super.call(this, undefined, _objectSpread(_objectSpread({}, options), {}, {
      dbName: ns.db
    }));
    _this.options = options !== null && options !== void 0 ? options : {}; // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION

    _this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;
    _this.pipeline = pipeline; // determine if we have a write stage, override read preference if so

    _this.hasWriteStage = false;

    if (typeof (options === null || options === void 0 ? void 0 : options.out) === 'string') {
      _this.pipeline = _this.pipeline.concat({
        $out: options.out
      });
      _this.hasWriteStage = true;
    } else if (pipeline.length > 0) {
      var finalStage = pipeline[pipeline.length - 1];

      if (finalStage.$out || finalStage.$merge) {
        _this.hasWriteStage = true;
      }
    }

    if (_this.hasWriteStage) {
      _this.trySecondaryWrite = true;
    }

    if (_this.explain && _this.writeConcern) {
      throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
    }

    if ((options === null || options === void 0 ? void 0 : options.cursor) != null && _typeof(options.cursor) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');
    }

    return _this;
  }

  _createClass(AggregateOperation, [{
    key: "canRetryRead",
    get: function get() {
      return !this.hasWriteStage;
    }
  }, {
    key: "addToPipeline",
    value: function addToPipeline(stage) {
      this.pipeline.push(stage);
    }
  }, {
    key: "execute",
    value: function execute(server, session, callback) {
      var options = this.options;
      var serverWireVersion = (0, utils_1.maxWireVersion)(server);
      var command = {
        aggregate: this.target,
        pipeline: this.pipeline
      };

      if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
        this.readConcern = undefined;
      }

      if (serverWireVersion >= 5) {
        if (this.hasWriteStage && this.writeConcern) {
          Object.assign(command, {
            writeConcern: this.writeConcern
          });
        }
      }

      if (options.bypassDocumentValidation === true) {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }

      if (typeof options.allowDiskUse === 'boolean') {
        command.allowDiskUse = options.allowDiskUse;
      }

      if (options.hint) {
        command.hint = options.hint;
      }

      if (options["let"]) {
        command["let"] = options["let"];
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (options.comment !== undefined) {
        command.comment = options.comment;
      }

      command.cursor = options.cursor || {};

      if (options.batchSize && !this.hasWriteStage) {
        command.cursor.batchSize = options.batchSize;
      }

      _get(_getPrototypeOf(AggregateOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return AggregateOperation;
}(command_1.CommandOperation);

exports.AggregateOperation = AggregateOperation;
(0, operation_1.defineAspects)(AggregateOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);

/***/ }),

/***/ 492:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BulkWriteOperation = void 0;

var operation_1 = __webpack_require__(6778);
/** @internal */


var BulkWriteOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(BulkWriteOperation, _operation_1$Abstract);

  var _super = _createSuper(BulkWriteOperation);

  function BulkWriteOperation(collection, operations, options) {
    var _this;

    _classCallCheck(this, BulkWriteOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.collection = collection;
    _this.operations = operations;
    return _this;
  }

  _createClass(BulkWriteOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var coll = this.collection;
      var operations = this.operations;

      var options = _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {
        readPreference: this.readPreference
      }); // Create the bulk operation


      var bulk = options.ordered === false ? coll.initializeUnorderedBulkOp(options) : coll.initializeOrderedBulkOp(options); // for each op go through and add to the bulk

      try {
        for (var i = 0; i < operations.length; i++) {
          bulk.raw(operations[i]);
        }
      } catch (err) {
        return callback(err);
      } // Execute the bulk


      bulk.execute(_objectSpread(_objectSpread({}, options), {}, {
        session: session
      }), function (err, r) {
        // We have connection level error
        if (!r && err) {
          return callback(err);
        } // Return the results


        callback(undefined, r);
      });
    }
  }]);

  return BulkWriteOperation;
}(operation_1.AbstractOperation);

exports.BulkWriteOperation = BulkWriteOperation;
(0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 1119:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CollectionsOperation = void 0;

var collection_1 = __webpack_require__(9730);

var operation_1 = __webpack_require__(6778);
/** @internal */


var CollectionsOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(CollectionsOperation, _operation_1$Abstract);

  var _super = _createSuper(CollectionsOperation);

  function CollectionsOperation(db, options) {
    var _this;

    _classCallCheck(this, CollectionsOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.db = db;
    return _this;
  }

  _createClass(CollectionsOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var db = this.db; // Let's get the collection names

      db.listCollections({}, _objectSpread(_objectSpread({}, this.options), {}, {
        nameOnly: true,
        readPreference: this.readPreference,
        session: session
      })).toArray(function (err, documents) {
        if (err || !documents) return callback(err); // Filter collections removing any illegal ones

        documents = documents.filter(function (doc) {
          return doc.name.indexOf('$') === -1;
        }); // Return the collection objects

        callback(undefined, documents.map(function (d) {
          return new collection_1.Collection(db, d.name, db.s.options);
        }));
      });
    }
  }]);

  return CollectionsOperation;
}(operation_1.AbstractOperation);

exports.CollectionsOperation = CollectionsOperation;

/***/ }),

/***/ 2124:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CommandOperation = void 0;

var error_1 = __webpack_require__(9271);

var explain_1 = __webpack_require__(3480);

var read_concern_1 = __webpack_require__(2027);

var server_selection_1 = __webpack_require__(2557);

var utils_1 = __webpack_require__(4356);

var write_concern_1 = __webpack_require__(1473);

var operation_1 = __webpack_require__(6778);

var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
/** @internal */

var CommandOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(CommandOperation, _operation_1$Abstract);

  var _super = _createSuper(CommandOperation);

  function CommandOperation(parent, options) {
    var _this;

    _classCallCheck(this, CommandOperation);

    _this = _super.call(this, options);
    _this.options = options !== null && options !== void 0 ? options : {}; // NOTE: this was explicitly added for the add/remove user operations, it's likely
    //       something we'd want to reconsider. Perhaps those commands can use `Admin`
    //       as a parent?

    var dbNameOverride = (options === null || options === void 0 ? void 0 : options.dbName) || (options === null || options === void 0 ? void 0 : options.authdb);

    if (dbNameOverride) {
      _this.ns = new utils_1.MongoDBNamespace(dbNameOverride, '$cmd');
    } else {
      _this.ns = parent ? parent.s.namespace.withCollection('$cmd') : new utils_1.MongoDBNamespace('admin', '$cmd');
    }

    _this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
    _this.writeConcern = write_concern_1.WriteConcern.fromOptions(options); // TODO(NODE-2056): make logger another "inheritable" property

    if (parent && parent.logger) {
      _this.logger = parent.logger;
    }

    if (_this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
      _this.explain = explain_1.Explain.fromOptions(options);
    } else if ((options === null || options === void 0 ? void 0 : options.explain) != null) {
      throw new error_1.MongoInvalidArgumentError("Option \"explain\" is not supported on this command");
    }

    return _this;
  }

  _createClass(CommandOperation, [{
    key: "canRetryWrite",
    get: function get() {
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        return this.explain == null;
      }

      return true;
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(server, session, cmd, callback) {
      // TODO: consider making this a non-enumerable property
      this.server = server;

      var options = _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {
        readPreference: this.readPreference,
        session: session
      });

      var serverWireVersion = (0, utils_1.maxWireVersion)(server);
      var inTransaction = this.session && this.session.inTransaction();

      if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
        Object.assign(cmd, {
          readConcern: this.readConcern
        });
      }

      if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
        options.omitReadPreference = true;
      }

      if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
        callback(new error_1.MongoCompatibilityError("Server ".concat(server.name, ", which reports wire version ").concat(serverWireVersion, ", does not support collation")));
        return;
      }

      if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
        Object.assign(cmd, {
          writeConcern: this.writeConcern
        });
      }

      if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
        if (options.collation && _typeof(options.collation) === 'object' && !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
          Object.assign(cmd, {
            collation: options.collation
          });
        }
      }

      if (typeof options.maxTimeMS === 'number') {
        cmd.maxTimeMS = options.maxTimeMS;
      }

      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
        if (serverWireVersion < 6 && cmd.aggregate) {
          // Prior to 3.6, with aggregate, verbosity is ignored, and we must pass in "explain: true"
          cmd.explain = true;
        } else {
          cmd = (0, utils_1.decorateWithExplain)(cmd, this.explain);
        }
      }

      server.command(this.ns, cmd, options, callback);
    }
  }]);

  return CommandOperation;
}(operation_1.AbstractOperation);

exports.CommandOperation = CommandOperation;

/***/ }),

/***/ 475:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.prepareDocs = exports.indexInformation = void 0;

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

function indexInformation(db, name, _optionsOrCallback, _callback) {
  var options = _optionsOrCallback;
  var callback = _callback;

  if ('function' === typeof _optionsOrCallback) {
    callback = _optionsOrCallback;
    options = {};
  } // If we specified full information


  var full = options.full == null ? false : options.full;
  var topology;

  try {
    topology = (0, utils_1.getTopology)(db);
  } catch (error) {
    return callback(error);
  } // Did the user destroy the topology


  if (topology.isDestroyed()) return callback(new error_1.MongoTopologyClosedError()); // Process all the results from the index command and collection

  function processResults(indexes) {
    // Contains all the information
    var info = {}; // Process all the indexes

    for (var i = 0; i < indexes.length; i++) {
      var index = indexes[i]; // Let's unpack the object

      info[index.name] = [];

      for (var _name in index.key) {
        info[index.name].push([_name, index.key[_name]]);
      }
    }

    return info;
  } // Get the list of indexes of the specified collection


  db.collection(name).listIndexes(options).toArray(function (err, indexes) {
    if (err) return callback(err);
    if (!Array.isArray(indexes)) return callback(undefined, []);
    if (full) return callback(undefined, indexes);
    callback(undefined, processResults(indexes));
  });
}

exports.indexInformation = indexInformation;

function prepareDocs(coll, docs, options) {
  var _a;

  var forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : (_a = coll.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId; // no need to modify the docs if server sets the ObjectId

  if (forceServerObjectId === true) {
    return docs;
  }

  return docs.map(function (doc) {
    if (doc._id == null) {
      doc._id = coll.s.pkFactory.createPk();
    }

    return doc;
  });
}

exports.prepareDocs = prepareDocs;

/***/ }),

/***/ 9355:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.connect = void 0;

var connection_string_1 = __webpack_require__(6964);

var constants_1 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var topology_1 = __webpack_require__(4228);

function connect(mongoClient, options, callback) {
  if (!callback) {
    throw new error_1.MongoInvalidArgumentError('Callback function must be provided');
  } // If a connection already been established, we can terminate early


  if (mongoClient.topology && mongoClient.topology.isConnected()) {
    return callback(undefined, mongoClient);
  }

  var logger = mongoClient.logger;

  var connectCallback = function connectCallback(err) {
    var warningMessage = 'seed list contains no mongos proxies, replicaset connections requires ' + 'the parameter replicaSet to be supplied in the URI or options object, ' + 'mongodb://server:port/db?replicaSet=name';

    if (err && err.message === 'no mongos proxies found in seed list') {
      if (logger.isWarn()) {
        logger.warn(warningMessage);
      } // Return a more specific error message for MongoClient.connect
      // TODO(NODE-3483)


      return callback(new error_1.MongoRuntimeError(warningMessage));
    }

    callback(err, mongoClient);
  };

  if (typeof options.srvHost === 'string') {
    return (0, connection_string_1.resolveSRVRecord)(options, function (err, hosts) {
      if (err || !hosts) return callback(err);

      var _iterator = _createForOfIteratorHelper(hosts.entries()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              index = _step$value[0],
              host = _step$value[1];

          options.hosts[index] = host;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return createTopology(mongoClient, options, connectCallback);
    });
  }

  return createTopology(mongoClient, options, connectCallback);
}

exports.connect = connect;

function createTopology(mongoClient, options, callback) {
  // Create the topology
  var topology = new topology_1.Topology(options.hosts, options); // Events can be emitted before initialization is complete so we have to
  // save the reference to the topology on the client ASAP if the event handlers need to access it

  mongoClient.topology = topology;
  topology.client = mongoClient;
  topology.once(topology_1.Topology.OPEN, function () {
    return mongoClient.emit('open', mongoClient);
  });

  var _iterator2 = _createForOfIteratorHelper(constants_1.MONGO_CLIENT_EVENTS),
      _step2;

  try {
    var _loop = function _loop() {
      var event = _step2.value;
      topology.on(event, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return mongoClient.emit.apply(mongoClient, [event].concat(args));
      });
    };

    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      _loop();
    } // initialize CSFLE if requested

  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  if (mongoClient.autoEncrypter) {
    mongoClient.autoEncrypter.init(function (err) {
      if (err) {
        return callback(err);
      }

      topology.connect(options, function (err) {
        if (err) {
          topology.close({
            force: true
          });
          return callback(err);
        }

        options.encrypter.connectInternalClient(function (error) {
          if (error) return callback(error);
          callback(undefined, topology);
        });
      });
    });
    return;
  } // otherwise connect normally


  topology.connect(options, function (err) {
    if (err) {
      topology.close({
        force: true
      });
      return callback(err);
    }

    callback(undefined, topology);
    return;
  });
}

/***/ }),

/***/ 2307:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CountOperation = void 0;

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


var CountOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(CountOperation, _command_1$CommandOpe);

  var _super = _createSuper(CountOperation);

  function CountOperation(namespace, filter, options) {
    var _this;

    _classCallCheck(this, CountOperation);

    _this = _super.call(this, {
      s: {
        namespace: namespace
      }
    }, options);
    _this.options = options;
    _this.collectionName = namespace.collection;
    _this.query = filter;
    return _this;
  }

  _createClass(CountOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var options = this.options;
      var cmd = {
        count: this.collectionName,
        query: this.query
      };

      if (typeof options.limit === 'number') {
        cmd.limit = options.limit;
      }

      if (typeof options.skip === 'number') {
        cmd.skip = options.skip;
      }

      if (options.hint != null) {
        cmd.hint = options.hint;
      }

      if (typeof options.maxTimeMS === 'number') {
        cmd.maxTimeMS = options.maxTimeMS;
      }

      _get(_getPrototypeOf(CountOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err, result) {
        callback(err, result ? result.n : 0);
      });
    }
  }]);

  return CountOperation;
}(command_1.CommandOperation);

exports.CountOperation = CountOperation;
(0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);

/***/ }),

/***/ 4961:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CountDocumentsOperation = void 0;

var aggregate_1 = __webpack_require__(17);
/** @internal */


var CountDocumentsOperation = /*#__PURE__*/function (_aggregate_1$Aggregat) {
  _inherits(CountDocumentsOperation, _aggregate_1$Aggregat);

  var _super = _createSuper(CountDocumentsOperation);

  function CountDocumentsOperation(collection, query, options) {
    _classCallCheck(this, CountDocumentsOperation);

    var pipeline = [];
    pipeline.push({
      $match: query
    });

    if (typeof options.skip === 'number') {
      pipeline.push({
        $skip: options.skip
      });
    }

    if (typeof options.limit === 'number') {
      pipeline.push({
        $limit: options.limit
      });
    }

    pipeline.push({
      $group: {
        _id: 1,
        n: {
          $sum: 1
        }
      }
    });
    return _super.call(this, collection.s.namespace, pipeline, options);
  }

  _createClass(CountDocumentsOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      _get(_getPrototypeOf(CountDocumentsOperation.prototype), "execute", this).call(this, server, session, function (err, result) {
        if (err || !result) {
          callback(err);
          return;
        } // NOTE: We're avoiding creating a cursor here to reduce the callstack.


        var response = result;

        if (response.cursor == null || response.cursor.firstBatch == null) {
          callback(undefined, 0);
          return;
        }

        var docs = response.cursor.firstBatch;
        callback(undefined, docs.length ? docs[0].n : 0);
      });
    }
  }]);

  return CountDocumentsOperation;
}(aggregate_1.AggregateOperation);

exports.CountDocumentsOperation = CountDocumentsOperation;

/***/ }),

/***/ 1348:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CreateCollectionOperation = void 0;

var collection_1 = __webpack_require__(9730);

var command_1 = __webpack_require__(2124);

var indexes_1 = __webpack_require__(6338);

var operation_1 = __webpack_require__(6778);

var ILLEGAL_COMMAND_FIELDS = new Set(['w', 'wtimeout', 'j', 'fsync', 'autoIndexId', 'pkFactory', 'raw', 'readPreference', 'session', 'readConcern', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation']);
/** @internal */

var CreateCollectionOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(CreateCollectionOperation, _command_1$CommandOpe);

  var _super = _createSuper(CreateCollectionOperation);

  function CreateCollectionOperation(db, name) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, CreateCollectionOperation);

    _this = _super.call(this, db, options);
    _this.options = options;
    _this.db = db;
    _this.name = name;
    return _this;
  }

  _createClass(CreateCollectionOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this2 = this;

      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _a, _b, _c, _d, _e, _f, db, name, options, encryptedFields, escCollection, eccCollection, ecocCollection, _i, _arr, collectionName, createOp, coll, createIndexOp;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                db = _this2.db;
                name = _this2.name;
                options = _this2.options;
                encryptedFields = (_a = options.encryptedFields) !== null && _a !== void 0 ? _a : (_c = (_b = db.s.client.options.autoEncryption) === null || _b === void 0 ? void 0 : _b.encryptedFieldsMap) === null || _c === void 0 ? void 0 : _c["".concat(db.databaseName, ".").concat(name)];

                if (!encryptedFields) {
                  _context.next = 18;
                  break;
                }

                // Create auxilliary collections for queryable encryption support.
                escCollection = (_d = encryptedFields.escCollection) !== null && _d !== void 0 ? _d : "enxcol_.".concat(name, ".esc");
                eccCollection = (_e = encryptedFields.eccCollection) !== null && _e !== void 0 ? _e : "enxcol_.".concat(name, ".ecc");
                ecocCollection = (_f = encryptedFields.ecocCollection) !== null && _f !== void 0 ? _f : "enxcol_.".concat(name, ".ecoc");
                _i = 0, _arr = [escCollection, eccCollection, ecocCollection];

              case 9:
                if (!(_i < _arr.length)) {
                  _context.next = 17;
                  break;
                }

                collectionName = _arr[_i];
                createOp = new CreateCollectionOperation(db, collectionName, {
                  clusteredIndex: {
                    key: {
                      _id: 1
                    },
                    unique: true
                  }
                });
                _context.next = 14;
                return createOp.executeWithoutEncryptedFieldsCheck(server, session);

              case 14:
                _i++;
                _context.next = 9;
                break;

              case 17:
                if (!options.encryptedFields) {
                  _this2.options = _objectSpread(_objectSpread({}, _this2.options), {}, {
                    encryptedFields: encryptedFields
                  });
                }

              case 18:
                _context.next = 20;
                return _this2.executeWithoutEncryptedFieldsCheck(server, session);

              case 20:
                coll = _context.sent;

                if (!encryptedFields) {
                  _context.next = 25;
                  break;
                }

                // Create the required index for queryable encryption support.
                createIndexOp = new indexes_1.CreateIndexOperation(db, name, {
                  __safeContent__: 1
                }, {});
                _context.next = 25;
                return new Promise(function (resolve, reject) {
                  createIndexOp.execute(server, session, function (err) {
                    return err ? reject(err) : resolve();
                  });
                });

              case 25:
                return _context.abrupt("return", coll);

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))().then(function (coll) {
        return callback(undefined, coll);
      }, function (err) {
        return callback(err);
      });
    }
  }, {
    key: "executeWithoutEncryptedFieldsCheck",
    value: function executeWithoutEncryptedFieldsCheck(server, session) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var db = _this3.db;
        var name = _this3.name;
        var options = _this3.options;

        var done = function done(err) {
          if (err) {
            return reject(err);
          }

          resolve(new collection_1.Collection(db, name, options));
        };

        var cmd = {
          create: name
        };

        for (var n in options) {
          if (options[n] != null && typeof options[n] !== 'function' && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options[n];
          }
        } // otherwise just execute the command


        _get(_getPrototypeOf(CreateCollectionOperation.prototype), "executeCommand", _this3).call(_this3, server, session, cmd, done);
      });
    }
  }]);

  return CreateCollectionOperation;
}(command_1.CommandOperation);

exports.CreateCollectionOperation = CreateCollectionOperation;
(0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 7857:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeDeleteStatement = exports.DeleteManyOperation = exports.DeleteOneOperation = exports.DeleteOperation = void 0;

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


var DeleteOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(DeleteOperation, _command_1$CommandOpe);

  var _super = _createSuper(DeleteOperation);

  function DeleteOperation(ns, statements, options) {
    var _this;

    _classCallCheck(this, DeleteOperation);

    _this = _super.call(this, undefined, options);
    _this.options = options;
    _this.ns = ns;
    _this.statements = statements;
    return _this;
  }

  _createClass(DeleteOperation, [{
    key: "canRetryWrite",
    get: function get() {
      if (_get(_getPrototypeOf(DeleteOperation.prototype), "canRetryWrite", this) === false) {
        return false;
      }

      return this.statements.every(function (op) {
        return op.limit != null ? op.limit > 0 : true;
      });
    }
  }, {
    key: "execute",
    value: function execute(server, session, callback) {
      var _a;

      var options = (_a = this.options) !== null && _a !== void 0 ? _a : {};
      var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
      var command = {
        "delete": this.ns.collection,
        deletes: this.statements,
        ordered: ordered
      };

      if (options["let"]) {
        command["let"] = options["let"];
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (options.comment !== undefined) {
        command.comment = options.comment;
      }

      if (options.explain != null && (0, utils_1.maxWireVersion)(server) < 3) {
        return callback ? callback(new error_1.MongoCompatibilityError("Server ".concat(server.name, " does not support explain on delete"))) : undefined;
      }

      var unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;

      if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 5) {
        if (this.statements.find(function (o) {
          return o.hint;
        })) {
          callback(new error_1.MongoCompatibilityError("Servers < 3.4 do not support hint on delete"));
          return;
        }
      }

      var statementWithCollation = this.statements.find(function (statement) {
        return !!statement.collation;
      });

      if (statementWithCollation && (0, utils_1.collationNotSupported)(server, statementWithCollation)) {
        callback(new error_1.MongoCompatibilityError("Server ".concat(server.name, " does not support collation")));
        return;
      }

      _get(_getPrototypeOf(DeleteOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return DeleteOperation;
}(command_1.CommandOperation);

exports.DeleteOperation = DeleteOperation;

var DeleteOneOperation = /*#__PURE__*/function (_DeleteOperation) {
  _inherits(DeleteOneOperation, _DeleteOperation);

  var _super2 = _createSuper(DeleteOneOperation);

  function DeleteOneOperation(collection, filter, options) {
    _classCallCheck(this, DeleteOneOperation);

    return _super2.call(this, collection.s.namespace, [makeDeleteStatement(filter, _objectSpread(_objectSpread({}, options), {}, {
      limit: 1
    }))], options);
  }

  _createClass(DeleteOneOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this2 = this;

      _get(_getPrototypeOf(DeleteOneOperation.prototype), "execute", this).call(this, server, session, function (err, res) {
        var _a, _b;

        if (err || res == null) return callback(err);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        if (_this2.explain) return callback(undefined, res);
        callback(undefined, {
          acknowledged: (_b = ((_a = _this2.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
          deletedCount: res.n
        });
      });
    }
  }]);

  return DeleteOneOperation;
}(DeleteOperation);

exports.DeleteOneOperation = DeleteOneOperation;

var DeleteManyOperation = /*#__PURE__*/function (_DeleteOperation2) {
  _inherits(DeleteManyOperation, _DeleteOperation2);

  var _super3 = _createSuper(DeleteManyOperation);

  function DeleteManyOperation(collection, filter, options) {
    _classCallCheck(this, DeleteManyOperation);

    return _super3.call(this, collection.s.namespace, [makeDeleteStatement(filter, options)], options);
  }

  _createClass(DeleteManyOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this3 = this;

      _get(_getPrototypeOf(DeleteManyOperation.prototype), "execute", this).call(this, server, session, function (err, res) {
        var _a, _b;

        if (err || res == null) return callback(err);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        if (_this3.explain) return callback(undefined, res);
        callback(undefined, {
          acknowledged: (_b = ((_a = _this3.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
          deletedCount: res.n
        });
      });
    }
  }]);

  return DeleteManyOperation;
}(DeleteOperation);

exports.DeleteManyOperation = DeleteManyOperation;

function makeDeleteStatement(filter, options) {
  var op = {
    q: filter,
    limit: typeof options.limit === 'number' ? options.limit : 0
  };

  if (options.single === true) {
    op.limit = 1;
  }

  if (options.collation) {
    op.collation = options.collation;
  }

  if (options.hint) {
    op.hint = options.hint;
  }

  return op;
}

exports.makeDeleteStatement = makeDeleteStatement;
(0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(DeleteOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);
(0, operation_1.defineAspects)(DeleteManyOperation, [operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);

/***/ }),

/***/ 6192:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DistinctOperation = void 0;

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/**
 * Return a list of distinct values for the given key across a collection.
 * @internal
 */


var DistinctOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(DistinctOperation, _command_1$CommandOpe);

  var _super = _createSuper(DistinctOperation);

  /**
   * Construct a Distinct operation.
   *
   * @param collection - Collection instance.
   * @param key - Field of the document to find distinct values for.
   * @param query - The query for filtering the set of documents to which we apply the distinct filter.
   * @param options - Optional settings. See Collection.prototype.distinct for a list of options.
   */
  function DistinctOperation(collection, key, query, options) {
    var _this;

    _classCallCheck(this, DistinctOperation);

    _this = _super.call(this, collection, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.collection = collection;
    _this.key = key;
    _this.query = query;
    return _this;
  }

  _createClass(DistinctOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this2 = this;

      var coll = this.collection;
      var key = this.key;
      var query = this.query;
      var options = this.options; // Distinct command

      var cmd = {
        distinct: coll.collectionName,
        key: key,
        query: query
      }; // Add maxTimeMS if defined

      if (typeof options.maxTimeMS === 'number') {
        cmd.maxTimeMS = options.maxTimeMS;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (typeof options.comment !== 'undefined') {
        cmd.comment = options.comment;
      } // Do we have a readConcern specified


      (0, utils_1.decorateWithReadConcern)(cmd, coll, options); // Have we specified collation

      try {
        (0, utils_1.decorateWithCollation)(cmd, coll, options);
      } catch (err) {
        return callback(err);
      }

      _get(_getPrototypeOf(DistinctOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err, result) {
        if (err) {
          callback(err);
          return;
        }

        callback(undefined, _this2.explain ? result : result.values);
      });
    }
  }]);

  return DistinctOperation;
}(command_1.CommandOperation);

exports.DistinctOperation = DistinctOperation;
(0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);

/***/ }),

/***/ 406:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;

var error_1 = __webpack_require__(9271);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


var DropCollectionOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(DropCollectionOperation, _command_1$CommandOpe);

  var _super = _createSuper(DropCollectionOperation);

  function DropCollectionOperation(db, name) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, DropCollectionOperation);

    _this = _super.call(this, db, options);
    _this.db = db;
    _this.options = options;
    _this.name = name;
    return _this;
  }

  _createClass(DropCollectionOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this2 = this;

      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _a, _b, _c, _d, db, options, name, encryptedFieldsMap, encryptedFields, listCollectionsResult, escCollection, eccCollection, ecocCollection, _i, _arr, collectionName, dropOp;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                db = _this2.db;
                options = _this2.options;
                name = _this2.name;
                encryptedFieldsMap = (_a = db.s.client.options.autoEncryption) === null || _a === void 0 ? void 0 : _a.encryptedFieldsMap;
                encryptedFields = (_b = options.encryptedFields) !== null && _b !== void 0 ? _b : encryptedFieldsMap === null || encryptedFieldsMap === void 0 ? void 0 : encryptedFieldsMap["".concat(db.databaseName, ".").concat(name)];

                if (!(!encryptedFields && encryptedFieldsMap)) {
                  _context.next = 10;
                  break;
                }

                _context.next = 8;
                return db.listCollections({
                  name: name
                }, {
                  nameOnly: false
                }).toArray();

              case 8:
                listCollectionsResult = _context.sent;
                encryptedFields = (_d = (_c = listCollectionsResult === null || listCollectionsResult === void 0 ? void 0 : listCollectionsResult[0]) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.encryptedFields;

              case 10:
                if (!encryptedFields) {
                  _context.next = 30;
                  break;
                }

                escCollection = encryptedFields.escCollection || "enxcol_.".concat(name, ".esc");
                eccCollection = encryptedFields.eccCollection || "enxcol_.".concat(name, ".ecc");
                ecocCollection = encryptedFields.ecocCollection || "enxcol_.".concat(name, ".ecoc");
                _i = 0, _arr = [escCollection, eccCollection, ecocCollection];

              case 15:
                if (!(_i < _arr.length)) {
                  _context.next = 30;
                  break;
                }

                collectionName = _arr[_i];
                // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.
                dropOp = new DropCollectionOperation(db, collectionName);
                _context.prev = 18;
                _context.next = 21;
                return dropOp.executeWithoutEncryptedFieldsCheck(server, session);

              case 21:
                _context.next = 27;
                break;

              case 23:
                _context.prev = 23;
                _context.t0 = _context["catch"](18);

                if (!(!(_context.t0 instanceof error_1.MongoServerError) || _context.t0.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound)) {
                  _context.next = 27;
                  break;
                }

                throw _context.t0;

              case 27:
                _i++;
                _context.next = 15;
                break;

              case 30:
                _context.next = 32;
                return _this2.executeWithoutEncryptedFieldsCheck(server, session);

              case 32:
                return _context.abrupt("return", _context.sent);

              case 33:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[18, 23]]);
      }))().then(function (result) {
        return callback(undefined, result);
      }, function (err) {
        return callback(err);
      });
    }
  }, {
    key: "executeWithoutEncryptedFieldsCheck",
    value: function executeWithoutEncryptedFieldsCheck(server, session) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        _get(_getPrototypeOf(DropCollectionOperation.prototype), "executeCommand", _this3).call(_this3, server, session, {
          drop: _this3.name
        }, function (err, result) {
          if (err) return reject(err);
          resolve(!!result.ok);
        });
      });
    }
  }]);

  return DropCollectionOperation;
}(command_1.CommandOperation);

exports.DropCollectionOperation = DropCollectionOperation;
/** @internal */

var DropDatabaseOperation = /*#__PURE__*/function (_command_1$CommandOpe2) {
  _inherits(DropDatabaseOperation, _command_1$CommandOpe2);

  var _super2 = _createSuper(DropDatabaseOperation);

  function DropDatabaseOperation(db, options) {
    var _this4;

    _classCallCheck(this, DropDatabaseOperation);

    _this4 = _super2.call(this, db, options);
    _this4.options = options;
    return _this4;
  }

  _createClass(DropDatabaseOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      _get(_getPrototypeOf(DropDatabaseOperation.prototype), "executeCommand", this).call(this, server, session, {
        dropDatabase: 1
      }, function (err, result) {
        if (err) return callback(err);
        if (result.ok) return callback(undefined, true);
        callback(undefined, false);
      });
    }
  }]);

  return DropDatabaseOperation;
}(command_1.CommandOperation);

exports.DropDatabaseOperation = DropDatabaseOperation;
(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 2261:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EstimatedDocumentCountOperation = void 0;

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


var EstimatedDocumentCountOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(EstimatedDocumentCountOperation, _command_1$CommandOpe);

  var _super = _createSuper(EstimatedDocumentCountOperation);

  function EstimatedDocumentCountOperation(collection) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EstimatedDocumentCountOperation);

    _this = _super.call(this, collection, options);
    _this.options = options;
    _this.collectionName = collection.collectionName;
    return _this;
  }

  _createClass(EstimatedDocumentCountOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var cmd = {
        count: this.collectionName
      };

      if (typeof this.options.maxTimeMS === 'number') {
        cmd.maxTimeMS = this.options.maxTimeMS;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }

      _get(_getPrototypeOf(EstimatedDocumentCountOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err, response) {
        if (err) {
          callback(err);
          return;
        }

        callback(undefined, (response === null || response === void 0 ? void 0 : response.n) || 0);
      });
    }
  }]);

  return EstimatedDocumentCountOperation;
}(command_1.CommandOperation);

exports.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
(0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);

/***/ }),

/***/ 7887:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.executeOperation = void 0;

var error_1 = __webpack_require__(9271);

var read_preference_1 = __webpack_require__(3985);

var server_selection_1 = __webpack_require__(2557);

var utils_1 = __webpack_require__(4356);

var operation_1 = __webpack_require__(6778);

var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';

function executeOperation(client, operation, callback) {
  if (!(operation instanceof operation_1.AbstractOperation)) {
    // TODO(NODE-3483): Extend MongoRuntimeError
    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');
  }

  return (0, utils_1.maybePromise)(callback, function (callback) {
    var topology = client.topology;

    if (topology == null) {
      if (client.s.hasBeenClosed) {
        return callback(new error_1.MongoNotConnectedError('Client must be connected before running operations'));
      }

      client.s.options[Symbol["for"]('@@mdb.skipPingOnConnect')] = true;
      return client.connect(function (error) {
        delete client.s.options[Symbol["for"]('@@mdb.skipPingOnConnect')];

        if (error) {
          return callback(error);
        }

        return executeOperation(client, operation, callback);
      });
    }

    if (topology.shouldCheckForSessionSupport()) {
      return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, {}, function (err) {
        if (err) return callback(err);
        executeOperation(client, operation, callback);
      });
    } // The driver sessions spec mandates that we implicitly create sessions for operations
    // that are not explicitly provided with a session.


    var session = operation.session;
    var owner;

    if (topology.hasSessionSupport()) {
      if (session == null) {
        owner = Symbol();
        session = client.startSession({
          owner: owner,
          explicit: false
        });
      } else if (session.hasEnded) {
        return callback(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));
      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
        return callback(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));
      }
    } else {
      // no session support
      if (session && session.explicit) {
        // If the user passed an explicit session and we are still, after server selection,
        // trying to run against a topology that doesn't support sessions we error out.
        return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));
      } else if (session && !session.explicit) {
        // We do not have to worry about ending the session because the server session has not been acquired yet
        delete operation.options.session;
        operation.clearSession();
        session = undefined;
      }
    }

    try {
      executeWithServerSelection(topology, session, operation, function (error, result) {
        if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {
          return session.endSession(function (endSessionError) {
            return callback(endSessionError !== null && endSessionError !== void 0 ? endSessionError : error, result);
          });
        }

        callback(error, result);
      });
    } catch (error) {
      if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {
        session.endSession()["catch"](function () {
          return null;
        });
      }

      throw error;
    }
  });
}

exports.executeOperation = executeOperation;

function executeWithServerSelection(topology, session, operation, callback) {
  var _a, _b;

  var readPreference = (_a = operation.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;
  var inTransaction = !!(session === null || session === void 0 ? void 0 : session.inTransaction());

  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {
    return callback(new error_1.MongoTransactionError("Read preference in a transaction must be primary, not: ".concat(readPreference.mode)));
  }

  if ((session === null || session === void 0 ? void 0 : session.isPinned) && session.transaction.isCommitted && !operation.bypassPinningCheck) {
    session.unpin();
  }

  var selector;

  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
    // GetMore and KillCursor operations must always select the same server, but run through
    // server selection to potentially force monitor checks if the server is
    // in an unknown state.
    selector = (0, server_selection_1.sameServerSelector)((_b = operation.server) === null || _b === void 0 ? void 0 : _b.description);
  } else if (operation.trySecondaryWrite) {
    // If operation should try to write to secondary use the custom server selector
    // otherwise provide the read preference.
    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
  } else {
    selector = readPreference;
  }

  var serverSelectionOptions = {
    session: session
  };

  function retryOperation(originalError) {
    var isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
    var isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);

    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
      return callback(new error_1.MongoServerError({
        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        originalError: originalError
      }));
    }

    if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {
      return callback(originalError);
    }

    if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {
      return callback(originalError);
    }

    if (originalError instanceof error_1.MongoNetworkError && (session === null || session === void 0 ? void 0 : session.isPinned) && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {
      // If we have a cursor and the initial command fails with a network error,
      // we can retry it on another connection. So we need to check it back in, clear the
      // pool for the service id, and retry again.
      session.unpin({
        force: true,
        forceClear: true
      });
    } // select a new server, and attempt to retry the operation


    topology.selectServer(selector, serverSelectionOptions, function (error, server) {
      if (!error && isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {
        return callback(new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes'));
      }

      if (error || !server) {
        return callback(error !== null && error !== void 0 ? error : new error_1.MongoUnexpectedServerResponseError('Server selection failed without error'));
      }

      operation.execute(server, session, callback);
    });
  }

  if (readPreference && !readPreference.equals(read_preference_1.ReadPreference.primary) && (session === null || session === void 0 ? void 0 : session.inTransaction())) {
    callback(new error_1.MongoTransactionError("Read preference in a transaction must be primary, not: ".concat(readPreference.mode)));
    return;
  } // select a server, and execute the operation against it


  topology.selectServer(selector, serverSelectionOptions, function (error, server) {
    if (error || !server) {
      return callback(error);
    }

    if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {
      var willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
      var willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;
      var hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
      var hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);

      if (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite) {
        if (hasWriteAspect && willRetryWrite) {
          operation.options.willRetryWrite = true;
          session.incrementTransactionNumber();
        }

        return operation.execute(server, session, function (error, result) {
          if (error instanceof error_1.MongoError) {
            return retryOperation(error);
          } else if (error) {
            return callback(error);
          }

          callback(undefined, result);
        });
      }
    }

    return operation.execute(server, session, callback);
  });
}

/***/ }),

/***/ 8012:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FindOperation = void 0;

var error_1 = __webpack_require__(9271);

var read_concern_1 = __webpack_require__(2027);

var sort_1 = __webpack_require__(7462);

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);

var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
/** @internal */

var FindOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(FindOperation, _command_1$CommandOpe);

  var _super = _createSuper(FindOperation);

  function FindOperation(collection, ns) {
    var _this;

    var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, FindOperation);

    _this = _super.call(this, collection, options);
    _this.options = options;
    _this.ns = ns;

    if (_typeof(filter) !== 'object' || Array.isArray(filter)) {
      throw new error_1.MongoInvalidArgumentError('Query filter must be a plain object or ObjectId');
    } // If the filter is a buffer, validate that is a valid BSON document


    if (Buffer.isBuffer(filter)) {
      var objectSize = filter[0] | filter[1] << 8 | filter[2] << 16 | filter[3] << 24;

      if (objectSize !== filter.length) {
        throw new error_1.MongoInvalidArgumentError("Query filter raw message size does not match message header size [".concat(filter.length, "] != [").concat(objectSize, "]"));
      }
    } // special case passing in an ObjectId as a filter


    _this.filter = filter != null && filter._bsontype === 'ObjectID' ? {
      _id: filter
    } : filter;
    return _this;
  }

  _createClass(FindOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      this.server = server;
      var serverWireVersion = (0, utils_1.maxWireVersion)(server);
      var options = this.options;

      if (options.allowDiskUse != null && serverWireVersion < 4) {
        callback(new error_1.MongoCompatibilityError('Option "allowDiskUse" is not supported on MongoDB < 3.2'));
        return;
      }

      if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
        callback(new error_1.MongoCompatibilityError("Server ".concat(server.name, ", which reports wire version ").concat(serverWireVersion, ", does not support collation")));
        return;
      }

      var findCommand = makeFindCommand(this.ns, this.filter, options);

      if (this.explain) {
        findCommand = (0, utils_1.decorateWithExplain)(findCommand, this.explain);
      }

      server.command(this.ns, findCommand, _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {
        documentsReturnedIn: 'firstBatch',
        session: session
      }), callback);
    }
  }]);

  return FindOperation;
}(command_1.CommandOperation);

exports.FindOperation = FindOperation;

function makeFindCommand(ns, filter, options) {
  var findCommand = {
    find: ns.collection,
    filter: filter
  };

  if (options.sort) {
    findCommand.sort = (0, sort_1.formatSort)(options.sort);
  }

  if (options.projection) {
    var projection = options.projection;

    if (projection && Array.isArray(projection)) {
      projection = projection.length ? projection.reduce(function (result, field) {
        result[field] = 1;
        return result;
      }, {}) : {
        _id: 1
      };
    }

    findCommand.projection = projection;
  }

  if (options.hint) {
    findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);
  }

  if (typeof options.skip === 'number') {
    findCommand.skip = options.skip;
  }

  if (typeof options.limit === 'number') {
    if (options.limit < 0) {
      findCommand.limit = -options.limit;
      findCommand.singleBatch = true;
    } else {
      findCommand.limit = options.limit;
    }
  }

  if (typeof options.batchSize === 'number') {
    if (options.batchSize < 0) {
      if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {
        findCommand.limit = -options.batchSize;
      }

      findCommand.singleBatch = true;
    } else {
      findCommand.batchSize = options.batchSize;
    }
  }

  if (typeof options.singleBatch === 'boolean') {
    findCommand.singleBatch = options.singleBatch;
  } // we check for undefined specifically here to allow falsy values
  // eslint-disable-next-line no-restricted-syntax


  if (options.comment !== undefined) {
    findCommand.comment = options.comment;
  }

  if (typeof options.maxTimeMS === 'number') {
    findCommand.maxTimeMS = options.maxTimeMS;
  }

  var readConcern = read_concern_1.ReadConcern.fromOptions(options);

  if (readConcern) {
    findCommand.readConcern = readConcern.toJSON();
  }

  if (options.max) {
    findCommand.max = options.max;
  }

  if (options.min) {
    findCommand.min = options.min;
  }

  if (typeof options.returnKey === 'boolean') {
    findCommand.returnKey = options.returnKey;
  }

  if (typeof options.showRecordId === 'boolean') {
    findCommand.showRecordId = options.showRecordId;
  }

  if (typeof options.tailable === 'boolean') {
    findCommand.tailable = options.tailable;
  }

  if (typeof options.oplogReplay === 'boolean') {
    findCommand.oplogReplay = options.oplogReplay;
  }

  if (typeof options.timeout === 'boolean') {
    findCommand.noCursorTimeout = !options.timeout;
  } else if (typeof options.noCursorTimeout === 'boolean') {
    findCommand.noCursorTimeout = options.noCursorTimeout;
  }

  if (typeof options.awaitData === 'boolean') {
    findCommand.awaitData = options.awaitData;
  }

  if (typeof options.allowPartialResults === 'boolean') {
    findCommand.allowPartialResults = options.allowPartialResults;
  }

  if (options.collation) {
    findCommand.collation = options.collation;
  }

  if (typeof options.allowDiskUse === 'boolean') {
    findCommand.allowDiskUse = options.allowDiskUse;
  }

  if (options["let"]) {
    findCommand["let"] = options["let"];
  }

  return findCommand;
}

(0, operation_1.defineAspects)(FindOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);

/***/ }),

/***/ 2016:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.ReturnDocument = void 0;

var error_1 = __webpack_require__(9271);

var read_preference_1 = __webpack_require__(3985);

var sort_1 = __webpack_require__(7462);

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @public */


exports.ReturnDocument = Object.freeze({
  BEFORE: 'before',
  AFTER: 'after'
});

function configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options) {
  cmdBase["new"] = options.returnDocument === exports.ReturnDocument.AFTER;
  cmdBase.upsert = options.upsert === true;

  if (options.bypassDocumentValidation === true) {
    cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;
  }

  return cmdBase;
}
/** @internal */


var FindAndModifyOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(FindAndModifyOperation, _command_1$CommandOpe);

  var _super = _createSuper(FindAndModifyOperation);

  function FindAndModifyOperation(collection, query, options) {
    var _this;

    _classCallCheck(this, FindAndModifyOperation);

    _this = _super.call(this, collection, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.cmdBase = {
      remove: false,
      "new": false,
      upsert: false
    };
    var sort = (0, sort_1.formatSort)(options.sort);

    if (sort) {
      _this.cmdBase.sort = sort;
    }

    if (options.projection) {
      _this.cmdBase.fields = options.projection;
    }

    if (options.maxTimeMS) {
      _this.cmdBase.maxTimeMS = options.maxTimeMS;
    } // Decorate the findAndModify command with the write Concern


    if (options.writeConcern) {
      _this.cmdBase.writeConcern = options.writeConcern;
    }

    if (options["let"]) {
      _this.cmdBase["let"] = options["let"];
    } // we check for undefined specifically here to allow falsy values
    // eslint-disable-next-line no-restricted-syntax


    if (options.comment !== undefined) {
      _this.cmdBase.comment = options.comment;
    } // force primary read preference


    _this.readPreference = read_preference_1.ReadPreference.primary;
    _this.collection = collection;
    _this.query = query;
    return _this;
  }

  _createClass(FindAndModifyOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _a;

      var coll = this.collection;
      var query = this.query;

      var options = _objectSpread(_objectSpread({}, this.options), this.bsonOptions); // Create findAndModify command object


      var cmd = _objectSpread({
        findAndModify: coll.collectionName,
        query: query
      }, this.cmdBase); // Have we specified collation


      try {
        (0, utils_1.decorateWithCollation)(cmd, coll, options);
      } catch (err) {
        return callback(err);
      }

      if (options.hint) {
        // TODO: once this method becomes a CommandOperation we will have the server
        // in place to check.
        var unacknowledgedWrite = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) === 0;

        if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {
          callback(new error_1.MongoCompatibilityError('The current topology does not support a hint on findAndModify commands'));
          return;
        }

        cmd.hint = options.hint;
      }

      if (this.explain && (0, utils_1.maxWireVersion)(server) < 4) {
        callback(new error_1.MongoCompatibilityError("Server ".concat(server.name, " does not support explain on findAndModify")));
        return;
      } // Execute the command


      _get(_getPrototypeOf(FindAndModifyOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err, result) {
        if (err) return callback(err);
        return callback(undefined, result);
      });
    }
  }]);

  return FindAndModifyOperation;
}(command_1.CommandOperation);
/** @internal */


var FindOneAndDeleteOperation = /*#__PURE__*/function (_FindAndModifyOperati) {
  _inherits(FindOneAndDeleteOperation, _FindAndModifyOperati);

  var _super2 = _createSuper(FindOneAndDeleteOperation);

  function FindOneAndDeleteOperation(collection, filter, options) {
    var _this2;

    _classCallCheck(this, FindOneAndDeleteOperation);

    // Basic validation
    if (filter == null || _typeof(filter) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
    }

    _this2 = _super2.call(this, collection, filter, options);
    _this2.cmdBase.remove = true;
    return _this2;
  }

  return _createClass(FindOneAndDeleteOperation);
}(FindAndModifyOperation);

exports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;
/** @internal */

var FindOneAndReplaceOperation = /*#__PURE__*/function (_FindAndModifyOperati2) {
  _inherits(FindOneAndReplaceOperation, _FindAndModifyOperati2);

  var _super3 = _createSuper(FindOneAndReplaceOperation);

  function FindOneAndReplaceOperation(collection, filter, replacement, options) {
    var _this3;

    _classCallCheck(this, FindOneAndReplaceOperation);

    if (filter == null || _typeof(filter) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
    }

    if (replacement == null || _typeof(replacement) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
    }

    if ((0, utils_1.hasAtomicOperators)(replacement)) {
      throw new error_1.MongoInvalidArgumentError('Replacement document must not contain atomic operators');
    }

    _this3 = _super3.call(this, collection, filter, options);
    _this3.cmdBase.update = replacement;
    configureFindAndModifyCmdBaseUpdateOpts(_this3.cmdBase, options);
    return _this3;
  }

  return _createClass(FindOneAndReplaceOperation);
}(FindAndModifyOperation);

exports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;
/** @internal */

var FindOneAndUpdateOperation = /*#__PURE__*/function (_FindAndModifyOperati3) {
  _inherits(FindOneAndUpdateOperation, _FindAndModifyOperati3);

  var _super4 = _createSuper(FindOneAndUpdateOperation);

  function FindOneAndUpdateOperation(collection, filter, update, options) {
    var _this4;

    _classCallCheck(this, FindOneAndUpdateOperation);

    if (filter == null || _typeof(filter) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
    }

    if (update == null || _typeof(update) !== 'object') {
      throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
    }

    if (!(0, utils_1.hasAtomicOperators)(update)) {
      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
    }

    _this4 = _super4.call(this, collection, filter, options);
    _this4.cmdBase.update = update;
    configureFindAndModifyCmdBaseUpdateOpts(_this4.cmdBase, options);

    if (options.arrayFilters) {
      _this4.cmdBase.arrayFilters = options.arrayFilters;
    }

    return _this4;
  }

  return _createClass(FindOneAndUpdateOperation);
}(FindAndModifyOperation);

exports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
(0, operation_1.defineAspects)(FindAndModifyOperation, [operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);

/***/ }),

/***/ 944:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GetMoreOperation = void 0;

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var operation_1 = __webpack_require__(6778);
/** @internal */


var GetMoreOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(GetMoreOperation, _operation_1$Abstract);

  var _super = _createSuper(GetMoreOperation);

  function GetMoreOperation(ns, cursorId, server, options) {
    var _this;

    _classCallCheck(this, GetMoreOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.ns = ns;
    _this.cursorId = cursorId;
    _this.server = server;
    return _this;
  }
  /**
   * Although there is a server already associated with the get more operation, the signature
   * for execute passes a server so we will just use that one.
   */


  _createClass(GetMoreOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      if (server !== this.server) {
        return callback(new error_1.MongoRuntimeError('Getmore must run on the same server operation began on'));
      }

      if (this.cursorId == null || this.cursorId.isZero()) {
        return callback(new error_1.MongoRuntimeError('Unable to iterate cursor with no id'));
      }

      var collection = this.ns.collection;

      if (collection == null) {
        // Cursors should have adopted the namespace returned by MongoDB
        // which should always defined a collection name (even a pseudo one, ex. db.aggregate())
        return callback(new error_1.MongoRuntimeError('A collection name must be determined before getMore'));
      }

      var getMoreCmd = {
        getMore: this.cursorId,
        collection: collection
      };

      if (typeof this.options.batchSize === 'number') {
        getMoreCmd.batchSize = Math.abs(this.options.batchSize);
      }

      if (typeof this.options.maxAwaitTimeMS === 'number') {
        getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (this.options.comment !== undefined && (0, utils_1.maxWireVersion)(server) >= 9) {
        getMoreCmd.comment = this.options.comment;
      }

      var commandOptions = _objectSpread({
        returnFieldSelector: null,
        documentsReturnedIn: 'nextBatch'
      }, this.options);

      server.command(this.ns, getMoreCmd, commandOptions, callback);
    }
  }]);

  return GetMoreOperation;
}(operation_1.AbstractOperation);

exports.GetMoreOperation = GetMoreOperation;
(0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);

/***/ }),

/***/ 6338:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;

var error_1 = __webpack_require__(9271);

var read_preference_1 = __webpack_require__(3985);

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var common_functions_1 = __webpack_require__(475);

var operation_1 = __webpack_require__(6778);

var VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version', // text indexes
'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes
'2dsphereIndexVersion', // 2d indexes
'bits', 'min', 'max', // geoHaystack Indexes
'bucketSize', // wildcard indexes
'wildcardProjection']);

function isIndexDirection(x) {
  return typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack';
}

function isSingleIndexTuple(t) {
  return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);
}

function makeIndexSpec(indexSpec, options) {
  var _a;

  var key = new Map();
  var indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec; // Iterate through array and handle different types

  var _iterator = _createForOfIteratorHelper(indexSpecs),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var spec = _step.value;

      if (typeof spec === 'string') {
        key.set(spec, 1);
      } else if (Array.isArray(spec)) {
        key.set(spec[0], (_a = spec[1]) !== null && _a !== void 0 ? _a : 1);
      } else if (spec instanceof Map) {
        var _iterator2 = _createForOfIteratorHelper(spec),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
                property = _step2$value[0],
                value = _step2$value[1];

            key.set(property, value);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else if ((0, utils_1.isObject)(spec)) {
        for (var _i2 = 0, _Object$entries = Object.entries(spec); _i2 < _Object$entries.length; _i2++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
              _property = _Object$entries$_i[0],
              _value = _Object$entries$_i[1];

          key.set(_property, _value);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return _objectSpread(_objectSpread({}, options), {}, {
    key: key
  });
}
/** @internal */


var IndexesOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(IndexesOperation, _operation_1$Abstract);

  var _super = _createSuper(IndexesOperation);

  function IndexesOperation(collection, options) {
    var _this;

    _classCallCheck(this, IndexesOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.collection = collection;
    return _this;
  }

  _createClass(IndexesOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var coll = this.collection;
      var options = this.options;
      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, _objectSpread(_objectSpread({
        full: true
      }, options), {}, {
        readPreference: this.readPreference,
        session: session
      }), callback);
    }
  }]);

  return IndexesOperation;
}(operation_1.AbstractOperation);

exports.IndexesOperation = IndexesOperation;
/** @internal */

var CreateIndexesOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(CreateIndexesOperation, _command_1$CommandOpe);

  var _super2 = _createSuper(CreateIndexesOperation);

  function CreateIndexesOperation(parent, collectionName, indexes, options) {
    var _this2;

    _classCallCheck(this, CreateIndexesOperation);

    _this2 = _super2.call(this, parent, options);
    _this2.options = options !== null && options !== void 0 ? options : {};
    _this2.collectionName = collectionName;
    _this2.indexes = indexes.map(function (userIndex) {
      // Ensure the key is a Map to preserve index key ordering
      var key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
      var name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join('_');
      var validIndexOptions = Object.fromEntries(Object.entries(_objectSpread({}, userIndex)).filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            optionName = _ref2[0];

        return VALID_INDEX_OPTIONS.has(optionName);
      }));
      return _objectSpread(_objectSpread({}, validIndexOptions), {}, {
        name: name,
        key: key
      });
    });
    return _this2;
  }

  _createClass(CreateIndexesOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var options = this.options;
      var indexes = this.indexes;
      var serverWireVersion = (0, utils_1.maxWireVersion)(server);
      var cmd = {
        createIndexes: this.collectionName,
        indexes: indexes
      };

      if (options.commitQuorum != null) {
        if (serverWireVersion < 9) {
          callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));
          return;
        }

        cmd.commitQuorum = options.commitQuorum;
      } // collation is set on each index, it should not be defined at the root


      this.options.collation = undefined;

      _get(_getPrototypeOf(CreateIndexesOperation.prototype), "executeCommand", this).call(this, server, session, cmd, function (err) {
        if (err) {
          callback(err);
          return;
        }

        var indexNames = indexes.map(function (index) {
          return index.name || '';
        });
        callback(undefined, indexNames);
      });
    }
  }]);

  return CreateIndexesOperation;
}(command_1.CommandOperation);

exports.CreateIndexesOperation = CreateIndexesOperation;
/** @internal */

var CreateIndexOperation = /*#__PURE__*/function (_CreateIndexesOperati) {
  _inherits(CreateIndexOperation, _CreateIndexesOperati);

  var _super3 = _createSuper(CreateIndexOperation);

  function CreateIndexOperation(parent, collectionName, indexSpec, options) {
    _classCallCheck(this, CreateIndexOperation);

    return _super3.call(this, parent, collectionName, [makeIndexSpec(indexSpec, options)], options);
  }

  _createClass(CreateIndexOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      _get(_getPrototypeOf(CreateIndexOperation.prototype), "execute", this).call(this, server, session, function (err, indexNames) {
        if (err || !indexNames) return callback(err);
        return callback(undefined, indexNames[0]);
      });
    }
  }]);

  return CreateIndexOperation;
}(CreateIndexesOperation);

exports.CreateIndexOperation = CreateIndexOperation;
/** @internal */

var EnsureIndexOperation = /*#__PURE__*/function (_CreateIndexOperation) {
  _inherits(EnsureIndexOperation, _CreateIndexOperation);

  var _super4 = _createSuper(EnsureIndexOperation);

  function EnsureIndexOperation(db, collectionName, indexSpec, options) {
    var _this3;

    _classCallCheck(this, EnsureIndexOperation);

    _this3 = _super4.call(this, db, collectionName, indexSpec, options);
    _this3.readPreference = read_preference_1.ReadPreference.primary;
    _this3.db = db;
    _this3.collectionName = collectionName;
    return _this3;
  }

  _createClass(EnsureIndexOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this4 = this;

      var indexName = this.indexes[0].name;
      var cursor = this.db.collection(this.collectionName).listIndexes({
        session: session
      });
      cursor.toArray(function (err, indexes) {
        /// ignore "NamespaceNotFound" errors
        if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
          return callback(err);
        }

        if (indexes) {
          indexes = Array.isArray(indexes) ? indexes : [indexes];

          if (indexes.some(function (index) {
            return index.name === indexName;
          })) {
            callback(undefined, indexName);
            return;
          }
        }

        _get(_getPrototypeOf(EnsureIndexOperation.prototype), "execute", _this4).call(_this4, server, session, callback);
      });
    }
  }]);

  return EnsureIndexOperation;
}(CreateIndexOperation);

exports.EnsureIndexOperation = EnsureIndexOperation;
/** @internal */

var DropIndexOperation = /*#__PURE__*/function (_command_1$CommandOpe2) {
  _inherits(DropIndexOperation, _command_1$CommandOpe2);

  var _super5 = _createSuper(DropIndexOperation);

  function DropIndexOperation(collection, indexName, options) {
    var _this5;

    _classCallCheck(this, DropIndexOperation);

    _this5 = _super5.call(this, collection, options);
    _this5.options = options !== null && options !== void 0 ? options : {};
    _this5.collection = collection;
    _this5.indexName = indexName;
    return _this5;
  }

  _createClass(DropIndexOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var cmd = {
        dropIndexes: this.collection.collectionName,
        index: this.indexName
      };

      _get(_getPrototypeOf(DropIndexOperation.prototype), "executeCommand", this).call(this, server, session, cmd, callback);
    }
  }]);

  return DropIndexOperation;
}(command_1.CommandOperation);

exports.DropIndexOperation = DropIndexOperation;
/** @internal */

var DropIndexesOperation = /*#__PURE__*/function (_DropIndexOperation) {
  _inherits(DropIndexesOperation, _DropIndexOperation);

  var _super6 = _createSuper(DropIndexesOperation);

  function DropIndexesOperation(collection, options) {
    _classCallCheck(this, DropIndexesOperation);

    return _super6.call(this, collection, '*', options);
  }

  _createClass(DropIndexesOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      _get(_getPrototypeOf(DropIndexesOperation.prototype), "execute", this).call(this, server, session, function (err) {
        if (err) return callback(err, false);
        callback(undefined, true);
      });
    }
  }]);

  return DropIndexesOperation;
}(DropIndexOperation);

exports.DropIndexesOperation = DropIndexesOperation;
/** @internal */

var ListIndexesOperation = /*#__PURE__*/function (_command_1$CommandOpe3) {
  _inherits(ListIndexesOperation, _command_1$CommandOpe3);

  var _super7 = _createSuper(ListIndexesOperation);

  function ListIndexesOperation(collection, options) {
    var _this6;

    _classCallCheck(this, ListIndexesOperation);

    _this6 = _super7.call(this, collection, options);
    _this6.options = options !== null && options !== void 0 ? options : {};
    _this6.collectionNamespace = collection.s.namespace;
    return _this6;
  }

  _createClass(ListIndexesOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var serverWireVersion = (0, utils_1.maxWireVersion)(server);
      var cursor = this.options.batchSize ? {
        batchSize: this.options.batchSize
      } : {};
      var command = {
        listIndexes: this.collectionNamespace.collection,
        cursor: cursor
      }; // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax

      if (serverWireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }

      _get(_getPrototypeOf(ListIndexesOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return ListIndexesOperation;
}(command_1.CommandOperation);

exports.ListIndexesOperation = ListIndexesOperation;
/** @internal */

var IndexExistsOperation = /*#__PURE__*/function (_operation_1$Abstract2) {
  _inherits(IndexExistsOperation, _operation_1$Abstract2);

  var _super8 = _createSuper(IndexExistsOperation);

  function IndexExistsOperation(collection, indexes, options) {
    var _this7;

    _classCallCheck(this, IndexExistsOperation);

    _this7 = _super8.call(this, options);
    _this7.options = options;
    _this7.collection = collection;
    _this7.indexes = indexes;
    return _this7;
  }

  _createClass(IndexExistsOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var coll = this.collection;
      var indexes = this.indexes;
      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, _objectSpread(_objectSpread({}, this.options), {}, {
        readPreference: this.readPreference,
        session: session
      }), function (err, indexInformation) {
        // If we have an error return
        if (err != null) return callback(err); // Let's check for the index names

        if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null); // Check in list of indexes

        for (var i = 0; i < indexes.length; i++) {
          if (indexInformation[indexes[i]] == null) {
            return callback(undefined, false);
          }
        } // All keys found return true


        return callback(undefined, true);
      });
    }
  }]);

  return IndexExistsOperation;
}(operation_1.AbstractOperation);

exports.IndexExistsOperation = IndexExistsOperation;
/** @internal */

var IndexInformationOperation = /*#__PURE__*/function (_operation_1$Abstract3) {
  _inherits(IndexInformationOperation, _operation_1$Abstract3);

  var _super9 = _createSuper(IndexInformationOperation);

  function IndexInformationOperation(db, name, options) {
    var _this8;

    _classCallCheck(this, IndexInformationOperation);

    _this8 = _super9.call(this, options);
    _this8.options = options !== null && options !== void 0 ? options : {};
    _this8.db = db;
    _this8.name = name;
    return _this8;
  }

  _createClass(IndexInformationOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var db = this.db;
      var name = this.name;
      (0, common_functions_1.indexInformation)(db, name, _objectSpread(_objectSpread({}, this.options), {}, {
        readPreference: this.readPreference,
        session: session
      }), callback);
    }
  }]);

  return IndexInformationOperation;
}(operation_1.AbstractOperation);

exports.IndexInformationOperation = IndexInformationOperation;
(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);
(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 2330:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;

var error_1 = __webpack_require__(9271);

var write_concern_1 = __webpack_require__(1473);

var bulk_write_1 = __webpack_require__(492);

var command_1 = __webpack_require__(2124);

var common_functions_1 = __webpack_require__(475);

var operation_1 = __webpack_require__(6778);
/** @internal */


var InsertOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(InsertOperation, _command_1$CommandOpe);

  var _super = _createSuper(InsertOperation);

  function InsertOperation(ns, documents, options) {
    var _this;

    _classCallCheck(this, InsertOperation);

    var _a;

    _this = _super.call(this, undefined, options);
    _this.options = _objectSpread(_objectSpread({}, options), {}, {
      checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false
    });
    _this.ns = ns;
    _this.documents = documents;
    return _this;
  }

  _createClass(InsertOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _a;

      var options = (_a = this.options) !== null && _a !== void 0 ? _a : {};
      var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
      var command = {
        insert: this.ns.collection,
        documents: this.documents,
        ordered: ordered
      };

      if (typeof options.bypassDocumentValidation === 'boolean') {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (options.comment !== undefined) {
        command.comment = options.comment;
      }

      _get(_getPrototypeOf(InsertOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return InsertOperation;
}(command_1.CommandOperation);

exports.InsertOperation = InsertOperation;

var InsertOneOperation = /*#__PURE__*/function (_InsertOperation) {
  _inherits(InsertOneOperation, _InsertOperation);

  var _super2 = _createSuper(InsertOneOperation);

  function InsertOneOperation(collection, doc, options) {
    _classCallCheck(this, InsertOneOperation);

    return _super2.call(this, collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);
  }

  _createClass(InsertOneOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this2 = this;

      _get(_getPrototypeOf(InsertOneOperation.prototype), "execute", this).call(this, server, session, function (err, res) {
        var _a, _b;

        if (err || res == null) return callback(err);
        if (res.code) return callback(new error_1.MongoServerError(res));

        if (res.writeErrors) {
          // This should be a WriteError but we can't change it now because of error hierarchy
          return callback(new error_1.MongoServerError(res.writeErrors[0]));
        }

        callback(undefined, {
          acknowledged: (_b = ((_a = _this2.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
          insertedId: _this2.documents[0]._id
        });
      });
    }
  }]);

  return InsertOneOperation;
}(InsertOperation);

exports.InsertOneOperation = InsertOneOperation;
/** @internal */

var InsertManyOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(InsertManyOperation, _operation_1$Abstract);

  var _super3 = _createSuper(InsertManyOperation);

  function InsertManyOperation(collection, docs, options) {
    var _this3;

    _classCallCheck(this, InsertManyOperation);

    _this3 = _super3.call(this, options);

    if (!Array.isArray(docs)) {
      throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
    }

    _this3.options = options;
    _this3.collection = collection;
    _this3.docs = docs;
    return _this3;
  }

  _createClass(InsertManyOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var coll = this.collection;

      var options = _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {
        readPreference: this.readPreference
      });

      var writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      var bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(function (document) {
        return {
          insertOne: {
            document: document
          }
        };
      }), options);
      bulkWriteOperation.execute(server, session, function (err, res) {
        var _a;

        if (err || res == null) {
          if (err && err.message === 'Operation must be an object with an operation key') {
            err = new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');
          }

          return callback(err);
        }

        callback(undefined, {
          acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,
          insertedCount: res.insertedCount,
          insertedIds: res.insertedIds
        });
      });
    }
  }]);

  return InsertManyOperation;
}(operation_1.AbstractOperation);

exports.InsertManyOperation = InsertManyOperation;
(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 5707:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IsCappedOperation = void 0;

var error_1 = __webpack_require__(9271);

var operation_1 = __webpack_require__(6778);
/** @internal */


var IsCappedOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(IsCappedOperation, _operation_1$Abstract);

  var _super = _createSuper(IsCappedOperation);

  function IsCappedOperation(collection, options) {
    var _this;

    _classCallCheck(this, IsCappedOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.collection = collection;
    return _this;
  }

  _createClass(IsCappedOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var coll = this.collection;
      coll.s.db.listCollections({
        name: coll.collectionName
      }, _objectSpread(_objectSpread({}, this.options), {}, {
        nameOnly: false,
        readPreference: this.readPreference,
        session: session
      })).toArray(function (err, collections) {
        if (err || !collections) return callback(err);

        if (collections.length === 0) {
          // TODO(NODE-3485)
          return callback(new error_1.MongoAPIError("collection ".concat(coll.namespace, " not found")));
        }

        var collOptions = collections[0].options;
        callback(undefined, !!(collOptions && collOptions.capped));
      });
    }
  }]);

  return IsCappedOperation;
}(operation_1.AbstractOperation);

exports.IsCappedOperation = IsCappedOperation;

/***/ }),

/***/ 262:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.KillCursorsOperation = void 0;

var error_1 = __webpack_require__(9271);

var operation_1 = __webpack_require__(6778);

var KillCursorsOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(KillCursorsOperation, _operation_1$Abstract);

  var _super = _createSuper(KillCursorsOperation);

  function KillCursorsOperation(cursorId, ns, server, options) {
    var _this;

    _classCallCheck(this, KillCursorsOperation);

    _this = _super.call(this, options);
    _this.ns = ns;
    _this.cursorId = cursorId;
    _this.server = server;
    return _this;
  }

  _createClass(KillCursorsOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      if (server !== this.server) {
        return callback(new error_1.MongoRuntimeError('Killcursor must run on the same server operation began on'));
      }

      var killCursors = this.ns.collection;

      if (killCursors == null) {
        // Cursors should have adopted the namespace returned by MongoDB
        // which should always defined a collection name (even a pseudo one, ex. db.aggregate())
        return callback(new error_1.MongoRuntimeError('A collection name must be determined before killCursors'));
      }

      var killCursorsCommand = {
        killCursors: killCursors,
        cursors: [this.cursorId]
      };
      server.command(this.ns, killCursorsCommand, {
        session: session
      }, function () {
        return callback();
      });
    }
  }]);

  return KillCursorsOperation;
}(operation_1.AbstractOperation);

exports.KillCursorsOperation = KillCursorsOperation;
(0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);

/***/ }),

/***/ 3949:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ListCollectionsOperation = void 0;

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


var ListCollectionsOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(ListCollectionsOperation, _command_1$CommandOpe);

  var _super = _createSuper(ListCollectionsOperation);

  function ListCollectionsOperation(db, filter, options) {
    var _this;

    _classCallCheck(this, ListCollectionsOperation);

    _this = _super.call(this, db, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.db = db;
    _this.filter = filter;
    _this.nameOnly = !!_this.options.nameOnly;
    _this.authorizedCollections = !!_this.options.authorizedCollections;

    if (typeof _this.options.batchSize === 'number') {
      _this.batchSize = _this.options.batchSize;
    }

    return _this;
  }

  _createClass(ListCollectionsOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      return _get(_getPrototypeOf(ListCollectionsOperation.prototype), "executeCommand", this).call(this, server, session, this.generateCommand((0, utils_1.maxWireVersion)(server)), callback);
    }
    /* This is here for the purpose of unit testing the final command that gets sent. */

  }, {
    key: "generateCommand",
    value: function generateCommand(wireVersion) {
      var command = {
        listCollections: 1,
        filter: this.filter,
        cursor: this.batchSize ? {
          batchSize: this.batchSize
        } : {},
        nameOnly: this.nameOnly,
        authorizedCollections: this.authorizedCollections
      }; // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax

      if (wireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }

      return command;
    }
  }]);

  return ListCollectionsOperation;
}(command_1.CommandOperation);

exports.ListCollectionsOperation = ListCollectionsOperation;
(0, operation_1.defineAspects)(ListCollectionsOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);

/***/ }),

/***/ 8529:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ListDatabasesOperation = void 0;

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


var ListDatabasesOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(ListDatabasesOperation, _command_1$CommandOpe);

  var _super = _createSuper(ListDatabasesOperation);

  function ListDatabasesOperation(db, options) {
    var _this;

    _classCallCheck(this, ListDatabasesOperation);

    _this = _super.call(this, db, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.ns = new utils_1.MongoDBNamespace('admin', '$cmd');
    return _this;
  }

  _createClass(ListDatabasesOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var cmd = {
        listDatabases: 1
      };

      if (this.options.nameOnly) {
        cmd.nameOnly = Number(cmd.nameOnly);
      }

      if (this.options.filter) {
        cmd.filter = this.options.filter;
      }

      if (typeof this.options.authorizedDatabases === 'boolean') {
        cmd.authorizedDatabases = this.options.authorizedDatabases;
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if ((0, utils_1.maxWireVersion)(server) >= 9 && this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }

      _get(_getPrototypeOf(ListDatabasesOperation.prototype), "executeCommand", this).call(this, server, session, cmd, callback);
    }
  }]);

  return ListDatabasesOperation;
}(command_1.CommandOperation);

exports.ListDatabasesOperation = ListDatabasesOperation;
(0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);

/***/ }),

/***/ 8600:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MapReduceOperation = void 0;

var bson_1 = __webpack_require__(53);

var error_1 = __webpack_require__(9271);

var read_preference_1 = __webpack_require__(3985);

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);

var exclusionList = ['explain', 'readPreference', 'readConcern', 'session', 'bypassDocumentValidation', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation', 'scope' // this option is reformatted thus exclude the original
];
/**
 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
 * @internal
 */

var MapReduceOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(MapReduceOperation, _command_1$CommandOpe);

  var _super = _createSuper(MapReduceOperation);

  /**
   * Constructs a MapReduce operation.
   *
   * @param collection - Collection instance.
   * @param map - The mapping function.
   * @param reduce - The reduce function.
   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.
   */
  function MapReduceOperation(collection, map, reduce, options) {
    var _this;

    _classCallCheck(this, MapReduceOperation);

    _this = _super.call(this, collection, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.collection = collection;
    _this.map = map;
    _this.reduce = reduce;
    return _this;
  }

  _createClass(MapReduceOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this2 = this;

      var coll = this.collection;
      var map = this.map;
      var reduce = this.reduce;
      var options = this.options;
      var mapCommandHash = {
        mapReduce: coll.collectionName,
        map: map,
        reduce: reduce
      };

      if (options.scope) {
        mapCommandHash.scope = processScope(options.scope);
      } // Add any other options passed in


      for (var n in options) {
        // Only include if not in exclusion list
        if (exclusionList.indexOf(n) === -1) {
          mapCommandHash[n] = options[n];
        }
      }

      options = Object.assign({}, options); // If we have a read preference and inline is not set as output fail hard

      if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== 'inline') {
        // Force readPreference to primary
        options.readPreference = read_preference_1.ReadPreference.primary; // Decorate command with writeConcern if supported

        (0, utils_1.applyWriteConcern)(mapCommandHash, {
          db: coll.s.db,
          collection: coll
        }, options);
      } else {
        (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);
      } // Is bypassDocumentValidation specified


      if (options.bypassDocumentValidation === true) {
        mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
      } // Have we specified collation


      try {
        (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);
      } catch (err) {
        return callback(err);
      }

      if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {
        callback(new error_1.MongoCompatibilityError("Server ".concat(server.name, " does not support explain on mapReduce")));
        return;
      } // Execute command


      _get(_getPrototypeOf(MapReduceOperation.prototype), "executeCommand", this).call(this, server, session, mapCommandHash, function (err, result) {
        if (err) return callback(err); // Check if we have an error

        if (1 !== result.ok || result.err || result.errmsg) {
          return callback(new error_1.MongoServerError(result));
        } // If an explain option was executed, don't process the server results


        if (_this2.explain) return callback(undefined, result); // Create statistics value

        var stats = {};
        if (result.timeMillis) stats['processtime'] = result.timeMillis;
        if (result.counts) stats['counts'] = result.counts;
        if (result.timing) stats['timing'] = result.timing; // invoked with inline?

        if (result.results) {
          // If we wish for no verbosity
          if (options['verbose'] == null || !options['verbose']) {
            return callback(undefined, result.results);
          }

          return callback(undefined, {
            results: result.results,
            stats: stats
          });
        } // The returned collection


        var collection = null; // If we have an object it's a different db

        if (result.result != null && _typeof(result.result) === 'object') {
          var doc = result.result; // Return a collection from another db

          collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);
        } else {
          // Create a collection object that wraps the result collection
          collection = coll.s.db.collection(result.result);
        } // If we wish for no verbosity


        if (options['verbose'] == null || !options['verbose']) {
          return callback(err, collection);
        } // Return stats as third set of values


        callback(err, {
          collection: collection,
          stats: stats
        });
      });
    }
  }]);

  return MapReduceOperation;
}(command_1.CommandOperation);

exports.MapReduceOperation = MapReduceOperation;
/** Functions that are passed as scope args must be converted to Code instances. */

function processScope(scope) {
  if (!(0, utils_1.isObject)(scope) || scope._bsontype === 'ObjectID') {
    return scope;
  }

  var newScope = {};

  for (var _i = 0, _Object$keys = Object.keys(scope); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if ('function' === typeof scope[key]) {
      newScope[key] = new bson_1.Code(String(scope[key]));
    } else if (scope[key]._bsontype === 'Code') {
      newScope[key] = scope[key];
    } else {
      newScope[key] = processScope(scope[key]);
    }
  }

  return newScope;
}

(0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);

/***/ }),

/***/ 6778:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defineAspects = exports.AbstractOperation = exports.Aspect = void 0;

var bson_1 = __webpack_require__(53);

var read_preference_1 = __webpack_require__(3985);

exports.Aspect = {
  READ_OPERATION: Symbol('READ_OPERATION'),
  WRITE_OPERATION: Symbol('WRITE_OPERATION'),
  RETRYABLE: Symbol('RETRYABLE'),
  EXPLAINABLE: Symbol('EXPLAINABLE'),
  SKIP_COLLATION: Symbol('SKIP_COLLATION'),
  CURSOR_CREATING: Symbol('CURSOR_CREATING'),
  MUST_SELECT_SAME_SERVER: Symbol('MUST_SELECT_SAME_SERVER')
};
/** @internal */

var kSession = Symbol('session');
/**
 * This class acts as a parent class for any operation and is responsible for setting this.options,
 * as well as setting and getting a session.
 * Additionally, this class implements `hasAspect`, which determines whether an operation has
 * a specific aspect.
 * @internal
 */

var AbstractOperation = /*#__PURE__*/function () {
  function AbstractOperation() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AbstractOperation);

    var _a;

    this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : (_a = read_preference_1.ReadPreference.fromOptions(options)) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary; // Pull the BSON serialize options from the already-resolved options

    this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);
    this[kSession] = options.session != null ? options.session : undefined;
    this.options = options;
    this.bypassPinningCheck = !!options.bypassPinningCheck;
    this.trySecondaryWrite = false;
  }

  _createClass(AbstractOperation, [{
    key: "hasAspect",
    value: function hasAspect(aspect) {
      var ctor = this.constructor;

      if (ctor.aspects == null) {
        return false;
      }

      return ctor.aspects.has(aspect);
    }
  }, {
    key: "session",
    get: function get() {
      return this[kSession];
    }
  }, {
    key: "clearSession",
    value: function clearSession() {
      this[kSession] = undefined;
    }
  }, {
    key: "canRetryRead",
    get: function get() {
      return true;
    }
  }, {
    key: "canRetryWrite",
    get: function get() {
      return true;
    }
  }]);

  return AbstractOperation;
}();

exports.AbstractOperation = AbstractOperation;

function defineAspects(operation, aspects) {
  if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
    aspects = [aspects];
  }

  aspects = new Set(aspects);
  Object.defineProperty(operation, 'aspects', {
    value: aspects,
    writable: false
  });
  return aspects;
}

exports.defineAspects = defineAspects;

/***/ }),

/***/ 2320:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OptionsOperation = void 0;

var error_1 = __webpack_require__(9271);

var operation_1 = __webpack_require__(6778);
/** @internal */


var OptionsOperation = /*#__PURE__*/function (_operation_1$Abstract) {
  _inherits(OptionsOperation, _operation_1$Abstract);

  var _super = _createSuper(OptionsOperation);

  function OptionsOperation(collection, options) {
    var _this;

    _classCallCheck(this, OptionsOperation);

    _this = _super.call(this, options);
    _this.options = options;
    _this.collection = collection;
    return _this;
  }

  _createClass(OptionsOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var coll = this.collection;
      coll.s.db.listCollections({
        name: coll.collectionName
      }, _objectSpread(_objectSpread({}, this.options), {}, {
        nameOnly: false,
        readPreference: this.readPreference,
        session: session
      })).toArray(function (err, collections) {
        if (err || !collections) return callback(err);

        if (collections.length === 0) {
          // TODO(NODE-3485)
          return callback(new error_1.MongoAPIError("collection ".concat(coll.namespace, " not found")));
        }

        callback(err, collections[0].options);
      });
    }
  }]);

  return OptionsOperation;
}(operation_1.AbstractOperation);

exports.OptionsOperation = OptionsOperation;

/***/ }),

/***/ 3215:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProfilingLevelOperation = void 0;

var error_1 = __webpack_require__(9271);

var command_1 = __webpack_require__(2124);
/** @internal */


var ProfilingLevelOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(ProfilingLevelOperation, _command_1$CommandOpe);

  var _super = _createSuper(ProfilingLevelOperation);

  function ProfilingLevelOperation(db, options) {
    var _this;

    _classCallCheck(this, ProfilingLevelOperation);

    _this = _super.call(this, db, options);
    _this.options = options;
    return _this;
  }

  _createClass(ProfilingLevelOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      _get(_getPrototypeOf(ProfilingLevelOperation.prototype), "executeCommand", this).call(this, server, session, {
        profile: -1
      }, function (err, doc) {
        if (err == null && doc.ok === 1) {
          var was = doc.was;
          if (was === 0) return callback(undefined, 'off');
          if (was === 1) return callback(undefined, 'slow_only');
          if (was === 2) return callback(undefined, 'all'); // TODO(NODE-3483)

          return callback(new error_1.MongoRuntimeError("Illegal profiling level value ".concat(was)));
        } else {
          // TODO(NODE-3483): Consider MongoUnexpectedServerResponseError
          err != null ? callback(err) : callback(new error_1.MongoRuntimeError('Error with profile command'));
        }
      });
    }
  }]);

  return ProfilingLevelOperation;
}(command_1.CommandOperation);

exports.ProfilingLevelOperation = ProfilingLevelOperation;

/***/ }),

/***/ 2560:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RemoveUserOperation = void 0;

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


var RemoveUserOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(RemoveUserOperation, _command_1$CommandOpe);

  var _super = _createSuper(RemoveUserOperation);

  function RemoveUserOperation(db, username, options) {
    var _this;

    _classCallCheck(this, RemoveUserOperation);

    _this = _super.call(this, db, options);
    _this.options = options;
    _this.username = username;
    return _this;
  }

  _createClass(RemoveUserOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      _get(_getPrototypeOf(RemoveUserOperation.prototype), "executeCommand", this).call(this, server, session, {
        dropUser: this.username
      }, function (err) {
        callback(err, err ? false : true);
      });
    }
  }]);

  return RemoveUserOperation;
}(command_1.CommandOperation);

exports.RemoveUserOperation = RemoveUserOperation;
(0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 8851:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RenameOperation = void 0;

var collection_1 = __webpack_require__(9730);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var operation_1 = __webpack_require__(6778);

var run_command_1 = __webpack_require__(5367);
/** @internal */


var RenameOperation = /*#__PURE__*/function (_run_command_1$RunAdm) {
  _inherits(RenameOperation, _run_command_1$RunAdm);

  var _super = _createSuper(RenameOperation);

  function RenameOperation(collection, newName, options) {
    var _this;

    _classCallCheck(this, RenameOperation);

    // Check the collection name
    (0, utils_1.checkCollectionName)(newName); // Build the command

    var renameCollection = collection.namespace;
    var toCollection = collection.s.namespace.withCollection(newName).toString();
    var dropTarget = typeof options.dropTarget === 'boolean' ? options.dropTarget : false;
    var cmd = {
      renameCollection: renameCollection,
      to: toCollection,
      dropTarget: dropTarget
    };
    _this = _super.call(this, collection, cmd, options);
    _this.options = options;
    _this.collection = collection;
    _this.newName = newName;
    return _this;
  }

  _createClass(RenameOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this2 = this;

      var coll = this.collection;

      _get(_getPrototypeOf(RenameOperation.prototype), "execute", this).call(this, server, session, function (err, doc) {
        if (err) return callback(err); // We have an error

        if (doc === null || doc === void 0 ? void 0 : doc.errmsg) {
          return callback(new error_1.MongoServerError(doc));
        }

        var newColl;

        try {
          newColl = new collection_1.Collection(coll.s.db, _this2.newName, coll.s.options);
        } catch (err) {
          return callback(err);
        }

        return callback(undefined, newColl);
      });
    }
  }]);

  return RenameOperation;
}(run_command_1.RunAdminCommandOperation);

exports.RenameOperation = RenameOperation;
(0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);

/***/ }),

/***/ 5367:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RunAdminCommandOperation = exports.RunCommandOperation = void 0;

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);
/** @internal */


var RunCommandOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(RunCommandOperation, _command_1$CommandOpe);

  var _super = _createSuper(RunCommandOperation);

  function RunCommandOperation(parent, command, options) {
    var _this;

    _classCallCheck(this, RunCommandOperation);

    _this = _super.call(this, parent, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.command = command;
    return _this;
  }

  _createClass(RunCommandOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var command = this.command;
      this.executeCommand(server, session, command, callback);
    }
  }]);

  return RunCommandOperation;
}(command_1.CommandOperation);

exports.RunCommandOperation = RunCommandOperation;

var RunAdminCommandOperation = /*#__PURE__*/function (_RunCommandOperation) {
  _inherits(RunAdminCommandOperation, _RunCommandOperation);

  var _super2 = _createSuper(RunAdminCommandOperation);

  function RunAdminCommandOperation(parent, command, options) {
    var _this2;

    _classCallCheck(this, RunAdminCommandOperation);

    _this2 = _super2.call(this, parent, command, options);
    _this2.ns = new utils_1.MongoDBNamespace('admin');
    return _this2;
  }

  return _createClass(RunAdminCommandOperation);
}(RunCommandOperation);

exports.RunAdminCommandOperation = RunAdminCommandOperation;

/***/ }),

/***/ 7230:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SetProfilingLevelOperation = exports.ProfilingLevel = void 0;

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var levelValues = new Set(['off', 'slow_only', 'all']);
/** @public */

exports.ProfilingLevel = Object.freeze({
  off: 'off',
  slowOnly: 'slow_only',
  all: 'all'
});
/** @internal */

var SetProfilingLevelOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(SetProfilingLevelOperation, _command_1$CommandOpe);

  var _super = _createSuper(SetProfilingLevelOperation);

  function SetProfilingLevelOperation(db, level, options) {
    var _this;

    _classCallCheck(this, SetProfilingLevelOperation);

    _this = _super.call(this, db, options);
    _this.options = options;

    switch (level) {
      case exports.ProfilingLevel.off:
        _this.profile = 0;
        break;

      case exports.ProfilingLevel.slowOnly:
        _this.profile = 1;
        break;

      case exports.ProfilingLevel.all:
        _this.profile = 2;
        break;

      default:
        _this.profile = 0;
        break;
    }

    _this.level = level;
    return _this;
  }

  _createClass(SetProfilingLevelOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var level = this.level;

      if (!levelValues.has(level)) {
        return callback(new error_1.MongoInvalidArgumentError("Profiling level must be one of \"".concat((0, utils_1.enumToString)(exports.ProfilingLevel), "\"")));
      } // TODO(NODE-3483): Determine error to put here


      _get(_getPrototypeOf(SetProfilingLevelOperation.prototype), "executeCommand", this).call(this, server, session, {
        profile: this.profile
      }, function (err, doc) {
        if (err == null && doc.ok === 1) return callback(undefined, level);
        return err != null ? callback(err) : callback(new error_1.MongoRuntimeError('Error with profile command'));
      });
    }
  }]);

  return SetProfilingLevelOperation;
}(command_1.CommandOperation);

exports.SetProfilingLevelOperation = SetProfilingLevelOperation;

/***/ }),

/***/ 9073:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DbStatsOperation = exports.CollStatsOperation = void 0;

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/**
 * Get all the collection statistics.
 * @internal
 */


var CollStatsOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(CollStatsOperation, _command_1$CommandOpe);

  var _super = _createSuper(CollStatsOperation);

  /**
   * Construct a Stats operation.
   *
   * @param collection - Collection instance
   * @param options - Optional settings. See Collection.prototype.stats for a list of options.
   */
  function CollStatsOperation(collection, options) {
    var _this;

    _classCallCheck(this, CollStatsOperation);

    _this = _super.call(this, collection, options);
    _this.options = options !== null && options !== void 0 ? options : {};
    _this.collectionName = collection.collectionName;
    return _this;
  }

  _createClass(CollStatsOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var command = {
        collStats: this.collectionName
      };

      if (this.options.scale != null) {
        command.scale = this.options.scale;
      }

      _get(_getPrototypeOf(CollStatsOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return CollStatsOperation;
}(command_1.CommandOperation);

exports.CollStatsOperation = CollStatsOperation;
/** @internal */

var DbStatsOperation = /*#__PURE__*/function (_command_1$CommandOpe2) {
  _inherits(DbStatsOperation, _command_1$CommandOpe2);

  var _super2 = _createSuper(DbStatsOperation);

  function DbStatsOperation(db, options) {
    var _this2;

    _classCallCheck(this, DbStatsOperation);

    _this2 = _super2.call(this, db, options);
    _this2.options = options;
    return _this2;
  }

  _createClass(DbStatsOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var command = {
        dbStats: true
      };

      if (this.options.scale != null) {
        command.scale = this.options.scale;
      }

      _get(_getPrototypeOf(DbStatsOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return DbStatsOperation;
}(command_1.CommandOperation);

exports.DbStatsOperation = DbStatsOperation;
(0, operation_1.defineAspects)(CollStatsOperation, [operation_1.Aspect.READ_OPERATION]);
(0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);

/***/ }),

/***/ 6262:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeUpdateStatement = exports.ReplaceOneOperation = exports.UpdateManyOperation = exports.UpdateOneOperation = exports.UpdateOperation = void 0;

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var command_1 = __webpack_require__(2124);

var operation_1 = __webpack_require__(6778);
/** @internal */


var UpdateOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(UpdateOperation, _command_1$CommandOpe);

  var _super = _createSuper(UpdateOperation);

  function UpdateOperation(ns, statements, options) {
    var _this;

    _classCallCheck(this, UpdateOperation);

    _this = _super.call(this, undefined, options);
    _this.options = options;
    _this.ns = ns;
    _this.statements = statements;
    return _this;
  }

  _createClass(UpdateOperation, [{
    key: "canRetryWrite",
    get: function get() {
      if (_get(_getPrototypeOf(UpdateOperation.prototype), "canRetryWrite", this) === false) {
        return false;
      }

      return this.statements.every(function (op) {
        return op.multi == null || op.multi === false;
      });
    }
  }, {
    key: "execute",
    value: function execute(server, session, callback) {
      var _a;

      var options = (_a = this.options) !== null && _a !== void 0 ? _a : {};
      var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
      var command = {
        update: this.ns.collection,
        updates: this.statements,
        ordered: ordered
      };

      if (typeof options.bypassDocumentValidation === 'boolean') {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }

      if (options["let"]) {
        command["let"] = options["let"];
      } // we check for undefined specifically here to allow falsy values
      // eslint-disable-next-line no-restricted-syntax


      if (options.comment !== undefined) {
        command.comment = options.comment;
      }

      var statementWithCollation = this.statements.find(function (statement) {
        return !!statement.collation;
      });

      if ((0, utils_1.collationNotSupported)(server, options) || statementWithCollation && (0, utils_1.collationNotSupported)(server, statementWithCollation)) {
        callback(new error_1.MongoCompatibilityError("Server ".concat(server.name, " does not support collation")));
        return;
      }

      var unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;

      if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 5) {
        if (this.statements.find(function (o) {
          return o.hint;
        })) {
          callback(new error_1.MongoCompatibilityError("Servers < 3.4 do not support hint on update"));
          return;
        }
      }

      if (this.explain && (0, utils_1.maxWireVersion)(server) < 3) {
        callback(new error_1.MongoCompatibilityError("Server ".concat(server.name, " does not support explain on update")));
        return;
      }

      if (this.statements.some(function (statement) {
        return !!statement.arrayFilters;
      }) && (0, utils_1.maxWireVersion)(server) < 6) {
        callback(new error_1.MongoCompatibilityError('Option "arrayFilters" is only supported on MongoDB 3.6+'));
        return;
      }

      _get(_getPrototypeOf(UpdateOperation.prototype), "executeCommand", this).call(this, server, session, command, callback);
    }
  }]);

  return UpdateOperation;
}(command_1.CommandOperation);

exports.UpdateOperation = UpdateOperation;
/** @internal */

var UpdateOneOperation = /*#__PURE__*/function (_UpdateOperation) {
  _inherits(UpdateOneOperation, _UpdateOperation);

  var _super2 = _createSuper(UpdateOneOperation);

  function UpdateOneOperation(collection, filter, update, options) {
    var _this2;

    _classCallCheck(this, UpdateOneOperation);

    _this2 = _super2.call(this, collection.s.namespace, [makeUpdateStatement(filter, update, _objectSpread(_objectSpread({}, options), {}, {
      multi: false
    }))], options);

    if (!(0, utils_1.hasAtomicOperators)(update)) {
      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
    }

    return _this2;
  }

  _createClass(UpdateOneOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this3 = this;

      _get(_getPrototypeOf(UpdateOneOperation.prototype), "execute", this).call(this, server, session, function (err, res) {
        var _a, _b;

        if (err || !res) return callback(err);
        if (_this3.explain != null) return callback(undefined, res);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        callback(undefined, {
          acknowledged: (_b = ((_a = _this3.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
          modifiedCount: res.nModified != null ? res.nModified : res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        });
      });
    }
  }]);

  return UpdateOneOperation;
}(UpdateOperation);

exports.UpdateOneOperation = UpdateOneOperation;
/** @internal */

var UpdateManyOperation = /*#__PURE__*/function (_UpdateOperation2) {
  _inherits(UpdateManyOperation, _UpdateOperation2);

  var _super3 = _createSuper(UpdateManyOperation);

  function UpdateManyOperation(collection, filter, update, options) {
    var _this4;

    _classCallCheck(this, UpdateManyOperation);

    _this4 = _super3.call(this, collection.s.namespace, [makeUpdateStatement(filter, update, _objectSpread(_objectSpread({}, options), {}, {
      multi: true
    }))], options);

    if (!(0, utils_1.hasAtomicOperators)(update)) {
      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
    }

    return _this4;
  }

  _createClass(UpdateManyOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this5 = this;

      _get(_getPrototypeOf(UpdateManyOperation.prototype), "execute", this).call(this, server, session, function (err, res) {
        var _a, _b;

        if (err || !res) return callback(err);
        if (_this5.explain != null) return callback(undefined, res);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        callback(undefined, {
          acknowledged: (_b = ((_a = _this5.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
          modifiedCount: res.nModified != null ? res.nModified : res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        });
      });
    }
  }]);

  return UpdateManyOperation;
}(UpdateOperation);

exports.UpdateManyOperation = UpdateManyOperation;
/** @internal */

var ReplaceOneOperation = /*#__PURE__*/function (_UpdateOperation3) {
  _inherits(ReplaceOneOperation, _UpdateOperation3);

  var _super4 = _createSuper(ReplaceOneOperation);

  function ReplaceOneOperation(collection, filter, replacement, options) {
    var _this6;

    _classCallCheck(this, ReplaceOneOperation);

    _this6 = _super4.call(this, collection.s.namespace, [makeUpdateStatement(filter, replacement, _objectSpread(_objectSpread({}, options), {}, {
      multi: false
    }))], options);

    if ((0, utils_1.hasAtomicOperators)(replacement)) {
      throw new error_1.MongoInvalidArgumentError('Replacement document must not contain atomic operators');
    }

    return _this6;
  }

  _createClass(ReplaceOneOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var _this7 = this;

      _get(_getPrototypeOf(ReplaceOneOperation.prototype), "execute", this).call(this, server, session, function (err, res) {
        var _a, _b;

        if (err || !res) return callback(err);
        if (_this7.explain != null) return callback(undefined, res);
        if (res.code) return callback(new error_1.MongoServerError(res));
        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));
        callback(undefined, {
          acknowledged: (_b = ((_a = _this7.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
          modifiedCount: res.nModified != null ? res.nModified : res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        });
      });
    }
  }]);

  return ReplaceOneOperation;
}(UpdateOperation);

exports.ReplaceOneOperation = ReplaceOneOperation;

function makeUpdateStatement(filter, update, options) {
  if (filter == null || _typeof(filter) !== 'object') {
    throw new error_1.MongoInvalidArgumentError('Selector must be a valid JavaScript object');
  }

  if (update == null || _typeof(update) !== 'object') {
    throw new error_1.MongoInvalidArgumentError('Document must be a valid JavaScript object');
  }

  var op = {
    q: filter,
    u: update
  };

  if (typeof options.upsert === 'boolean') {
    op.upsert = options.upsert;
  }

  if (options.multi) {
    op.multi = options.multi;
  }

  if (options.hint) {
    op.hint = options.hint;
  }

  if (options.arrayFilters) {
    op.arrayFilters = options.arrayFilters;
  }

  if (options.collation) {
    op.collation = options.collation;
  }

  return op;
}

exports.makeUpdateStatement = makeUpdateStatement;
(0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
(0, operation_1.defineAspects)(UpdateOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);
(0, operation_1.defineAspects)(UpdateManyOperation, [operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);
(0, operation_1.defineAspects)(ReplaceOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);

/***/ }),

/***/ 8716:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ValidateCollectionOperation = void 0;

var error_1 = __webpack_require__(9271);

var command_1 = __webpack_require__(2124);
/** @internal */


var ValidateCollectionOperation = /*#__PURE__*/function (_command_1$CommandOpe) {
  _inherits(ValidateCollectionOperation, _command_1$CommandOpe);

  var _super = _createSuper(ValidateCollectionOperation);

  function ValidateCollectionOperation(admin, collectionName, options) {
    var _this;

    _classCallCheck(this, ValidateCollectionOperation);

    // Decorate command with extra options
    var command = {
      validate: collectionName
    };
    var keys = Object.keys(options);

    for (var i = 0; i < keys.length; i++) {
      if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== 'session') {
        command[keys[i]] = options[keys[i]];
      }
    }

    _this = _super.call(this, admin.s.db, options);
    _this.options = options;
    _this.command = command;
    _this.collectionName = collectionName;
    return _this;
  }

  _createClass(ValidateCollectionOperation, [{
    key: "execute",
    value: function execute(server, session, callback) {
      var collectionName = this.collectionName;

      _get(_getPrototypeOf(ValidateCollectionOperation.prototype), "executeCommand", this).call(this, server, session, this.command, function (err, doc) {
        if (err != null) return callback(err); // TODO(NODE-3483): Replace these with MongoUnexpectedServerResponseError

        if (doc.ok === 0) return callback(new error_1.MongoRuntimeError('Error with validate command'));
        if (doc.result != null && typeof doc.result !== 'string') return callback(new error_1.MongoRuntimeError('Error with validation data'));
        if (doc.result != null && doc.result.match(/exception|corrupt/) != null) return callback(new error_1.MongoRuntimeError("Invalid collection ".concat(collectionName)));
        if (doc.valid != null && !doc.valid) return callback(new error_1.MongoRuntimeError("Invalid collection ".concat(collectionName)));
        return callback(undefined, doc);
      });
    }
  }]);

  return ValidateCollectionOperation;
}(command_1.CommandOperation);

exports.ValidateCollectionOperation = ValidateCollectionOperation;

/***/ }),

/***/ 8912:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PromiseProvider = void 0;

var error_1 = __webpack_require__(9271);
/** @internal */


var kPromise = Symbol('promise');

var store = _defineProperty({}, kPromise, undefined);
/**
 * Global promise store allowing user-provided promises
 * @public
 */


var PromiseProvider = /*#__PURE__*/function () {
  function PromiseProvider() {
    _classCallCheck(this, PromiseProvider);
  }

  _createClass(PromiseProvider, null, [{
    key: "validate",
    value:
    /** Validates the passed in promise library */
    function validate(lib) {
      if (typeof lib !== 'function') throw new error_1.MongoInvalidArgumentError("Promise must be a function, got ".concat(lib));
      return !!lib;
    }
    /** Sets the promise library */

  }, {
    key: "set",
    value: function set(lib) {
      if (!PromiseProvider.validate(lib)) {
        // validate
        return;
      }

      store[kPromise] = lib;
    }
    /** Get the stored promise library, or resolves passed in */

  }, {
    key: "get",
    value: function get() {
      return store[kPromise];
    }
  }]);

  return PromiseProvider;
}();

exports.PromiseProvider = PromiseProvider;
PromiseProvider.set(global.Promise);

/***/ }),

/***/ 2027:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReadConcern = exports.ReadConcernLevel = void 0;
/** @public */

exports.ReadConcernLevel = Object.freeze({
  local: 'local',
  majority: 'majority',
  linearizable: 'linearizable',
  available: 'available',
  snapshot: 'snapshot'
});
/**
 * The MongoDB ReadConcern, which allows for control of the consistency and isolation properties
 * of the data read from replica sets and replica set shards.
 * @public
 *
 * @see https://docs.mongodb.com/manual/reference/read-concern/index.html
 */

var ReadConcern = /*#__PURE__*/function () {
  /** Constructs a ReadConcern from the read concern level.*/
  function ReadConcern(level) {
    _classCallCheck(this, ReadConcern);

    var _a;
    /**
     * A spec test exists that allows level to be any string.
     * "invalid readConcern with out stage"
     * @see ./test/spec/crud/v2/aggregate-out-readConcern.json
     * @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#unknown-levels-and-additional-options-for-string-based-readconcerns
     */


    this.level = (_a = exports.ReadConcernLevel[level]) !== null && _a !== void 0 ? _a : level;
  }
  /**
   * Construct a ReadConcern given an options object.
   *
   * @param options - The options object from which to extract the write concern.
   */


  _createClass(ReadConcern, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        level: this.level
      };
    }
  }], [{
    key: "fromOptions",
    value: function fromOptions(options) {
      if (options == null) {
        return;
      }

      if (options.readConcern) {
        var readConcern = options.readConcern;

        if (readConcern instanceof ReadConcern) {
          return readConcern;
        } else if (typeof readConcern === 'string') {
          return new ReadConcern(readConcern);
        } else if ('level' in readConcern && readConcern.level) {
          return new ReadConcern(readConcern.level);
        }
      }

      if (options.level) {
        return new ReadConcern(options.level);
      }

      return;
    }
  }, {
    key: "MAJORITY",
    get: function get() {
      return exports.ReadConcernLevel.majority;
    }
  }, {
    key: "AVAILABLE",
    get: function get() {
      return exports.ReadConcernLevel.available;
    }
  }, {
    key: "LINEARIZABLE",
    get: function get() {
      return exports.ReadConcernLevel.linearizable;
    }
  }, {
    key: "SNAPSHOT",
    get: function get() {
      return exports.ReadConcernLevel.snapshot;
    }
  }]);

  return ReadConcern;
}();

exports.ReadConcern = ReadConcern;

/***/ }),

/***/ 3985:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReadPreference = exports.ReadPreferenceMode = void 0;

var error_1 = __webpack_require__(9271);
/** @public */


exports.ReadPreferenceMode = Object.freeze({
  primary: 'primary',
  primaryPreferred: 'primaryPreferred',
  secondary: 'secondary',
  secondaryPreferred: 'secondaryPreferred',
  nearest: 'nearest'
});
/**
 * The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
 * used to construct connections.
 * @public
 *
 * @see https://docs.mongodb.com/manual/core/read-preference/
 */

var ReadPreference = /*#__PURE__*/function () {
  /**
   * @param mode - A string describing the read preference mode (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
   * @param tags - A tag set used to target reads to members with the specified tag(s). tagSet is not available if using read preference mode primary.
   * @param options - Additional read preference options
   */
  function ReadPreference(mode, tags, options) {
    _classCallCheck(this, ReadPreference);

    if (!ReadPreference.isValid(mode)) {
      throw new error_1.MongoInvalidArgumentError("Invalid read preference mode ".concat(JSON.stringify(mode)));
    }

    if (options == null && _typeof(tags) === 'object' && !Array.isArray(tags)) {
      options = tags;
      tags = undefined;
    } else if (tags && !Array.isArray(tags)) {
      throw new error_1.MongoInvalidArgumentError('ReadPreference tags must be an array');
    }

    this.mode = mode;
    this.tags = tags;
    this.hedge = options === null || options === void 0 ? void 0 : options.hedge;
    this.maxStalenessSeconds = undefined;
    this.minWireVersion = undefined;
    options = options !== null && options !== void 0 ? options : {};

    if (options.maxStalenessSeconds != null) {
      if (options.maxStalenessSeconds <= 0) {
        throw new error_1.MongoInvalidArgumentError('maxStalenessSeconds must be a positive integer');
      }

      this.maxStalenessSeconds = options.maxStalenessSeconds; // NOTE: The minimum required wire version is 5 for this read preference. If the existing
      //       topology has a lower value then a MongoError will be thrown during server selection.

      this.minWireVersion = 5;
    }

    if (this.mode === ReadPreference.PRIMARY) {
      if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
        throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with tags');
      }

      if (this.maxStalenessSeconds) {
        throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with maxStalenessSeconds');
      }

      if (this.hedge) {
        throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with hedge');
      }
    }
  } // Support the deprecated `preference` property introduced in the porcelain layer


  _createClass(ReadPreference, [{
    key: "preference",
    get: function get() {
      return this.mode;
    }
  }, {
    key: "isValid",
    value:
    /**
     * Validate if a mode is legal
     *
     * @param mode - The string representing the read preference mode.
     */
    function isValid(mode) {
      return ReadPreference.isValid(typeof mode === 'string' ? mode : this.mode);
    }
    /**
     * Indicates that this readPreference needs the "secondaryOk" bit when sent over the wire
     * @deprecated Use secondaryOk instead
     * @see https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#op-query
     */

  }, {
    key: "slaveOk",
    value: function slaveOk() {
      return this.secondaryOk();
    }
    /**
     * Indicates that this readPreference needs the "SecondaryOk" bit when sent over the wire
     * @see https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#op-query
     */

  }, {
    key: "secondaryOk",
    value: function secondaryOk() {
      var NEEDS_SECONDARYOK = new Set([ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST]);
      return NEEDS_SECONDARYOK.has(this.mode);
    }
    /**
     * Check if the two ReadPreferences are equivalent
     *
     * @param readPreference - The read preference with which to check equality
     */

  }, {
    key: "equals",
    value: function equals(readPreference) {
      return readPreference.mode === this.mode;
    }
    /** Return JSON representation */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var readPreference = {
        mode: this.mode
      };
      if (Array.isArray(this.tags)) readPreference.tags = this.tags;
      if (this.maxStalenessSeconds) readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge) readPreference.hedge = this.hedge;
      return readPreference;
    }
  }], [{
    key: "fromString",
    value: function fromString(mode) {
      return new ReadPreference(mode);
    }
    /**
     * Construct a ReadPreference given an options object.
     *
     * @param options - The options object from which to extract the read preference.
     */

  }, {
    key: "fromOptions",
    value: function fromOptions(options) {
      var _a, _b, _c;

      if (!options) return;
      var readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : (_b = options.session) === null || _b === void 0 ? void 0 : _b.transaction.options.readPreference;
      var readPreferenceTags = options.readPreferenceTags;

      if (readPreference == null) {
        return;
      }

      if (typeof readPreference === 'string') {
        return new ReadPreference(readPreference, readPreferenceTags, {
          maxStalenessSeconds: options.maxStalenessSeconds,
          hedge: options.hedge
        });
      } else if (!(readPreference instanceof ReadPreference) && _typeof(readPreference) === 'object') {
        var mode = readPreference.mode || readPreference.preference;

        if (mode && typeof mode === 'string') {
          return new ReadPreference(mode, (_c = readPreference.tags) !== null && _c !== void 0 ? _c : readPreferenceTags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds,
            hedge: options.hedge
          });
        }
      }

      if (readPreferenceTags) {
        readPreference.tags = readPreferenceTags;
      }

      return readPreference;
    }
    /**
     * Replaces options.readPreference with a ReadPreference instance
     */

  }, {
    key: "translate",
    value: function translate(options) {
      if (options.readPreference == null) return options;
      var r = options.readPreference;

      if (typeof r === 'string') {
        options.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && _typeof(r) === 'object') {
        var mode = r.mode || r.preference;

        if (mode && typeof mode === 'string') {
          options.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError("Invalid read preference: ".concat(r));
      }

      return options;
    }
    /**
     * Validate if a mode is legal
     *
     * @param mode - The string representing the read preference mode.
     */

  }, {
    key: "isValid",
    value: function isValid(mode) {
      var VALID_MODES = new Set([ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST, null]);
      return VALID_MODES.has(mode);
    }
  }]);

  return ReadPreference;
}();

exports.ReadPreference = ReadPreference;
ReadPreference.PRIMARY = exports.ReadPreferenceMode.primary;
ReadPreference.PRIMARY_PREFERRED = exports.ReadPreferenceMode.primaryPreferred;
ReadPreference.SECONDARY = exports.ReadPreferenceMode.secondary;
ReadPreference.SECONDARY_PREFERRED = exports.ReadPreferenceMode.secondaryPreferred;
ReadPreference.NEAREST = exports.ReadPreferenceMode.nearest;
ReadPreference.primary = new ReadPreference(exports.ReadPreferenceMode.primary);
ReadPreference.primaryPreferred = new ReadPreference(exports.ReadPreferenceMode.primaryPreferred);
ReadPreference.secondary = new ReadPreference(exports.ReadPreferenceMode.secondary);
ReadPreference.secondaryPreferred = new ReadPreference(exports.ReadPreferenceMode.secondaryPreferred);
ReadPreference.nearest = new ReadPreference(exports.ReadPreferenceMode.nearest);

/***/ }),

/***/ 4118:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports._advanceClusterTime = exports.drainTimerQueue = exports.ServerType = exports.TopologyType = exports.STATE_CONNECTED = exports.STATE_CONNECTING = exports.STATE_CLOSED = exports.STATE_CLOSING = void 0;

var timers_1 = __webpack_require__(9512); // shared state names


exports.STATE_CLOSING = 'closing';
exports.STATE_CLOSED = 'closed';
exports.STATE_CONNECTING = 'connecting';
exports.STATE_CONNECTED = 'connected';
/**
 * An enumeration of topology types we know about
 * @public
 */

exports.TopologyType = Object.freeze({
  Single: 'Single',
  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',
  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',
  Sharded: 'Sharded',
  Unknown: 'Unknown',
  LoadBalanced: 'LoadBalanced'
});
/**
 * An enumeration of server types we know about
 * @public
 */

exports.ServerType = Object.freeze({
  Standalone: 'Standalone',
  Mongos: 'Mongos',
  PossiblePrimary: 'PossiblePrimary',
  RSPrimary: 'RSPrimary',
  RSSecondary: 'RSSecondary',
  RSArbiter: 'RSArbiter',
  RSOther: 'RSOther',
  RSGhost: 'RSGhost',
  Unknown: 'Unknown',
  LoadBalancer: 'LoadBalancer'
});
/** @internal */

function drainTimerQueue(queue) {
  queue.forEach(timers_1.clearTimeout);
  queue.clear();
}

exports.drainTimerQueue = drainTimerQueue;
/** Shared function to determine clusterTime for a given topology or session */

function _advanceClusterTime(entity, $clusterTime) {
  if (entity.clusterTime == null) {
    entity.clusterTime = $clusterTime;
  } else {
    if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
      entity.clusterTime = $clusterTime;
    }
  }
}

exports._advanceClusterTime = _advanceClusterTime;

/***/ }),

/***/ 9874:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ServerHeartbeatFailedEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.TopologyClosedEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.ServerClosedEvent = exports.ServerOpeningEvent = exports.ServerDescriptionChangedEvent = void 0;
/**
 * Emitted when server description changes, but does NOT include changes to the RTT.
 * @public
 * @category Event
 */

var ServerDescriptionChangedEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerDescriptionChangedEvent(topologyId, address, previousDescription, newDescription) {
  _classCallCheck(this, ServerDescriptionChangedEvent);

  this.topologyId = topologyId;
  this.address = address;
  this.previousDescription = previousDescription;
  this.newDescription = newDescription;
});

exports.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;
/**
 * Emitted when server is initialized.
 * @public
 * @category Event
 */

var ServerOpeningEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerOpeningEvent(topologyId, address) {
  _classCallCheck(this, ServerOpeningEvent);

  this.topologyId = topologyId;
  this.address = address;
});

exports.ServerOpeningEvent = ServerOpeningEvent;
/**
 * Emitted when server is closed.
 * @public
 * @category Event
 */

var ServerClosedEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerClosedEvent(topologyId, address) {
  _classCallCheck(this, ServerClosedEvent);

  this.topologyId = topologyId;
  this.address = address;
});

exports.ServerClosedEvent = ServerClosedEvent;
/**
 * Emitted when topology description changes.
 * @public
 * @category Event
 */

var TopologyDescriptionChangedEvent = /*#__PURE__*/_createClass(
/** @internal */
function TopologyDescriptionChangedEvent(topologyId, previousDescription, newDescription) {
  _classCallCheck(this, TopologyDescriptionChangedEvent);

  this.topologyId = topologyId;
  this.previousDescription = previousDescription;
  this.newDescription = newDescription;
});

exports.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;
/**
 * Emitted when topology is initialized.
 * @public
 * @category Event
 */

var TopologyOpeningEvent = /*#__PURE__*/_createClass(
/** @internal */
function TopologyOpeningEvent(topologyId) {
  _classCallCheck(this, TopologyOpeningEvent);

  this.topologyId = topologyId;
});

exports.TopologyOpeningEvent = TopologyOpeningEvent;
/**
 * Emitted when topology is closed.
 * @public
 * @category Event
 */

var TopologyClosedEvent = /*#__PURE__*/_createClass(
/** @internal */
function TopologyClosedEvent(topologyId) {
  _classCallCheck(this, TopologyClosedEvent);

  this.topologyId = topologyId;
});

exports.TopologyClosedEvent = TopologyClosedEvent;
/**
 * Emitted when the server monitors hello command is started - immediately before
 * the hello command is serialized into raw BSON and written to the socket.
 *
 * @public
 * @category Event
 */

var ServerHeartbeatStartedEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerHeartbeatStartedEvent(connectionId) {
  _classCallCheck(this, ServerHeartbeatStartedEvent);

  this.connectionId = connectionId;
});

exports.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;
/**
 * Emitted when the server monitors hello succeeds.
 * @public
 * @category Event
 */

var ServerHeartbeatSucceededEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerHeartbeatSucceededEvent(connectionId, duration, reply) {
  _classCallCheck(this, ServerHeartbeatSucceededEvent);

  this.connectionId = connectionId;
  this.duration = duration;
  this.reply = reply !== null && reply !== void 0 ? reply : {};
});

exports.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;
/**
 * Emitted when the server monitors hello fails, either with an ok: 0 or a socket exception.
 * @public
 * @category Event
 */

var ServerHeartbeatFailedEvent = /*#__PURE__*/_createClass(
/** @internal */
function ServerHeartbeatFailedEvent(connectionId, duration, failure) {
  _classCallCheck(this, ServerHeartbeatFailedEvent);

  this.connectionId = connectionId;
  this.duration = duration;
  this.failure = failure;
});

exports.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;

/***/ }),

/***/ 2551:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _ref;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RTTPinger = exports.Monitor = void 0;

var timers_1 = __webpack_require__(9512);

var bson_1 = __webpack_require__(53);

var connect_1 = __webpack_require__(7247);

var connection_1 = __webpack_require__(7625);

var constants_1 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var mongo_types_1 = __webpack_require__(3738);

var utils_1 = __webpack_require__(4356);

var common_1 = __webpack_require__(4118);

var events_1 = __webpack_require__(9874);

var server_1 = __webpack_require__(4310);
/** @internal */


var kServer = Symbol('server');
/** @internal */

var kMonitorId = Symbol('monitorId');
/** @internal */

var kConnection = Symbol('connection');
/** @internal */

var kCancellationToken = Symbol('cancellationToken');
/** @internal */

var kRTTPinger = Symbol('rttPinger');
/** @internal */

var kRoundTripTime = Symbol('roundTripTime');
var STATE_IDLE = 'idle';
var STATE_MONITORING = 'monitoring';
var stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, STATE_MONITORING]), _defineProperty(_ref, STATE_IDLE, [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING]), _defineProperty(_ref, STATE_MONITORING, [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]), _ref));
var INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);

function isInCloseState(monitor) {
  return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
}
/** @internal */


var Monitor = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(Monitor, _mongo_types_1$TypedE);

  var _super = _createSuper(Monitor);

  function Monitor(server, options) {
    var _this;

    _classCallCheck(this, Monitor);

    var _a, _b, _c;

    _this = _super.call(this);
    _this[kServer] = server;
    _this[kConnection] = undefined;
    _this[kCancellationToken] = new mongo_types_1.CancellationToken();

    _this[kCancellationToken].setMaxListeners(Infinity);

    _this[kMonitorId] = undefined;
    _this.s = {
      state: common_1.STATE_CLOSED
    };
    _this.address = server.description.address;
    _this.options = Object.freeze({
      connectTimeoutMS: (_a = options.connectTimeoutMS) !== null && _a !== void 0 ? _a : 10000,
      heartbeatFrequencyMS: (_b = options.heartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 10000,
      minHeartbeatFrequencyMS: (_c = options.minHeartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 500
    });
    var cancellationToken = _this[kCancellationToken]; // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration

    var connectOptions = Object.assign({
      id: '<monitor>',
      generation: server.s.pool.generation,
      connectionType: connection_1.Connection,
      cancellationToken: cancellationToken,
      hostAddress: server.description.hostAddress
    }, options, // force BSON serialization options
    {
      raw: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: true
    }); // ensure no authentication is used for monitoring

    delete connectOptions.credentials;

    if (connectOptions.autoEncrypter) {
      delete connectOptions.autoEncrypter;
    }

    _this.connectOptions = Object.freeze(connectOptions);
    return _this;
  }

  _createClass(Monitor, [{
    key: "connection",
    get: function get() {
      return this[kConnection];
    }
  }, {
    key: "connect",
    value: function connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      } // start


      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = (0, utils_1.makeInterruptibleAsyncInterval)(monitorServer(this), {
        interval: heartbeatFrequencyMS,
        minInterval: minHeartbeatFrequencyMS,
        immediate: true
      });
    }
  }, {
    key: "requestCheck",
    value: function requestCheck() {
      var _a;

      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }

      (_a = this[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();
    }
  }, {
    key: "reset",
    value: function reset() {
      var topologyVersion = this[kServer].description.topologyVersion;

      if (isInCloseState(this) || topologyVersion == null) {
        return;
      }

      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this); // restart monitor

      stateTransition(this, STATE_IDLE); // restart monitoring

      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = (0, utils_1.makeInterruptibleAsyncInterval)(monitorServer(this), {
        interval: heartbeatFrequencyMS,
        minInterval: minHeartbeatFrequencyMS
      });
    }
  }, {
    key: "close",
    value: function close() {
      if (isInCloseState(this)) {
        return;
      }

      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this); // close monitor

      this.emit('close');
      stateTransition(this, common_1.STATE_CLOSED);
    }
  }]);

  return Monitor;
}(mongo_types_1.TypedEventEmitter);

exports.Monitor = Monitor;

function resetMonitorState(monitor) {
  var _a, _b, _c;

  (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.stop();
  monitor[kMonitorId] = undefined;
  (_b = monitor[kRTTPinger]) === null || _b === void 0 ? void 0 : _b.close();
  monitor[kRTTPinger] = undefined;
  monitor[kCancellationToken].emit('cancel');
  (_c = monitor[kConnection]) === null || _c === void 0 ? void 0 : _c.destroy({
    force: true
  });
  monitor[kConnection] = undefined;
}

function checkServer(monitor, callback) {
  var start = (0, utils_1.now)();
  monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));

  function failureHandler(err) {
    var _a;

    (_a = monitor[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({
      force: true
    });
    monitor[kConnection] = undefined;
    monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err));
    monitor.emit('resetServer', err);
    monitor.emit('resetConnectionPool');
    callback(err);
  }

  var connection = monitor[kConnection];

  if (connection && !connection.closed) {
    var serverApi = connection.serverApi,
        helloOk = connection.helloOk;
    var connectTimeoutMS = monitor.options.connectTimeoutMS;
    var maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
    var topologyVersion = monitor[kServer].description.topologyVersion;
    var isAwaitable = topologyVersion != null;

    var cmd = _objectSpread(_defineProperty({}, (serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND, true), isAwaitable && topologyVersion ? {
      maxAwaitTimeMS: maxAwaitTimeMS,
      topologyVersion: makeTopologyVersion(topologyVersion)
    } : {});

    var options = isAwaitable ? {
      socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
      exhaustAllowed: true
    } : {
      socketTimeoutMS: connectTimeoutMS
    };

    if (isAwaitable && monitor[kRTTPinger] == null) {
      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], Object.assign({
        heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS
      }, monitor.connectOptions));
    }

    connection.command((0, utils_1.ns)('admin.$cmd'), cmd, options, function (err, hello) {
      var _a;

      if (err) {
        return failureHandler(err);
      }

      if (!('isWritablePrimary' in hello)) {
        // Provide hello-style response document.
        hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
      }

      var rttPinger = monitor[kRTTPinger];
      var duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);
      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello)); // if we are using the streaming protocol then we immediately issue another `started`
      // event, otherwise the "check" is complete and return to the main monitor loop

      if (isAwaitable && hello.topologyVersion) {
        monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));
        start = (0, utils_1.now)();
      } else {
        (_a = monitor[kRTTPinger]) === null || _a === void 0 ? void 0 : _a.close();
        monitor[kRTTPinger] = undefined;
        callback(undefined, hello);
      }
    });
    return;
  } // connecting does an implicit `hello`


  (0, connect_1.connect)(monitor.connectOptions, function (err, conn) {
    if (err) {
      monitor[kConnection] = undefined; // we already reset the connection pool on network errors in all cases

      if (!(err instanceof error_1.MongoNetworkError)) {
        monitor.emit('resetConnectionPool');
      }

      failureHandler(err);
      return;
    }

    if (conn) {
      // Tell the connection that we are using the streaming protocol so that the
      // connection's message stream will only read the last hello on the buffer.
      conn.isMonitoringConnection = true;

      if (isInCloseState(monitor)) {
        conn.destroy({
          force: true
        });
        return;
      }

      monitor[kConnection] = conn;
      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello));
      callback(undefined, conn.hello);
    }
  });
}

function monitorServer(monitor) {
  return function (callback) {
    stateTransition(monitor, STATE_MONITORING);

    function done() {
      if (!isInCloseState(monitor)) {
        stateTransition(monitor, STATE_IDLE);
      }

      callback();
    }

    checkServer(monitor, function (err, hello) {
      if (err) {
        // otherwise an error occurred on initial discovery, also bail
        if (monitor[kServer].description.type === common_1.ServerType.Unknown) {
          monitor.emit('resetServer', err);
          return done();
        }
      } // if the check indicates streaming is supported, immediately reschedule monitoring


      if (hello && hello.topologyVersion) {
        (0, timers_1.setTimeout)(function () {
          var _a;

          if (!isInCloseState(monitor)) {
            (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();
          }
        }, 0);
      }

      done();
    });
  };
}

function makeTopologyVersion(tv) {
  return {
    processId: tv.processId,
    // tests mock counter as just number, but in a real situation counter should always be a Long
    // TODO(NODE-2674): Preserve int64 sent from MongoDB
    counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
  };
}
/** @internal */


var RTTPinger = /*#__PURE__*/function () {
  function RTTPinger(cancellationToken, options) {
    var _this2 = this;

    _classCallCheck(this, RTTPinger);

    this[kConnection] = undefined;
    this[kCancellationToken] = cancellationToken;
    this[kRoundTripTime] = 0;
    this.closed = false;
    var heartbeatFrequencyMS = options.heartbeatFrequencyMS;
    this[kMonitorId] = (0, timers_1.setTimeout)(function () {
      return measureRoundTripTime(_this2, options);
    }, heartbeatFrequencyMS);
  }

  _createClass(RTTPinger, [{
    key: "roundTripTime",
    get: function get() {
      return this[kRoundTripTime];
    }
  }, {
    key: "close",
    value: function close() {
      var _a;

      this.closed = true;
      (0, timers_1.clearTimeout)(this[kMonitorId]);
      (_a = this[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({
        force: true
      });
      this[kConnection] = undefined;
    }
  }]);

  return RTTPinger;
}();

exports.RTTPinger = RTTPinger;

function measureRoundTripTime(rttPinger, options) {
  var start = (0, utils_1.now)();
  options.cancellationToken = rttPinger[kCancellationToken];
  var heartbeatFrequencyMS = options.heartbeatFrequencyMS;

  if (rttPinger.closed) {
    return;
  }

  function measureAndReschedule(conn) {
    if (rttPinger.closed) {
      conn === null || conn === void 0 ? void 0 : conn.destroy({
        force: true
      });
      return;
    }

    if (rttPinger[kConnection] == null) {
      rttPinger[kConnection] = conn;
    }

    rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);
    rttPinger[kMonitorId] = (0, timers_1.setTimeout)(function () {
      return measureRoundTripTime(rttPinger, options);
    }, heartbeatFrequencyMS);
  }

  var connection = rttPinger[kConnection];

  if (connection == null) {
    (0, connect_1.connect)(options, function (err, conn) {
      if (err) {
        rttPinger[kConnection] = undefined;
        rttPinger[kRoundTripTime] = 0;
        return;
      }

      measureAndReschedule(conn);
    });
    return;
  }

  connection.command((0, utils_1.ns)('admin.$cmd'), _defineProperty({}, constants_1.LEGACY_HELLO_COMMAND, 1), undefined, function (err) {
    if (err) {
      rttPinger[kConnection] = undefined;
      rttPinger[kRoundTripTime] = 0;
      return;
    }

    measureAndReschedule();
  });
}

/***/ }),

/***/ 4310:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _ref;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Server = void 0;

var connection_1 = __webpack_require__(7625);

var connection_pool_1 = __webpack_require__(6854);

var constants_1 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var logger_1 = __webpack_require__(295);

var mongo_types_1 = __webpack_require__(3738);

var transactions_1 = __webpack_require__(3271);

var utils_1 = __webpack_require__(4356);

var common_1 = __webpack_require__(4118);

var monitor_1 = __webpack_require__(2551);

var server_description_1 = __webpack_require__(1071);

var stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, common_1.STATE_CONNECTING]), _defineProperty(_ref, common_1.STATE_CONNECTING, [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CONNECTED, [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _ref));
/** @internal */

var kMonitor = Symbol('monitor');
/** @internal */

var Server = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(Server, _mongo_types_1$TypedE);

  var _super = _createSuper(Server);

  /**
   * Create a server
   */
  function Server(topology, description, options) {
    var _this;

    _classCallCheck(this, Server);

    _this = _super.call(this);
    _this.serverApi = options.serverApi;

    var poolOptions = _objectSpread({
      hostAddress: description.hostAddress
    }, options);

    _this.s = {
      description: description,
      options: options,
      logger: new logger_1.Logger('Server'),
      state: common_1.STATE_CLOSED,
      topology: topology,
      pool: new connection_pool_1.ConnectionPool(poolOptions),
      operationCount: 0
    };

    var _loop = function _loop() {
      var event = _arr[_i];

      _this.s.pool.on(event, function (e) {
        return _this.emit(event, e);
      });
    };

    for (var _i = 0, _arr = [].concat(_toConsumableArray(constants_1.CMAP_EVENTS), _toConsumableArray(constants_1.APM_EVENTS)); _i < _arr.length; _i++) {
      _loop();
    }

    _this.s.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, function (clusterTime) {
      _this.clusterTime = clusterTime;
    });

    if (_this.loadBalanced) {
      _this[kMonitor] = null; // monitoring is disabled in load balancing mode

      return _possibleConstructorReturn(_this);
    } // create the monitor
    // TODO(NODE-4144): Remove new variable for type narrowing


    var monitor = new monitor_1.Monitor(_assertThisInitialized(_this), _this.s.options);
    _this[kMonitor] = monitor;

    var _iterator = _createForOfIteratorHelper(constants_1.HEARTBEAT_EVENTS),
        _step;

    try {
      var _loop2 = function _loop2() {
        var event = _step.value;
        monitor.on(event, function (e) {
          return _this.emit(event, e);
        });
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop2();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    monitor.on('resetConnectionPool', function () {
      _this.s.pool.clear();
    });
    monitor.on('resetServer', function (error) {
      return markServerUnknown(_assertThisInitialized(_this), error);
    });
    monitor.on(Server.SERVER_HEARTBEAT_SUCCEEDED, function (event) {
      _this.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(_this.description.hostAddress, event.reply, {
        roundTripTime: calculateRoundTripTime(_this.description.roundTripTime, event.duration)
      }));

      if (_this.s.state === common_1.STATE_CONNECTING) {
        stateTransition(_assertThisInitialized(_this), common_1.STATE_CONNECTED);

        _this.emit(Server.CONNECT, _assertThisInitialized(_this));
      }
    });
    return _this;
  }

  _createClass(Server, [{
    key: "clusterTime",
    get: function get() {
      return this.s.topology.clusterTime;
    },
    set: function set(clusterTime) {
      this.s.topology.clusterTime = clusterTime;
    }
  }, {
    key: "description",
    get: function get() {
      return this.s.description;
    }
  }, {
    key: "name",
    get: function get() {
      return this.s.description.address;
    }
  }, {
    key: "autoEncrypter",
    get: function get() {
      if (this.s.options && this.s.options.autoEncrypter) {
        return this.s.options.autoEncrypter;
      }

      return;
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      return this.s.topology.description.type === common_1.TopologyType.LoadBalanced;
    }
    /**
     * Initiate server connect
     */

  }, {
    key: "connect",
    value: function connect() {
      var _a;

      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }

      stateTransition(this, common_1.STATE_CONNECTING); // If in load balancer mode we automatically set the server to
      // a load balancer. It never transitions out of this state and
      // has no monitor.

      if (!this.loadBalanced) {
        (_a = this[kMonitor]) === null || _a === void 0 ? void 0 : _a.connect();
      } else {
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Server.CONNECT, this);
      }
    }
    /** Destroy the server connection */

  }, {
    key: "destroy",
    value: function destroy(options, callback) {
      var _this2 = this;

      var _a;

      if (typeof options === 'function') callback = options, options = {};
      options = Object.assign({}, {
        force: false
      }, options);

      if (this.s.state === common_1.STATE_CLOSED) {
        if (typeof callback === 'function') {
          callback();
        }

        return;
      }

      stateTransition(this, common_1.STATE_CLOSING);

      if (!this.loadBalanced) {
        (_a = this[kMonitor]) === null || _a === void 0 ? void 0 : _a.close();
      }

      this.s.pool.close(options, function (err) {
        stateTransition(_this2, common_1.STATE_CLOSED);

        _this2.emit('closed');

        if (typeof callback === 'function') {
          callback(err);
        }
      });
    }
    /**
     * Immediately schedule monitoring of this server. If there already an attempt being made
     * this will be a no-op.
     */

  }, {
    key: "requestCheck",
    value: function requestCheck() {
      var _a;

      if (!this.loadBalanced) {
        (_a = this[kMonitor]) === null || _a === void 0 ? void 0 : _a.requestCheck();
      }
    }
    /**
     * Execute a command
     * @internal
     */

  }, {
    key: "command",
    value: function command(ns, cmd, options, callback) {
      var _this3 = this;

      if (callback == null) {
        throw new error_1.MongoInvalidArgumentError('Callback must be provided');
      }

      if (ns.db == null || typeof ns === 'string') {
        throw new error_1.MongoInvalidArgumentError('Namespace must not be a string');
      }

      if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
        callback(new error_1.MongoServerClosedError());
        return;
      } // Clone the options


      var finalOptions = Object.assign({}, options, {
        wireProtocolCommand: false
      }); // There are cases where we need to flag the read preference not to get sent in
      // the command, such as pre-5.0 servers attempting to perform an aggregate write
      // with a non-primary read preference. In this case the effective read preference
      // (primary) is not the same as the provided and must be removed completely.

      if (finalOptions.omitReadPreference) {
        delete finalOptions.readPreference;
      } // error if collation not supported


      if ((0, utils_1.collationNotSupported)(this, cmd)) {
        callback(new error_1.MongoCompatibilityError("Server ".concat(this.name, " does not support collation")));
        return;
      }

      var session = finalOptions.session;
      var conn = session === null || session === void 0 ? void 0 : session.pinnedConnection; // NOTE: This is a hack! We can't retrieve the connections used for executing an operation
      //       (and prevent them from being checked back in) at the point of operation execution.
      //       This should be considered as part of the work for NODE-2882
      // NOTE:
      //       When incrementing operation count, it's important that we increment it before we
      //       attempt to check out a connection from the pool.  This ensures that operations that
      //       are waiting for a connection are included in the operation count.  Load balanced
      //       mode will only ever have a single server, so the operation count doesn't matter.
      //       Incrementing the operation count above the logic to handle load balanced mode would
      //       require special logic to decrement it again, or would double increment (the load
      //       balanced code makes a recursive call).  Instead, we increment the count after this
      //       check.

      if (this.loadBalanced && session && conn == null && isPinnableCommand(cmd, session)) {
        this.s.pool.checkOut(function (err, checkedOut) {
          if (err || checkedOut == null) {
            if (callback) return callback(err);
            return;
          }

          session.pin(checkedOut);

          _this3.command(ns, cmd, finalOptions, callback);
        });
        return;
      }

      this.s.operationCount += 1;
      this.s.pool.withConnection(conn, function (err, conn, cb) {
        if (err || !conn) {
          _this3.s.operationCount -= 1;
          markServerUnknown(_this3, err);
          return cb(err);
        }

        conn.command(ns, cmd, finalOptions, makeOperationHandler(_this3, conn, cmd, finalOptions, function (error, response) {
          _this3.s.operationCount -= 1;
          cb(error, response);
        }));
      }, callback);
    }
  }]);

  return Server;
}(mongo_types_1.TypedEventEmitter);

exports.Server = Server;
/** @event */

Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
/** @event */

Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
/** @event */

Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
/** @event */

Server.CONNECT = constants_1.CONNECT;
/** @event */

Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
/** @event */

Server.CLOSED = constants_1.CLOSED;
/** @event */

Server.ENDED = constants_1.ENDED;

function calculateRoundTripTime(oldRtt, duration) {
  if (oldRtt === -1) {
    return duration;
  }

  var alpha = 0.2;
  return alpha * duration + (1 - alpha) * oldRtt;
}

function markServerUnknown(server, error) {
  var _a; // Load balancer servers can never be marked unknown.


  if (server.loadBalanced) {
    return;
  }

  if (error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError)) {
    (_a = server[kMonitor]) === null || _a === void 0 ? void 0 : _a.reset();
  }

  server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, undefined, {
    error: error
  }));
}

function isPinnableCommand(cmd, session) {
  if (session) {
    return session.inTransaction() || 'aggregate' in cmd || 'find' in cmd || 'getMore' in cmd || 'listCollections' in cmd || 'listIndexes' in cmd;
  }

  return false;
}

function connectionIsStale(pool, connection) {
  if (connection.serviceId) {
    return connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString());
  }

  return connection.generation !== pool.generation;
}

function shouldHandleStateChangeError(server, err) {
  var etv = err.topologyVersion;
  var stv = server.description.topologyVersion;
  return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
}

function inActiveTransaction(session, cmd) {
  return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
}
/** this checks the retryWrites option passed down from the client options, it
 * does not check if the server supports retryable writes */


function isRetryableWritesEnabled(topology) {
  return topology.s.options.retryWrites !== false;
}

function makeOperationHandler(server, connection, cmd, options, callback) {
  var session = options === null || options === void 0 ? void 0 : options.session;
  return function handleOperationResult(error, result) {
    if (result != null) {
      return callback(undefined, result);
    }

    if (!error) {
      return callback(new error_1.MongoUnexpectedServerResponseError('Empty response with no error'));
    }

    if (!(error instanceof error_1.MongoError)) {
      // Node.js or some other error we have not special handling for
      return callback(error);
    }

    if (connectionIsStale(server.s.pool, connection)) {
      return callback(error);
    }

    if (error instanceof error_1.MongoNetworkError) {
      if (session && !session.hasEnded && session.serverSession) {
        session.serverSession.isDirty = true;
      } // inActiveTransaction check handles commit and abort.


      if (inActiveTransaction(session, cmd) && !error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        error.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
      }

      if ((isRetryableWritesEnabled(server.s.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, utils_1.supportsRetryableWrites)(server) && !inActiveTransaction(session, cmd)) {
        error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
      }

      if (!(error instanceof error_1.MongoNetworkTimeoutError) || (0, error_1.isNetworkErrorBeforeHandshake)(error)) {
        // In load balanced mode we never mark the server as unknown and always
        // clear for the specific service id.
        server.s.pool.clear(connection.serviceId);

        if (!server.loadBalanced) {
          markServerUnknown(server, error);
        }
      }
    } else {
      if ((isRetryableWritesEnabled(server.s.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, error_1.needsRetryableWriteLabel)(error, (0, utils_1.maxWireVersion)(server)) && !inActiveTransaction(session, cmd)) {
        error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
      }

      if ((0, error_1.isSDAMUnrecoverableError)(error)) {
        if (shouldHandleStateChangeError(server, error)) {
          if ((0, utils_1.maxWireVersion)(server) <= 7 || (0, error_1.isNodeShuttingDownError)(error)) {
            server.s.pool.clear(connection.serviceId);
          }

          if (!server.loadBalanced) {
            markServerUnknown(server, error);
            process.nextTick(function () {
              return server.requestCheck();
            });
          }
        }
      }
    }

    if (session && session.isPinned && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
      session.unpin({
        force: true
      });
    }

    return callback(error);
  };
}

/***/ }),

/***/ 1071:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.compareTopologyVersion = exports.parseServerType = exports.ServerDescription = void 0;

var bson_1 = __webpack_require__(53);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var common_1 = __webpack_require__(4118);

var WRITABLE_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.Standalone, common_1.ServerType.Mongos, common_1.ServerType.LoadBalancer]);
var DATA_BEARING_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.RSSecondary, common_1.ServerType.Mongos, common_1.ServerType.Standalone, common_1.ServerType.LoadBalancer]);
/**
 * The client's view of a single server, based on the most recent hello outcome.
 *
 * Internal type, not meant to be directly instantiated
 * @public
 */

var ServerDescription = /*#__PURE__*/function () {
  /**
   * Create a ServerDescription
   * @internal
   *
   * @param address - The address of the server
   * @param hello - An optional hello response for this server
   */
  function ServerDescription(address, hello) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ServerDescription);

    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;

    if (address == null || address === '') {
      throw new error_1.MongoRuntimeError('ServerDescription must be provided with a non-empty address');
    }

    this.address = typeof address === 'string' ? utils_1.HostAddress.fromString(address).toString(false) // Use HostAddress to normalize
    : address.toString(false);
    this.type = parseServerType(hello, options);
    this.hosts = (_b = (_a = hello === null || hello === void 0 ? void 0 : hello.hosts) === null || _a === void 0 ? void 0 : _a.map(function (host) {
      return host.toLowerCase();
    })) !== null && _b !== void 0 ? _b : [];
    this.passives = (_d = (_c = hello === null || hello === void 0 ? void 0 : hello.passives) === null || _c === void 0 ? void 0 : _c.map(function (host) {
      return host.toLowerCase();
    })) !== null && _d !== void 0 ? _d : [];
    this.arbiters = (_f = (_e = hello === null || hello === void 0 ? void 0 : hello.arbiters) === null || _e === void 0 ? void 0 : _e.map(function (host) {
      return host.toLowerCase();
    })) !== null && _f !== void 0 ? _f : [];
    this.tags = (_g = hello === null || hello === void 0 ? void 0 : hello.tags) !== null && _g !== void 0 ? _g : {};
    this.minWireVersion = (_h = hello === null || hello === void 0 ? void 0 : hello.minWireVersion) !== null && _h !== void 0 ? _h : 0;
    this.maxWireVersion = (_j = hello === null || hello === void 0 ? void 0 : hello.maxWireVersion) !== null && _j !== void 0 ? _j : 0;
    this.roundTripTime = (_k = options === null || options === void 0 ? void 0 : options.roundTripTime) !== null && _k !== void 0 ? _k : -1;
    this.lastUpdateTime = (0, utils_1.now)();
    this.lastWriteDate = (_m = (_l = hello === null || hello === void 0 ? void 0 : hello.lastWrite) === null || _l === void 0 ? void 0 : _l.lastWriteDate) !== null && _m !== void 0 ? _m : 0;
    this.error = (_o = options.error) !== null && _o !== void 0 ? _o : null; // TODO(NODE-2674): Preserve int64 sent from MongoDB

    this.topologyVersion = (_r = (_q = (_p = this.error) === null || _p === void 0 ? void 0 : _p.topologyVersion) !== null && _q !== void 0 ? _q : hello === null || hello === void 0 ? void 0 : hello.topologyVersion) !== null && _r !== void 0 ? _r : null;
    this.setName = (_s = hello === null || hello === void 0 ? void 0 : hello.setName) !== null && _s !== void 0 ? _s : null;
    this.setVersion = (_t = hello === null || hello === void 0 ? void 0 : hello.setVersion) !== null && _t !== void 0 ? _t : null;
    this.electionId = (_u = hello === null || hello === void 0 ? void 0 : hello.electionId) !== null && _u !== void 0 ? _u : null;
    this.logicalSessionTimeoutMinutes = (_v = hello === null || hello === void 0 ? void 0 : hello.logicalSessionTimeoutMinutes) !== null && _v !== void 0 ? _v : null;
    this.primary = (_w = hello === null || hello === void 0 ? void 0 : hello.primary) !== null && _w !== void 0 ? _w : null;
    this.me = (_y = (_x = hello === null || hello === void 0 ? void 0 : hello.me) === null || _x === void 0 ? void 0 : _x.toLowerCase()) !== null && _y !== void 0 ? _y : null;
    this.$clusterTime = (_z = hello === null || hello === void 0 ? void 0 : hello.$clusterTime) !== null && _z !== void 0 ? _z : null;
  }

  _createClass(ServerDescription, [{
    key: "hostAddress",
    get: function get() {
      return utils_1.HostAddress.fromString(this.address);
    }
  }, {
    key: "allHosts",
    get: function get() {
      return this.hosts.concat(this.arbiters).concat(this.passives);
    }
    /** Is this server available for reads*/

  }, {
    key: "isReadable",
    get: function get() {
      return this.type === common_1.ServerType.RSSecondary || this.isWritable;
    }
    /** Is this server data bearing */

  }, {
    key: "isDataBearing",
    get: function get() {
      return DATA_BEARING_SERVER_TYPES.has(this.type);
    }
    /** Is this server available for writes */

  }, {
    key: "isWritable",
    get: function get() {
      return WRITABLE_SERVER_TYPES.has(this.type);
    }
  }, {
    key: "host",
    get: function get() {
      var chopLength = ":".concat(this.port).length;
      return this.address.slice(0, -chopLength);
    }
  }, {
    key: "port",
    get: function get() {
      var port = this.address.split(':').pop();
      return port ? Number.parseInt(port, 10) : 27017;
    }
    /**
     * Determines if another `ServerDescription` is equal to this one per the rules defined
     * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}
     */

  }, {
    key: "equals",
    value: function equals(other) {
      // Despite using the comparator that would determine a nullish topologyVersion as greater than
      // for equality we should only always perform direct equality comparison
      var topologyVersionsEqual = this.topologyVersion === (other === null || other === void 0 ? void 0 : other.topologyVersion) || compareTopologyVersion(this.topologyVersion, other === null || other === void 0 ? void 0 : other.topologyVersion) === 0;
      var electionIdsEqual = this.electionId != null && (other === null || other === void 0 ? void 0 : other.electionId) != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === (other === null || other === void 0 ? void 0 : other.electionId);
      return other != null && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
    }
  }]);

  return ServerDescription;
}();

exports.ServerDescription = ServerDescription; // Parses a `hello` message and determines the server type

function parseServerType(hello, options) {
  if (options === null || options === void 0 ? void 0 : options.loadBalanced) {
    return common_1.ServerType.LoadBalancer;
  }

  if (!hello || !hello.ok) {
    return common_1.ServerType.Unknown;
  }

  if (hello.isreplicaset) {
    return common_1.ServerType.RSGhost;
  }

  if (hello.msg && hello.msg === 'isdbgrid') {
    return common_1.ServerType.Mongos;
  }

  if (hello.setName) {
    if (hello.hidden) {
      return common_1.ServerType.RSOther;
    } else if (hello.isWritablePrimary) {
      return common_1.ServerType.RSPrimary;
    } else if (hello.secondary) {
      return common_1.ServerType.RSSecondary;
    } else if (hello.arbiterOnly) {
      return common_1.ServerType.RSArbiter;
    } else {
      return common_1.ServerType.RSOther;
    }
  }

  return common_1.ServerType.Standalone;
}

exports.parseServerType = parseServerType;

function tagsStrictEqual(tags, tags2) {
  var tagsKeys = Object.keys(tags);
  var tags2Keys = Object.keys(tags2);
  return tagsKeys.length === tags2Keys.length && tagsKeys.every(function (key) {
    return tags2[key] === tags[key];
  });
}
/**
 * Compares two topology versions.
 *
 * 1. If the response topologyVersion is unset or the ServerDescription's
 *    topologyVersion is null, the client MUST assume the response is more recent.
 * 1. If the response's topologyVersion.processId is not equal to the
 *    ServerDescription's, the client MUST assume the response is more recent.
 * 1. If the response's topologyVersion.processId is equal to the
 *    ServerDescription's, the client MUST use the counter field to determine
 *    which topologyVersion is more recent.
 *
 * ```ts
 * currentTv <   newTv === -1
 * currentTv === newTv === 0
 * currentTv >   newTv === 1
 * ```
 */


function compareTopologyVersion(currentTv, newTv) {
  if (currentTv == null || newTv == null) {
    return -1;
  }

  if (!currentTv.processId.equals(newTv.processId)) {
    return -1;
  } // TODO(NODE-2674): Preserve int64 sent from MongoDB


  var currentCounter = bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);
  var newCounter = bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);
  return currentCounter.compare(newCounter);
}

exports.compareTopologyVersion = compareTopologyVersion;

/***/ }),

/***/ 2557:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;

var error_1 = __webpack_require__(9271);

var read_preference_1 = __webpack_require__(3985);

var common_1 = __webpack_require__(4118); // max staleness constants


var IDLE_WRITE_PERIOD = 10000;
var SMALLEST_MAX_STALENESS_SECONDS = 90; //  Minimum version to try writes on secondaries.

exports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
/**
 * Returns a server selector that selects for writable servers
 */

function writableServerSelector() {
  return function (topologyDescription, servers) {
    return latencyWindowReducer(topologyDescription, servers.filter(function (s) {
      return s.isWritable;
    }));
  };
}

exports.writableServerSelector = writableServerSelector;
/**
 * The purpose of this selector is to select the same server, only
 * if it is in a state that it can have commands sent to it.
 */

function sameServerSelector(description) {
  return function (topologyDescription, servers) {
    if (!description) return []; // Filter the servers to match the provided description only if
    // the type is not unknown.

    return servers.filter(function (sd) {
      return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
    });
  };
}

exports.sameServerSelector = sameServerSelector;
/**
 * Returns a server selector that uses a read preference to select a
 * server potentially for a write on a secondary.
 */

function secondaryWritableServerSelector(wireVersion, readPreference) {
  // If server version < 5.0, read preference always primary.
  // If server version >= 5.0...
  // - If read preference is supplied, use that.
  // - If no read preference is supplied, use primary.
  if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {
    return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
  }

  return readPreferenceServerSelector(readPreference);
}

exports.secondaryWritableServerSelector = secondaryWritableServerSelector;
/**
 * Reduces the passed in array of servers by the rules of the "Max Staleness" specification
 * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst
 *
 * @param readPreference - The read preference providing max staleness guidance
 * @param topologyDescription - The topology description
 * @param servers - The list of server descriptions to be reduced
 * @returns The list of servers that satisfy the requirements of max staleness
 */

function maxStalenessReducer(readPreference, topologyDescription, servers) {
  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
    return servers;
  }

  var maxStaleness = readPreference.maxStalenessSeconds;
  var maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;

  if (maxStaleness < maxStalenessVariance) {
    throw new error_1.MongoInvalidArgumentError("Option \"maxStalenessSeconds\" must be at least ".concat(maxStalenessVariance, " seconds"));
  }

  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
    throw new error_1.MongoInvalidArgumentError("Option \"maxStalenessSeconds\" must be at least ".concat(SMALLEST_MAX_STALENESS_SECONDS, " seconds"));
  }

  if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
    var primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
    return servers.reduce(function (result, server) {
      var _a;

      var stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
      var staleness = stalenessMS / 1000;
      var maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;

      if (staleness <= maxStalenessSeconds) {
        result.push(server);
      }

      return result;
    }, []);
  }

  if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
    if (servers.length === 0) {
      return servers;
    }

    var sMax = servers.reduce(function (max, s) {
      return s.lastWriteDate > max.lastWriteDate ? s : max;
    });
    return servers.reduce(function (result, server) {
      var _a;

      var stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
      var staleness = stalenessMS / 1000;
      var maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;

      if (staleness <= maxStalenessSeconds) {
        result.push(server);
      }

      return result;
    }, []);
  }

  return servers;
}
/**
 * Determines whether a server's tags match a given set of tags
 *
 * @param tagSet - The requested tag set to match
 * @param serverTags - The server's tags
 */


function tagSetMatch(tagSet, serverTags) {
  var keys = Object.keys(tagSet);
  var serverTagKeys = Object.keys(serverTags);

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];

    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
      return false;
    }
  }

  return true;
}
/**
 * Reduces a set of server descriptions based on tags requested by the read preference
 *
 * @param readPreference - The read preference providing the requested tags
 * @param servers - The list of server descriptions to reduce
 * @returns The list of servers matching the requested tags
 */


function tagSetReducer(readPreference, servers) {
  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
    return servers;
  }

  var _loop = function _loop(i) {
    var tagSet = readPreference.tags[i];
    var serversMatchingTagset = servers.reduce(function (matched, server) {
      if (tagSetMatch(tagSet, server.tags)) matched.push(server);
      return matched;
    }, []);

    if (serversMatchingTagset.length) {
      return {
        v: serversMatchingTagset
      };
    }
  };

  for (var i = 0; i < readPreference.tags.length; ++i) {
    var _ret = _loop(i);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return [];
}
/**
 * Reduces a list of servers to ensure they fall within an acceptable latency window. This is
 * further specified in the "Server Selection" specification, found here:
 * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst
 *
 * @param topologyDescription - The topology description
 * @param servers - The list of servers to reduce
 * @returns The servers which fall within an acceptable latency window
 */


function latencyWindowReducer(topologyDescription, servers) {
  var low = servers.reduce(function (min, server) {
    return min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min);
  }, -1);
  var high = low + topologyDescription.localThresholdMS;
  return servers.reduce(function (result, server) {
    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);
    return result;
  }, []);
} // filters


function primaryFilter(server) {
  return server.type === common_1.ServerType.RSPrimary;
}

function secondaryFilter(server) {
  return server.type === common_1.ServerType.RSSecondary;
}

function nearestFilter(server) {
  return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;
}

function knownFilter(server) {
  return server.type !== common_1.ServerType.Unknown;
}

function loadBalancerFilter(server) {
  return server.type === common_1.ServerType.LoadBalancer;
}
/**
 * Returns a function which selects servers based on a provided read preference
 *
 * @param readPreference - The read preference to select with
 */


function readPreferenceServerSelector(readPreference) {
  if (!readPreference.isValid()) {
    throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');
  }

  return function (topologyDescription, servers) {
    var commonWireVersion = topologyDescription.commonWireVersion;

    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
      throw new error_1.MongoCompatibilityError("Minimum wire version '".concat(readPreference.minWireVersion, "' required, but found '").concat(commonWireVersion, "'"));
    }

    if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
      return servers.filter(loadBalancerFilter);
    }

    if (topologyDescription.type === common_1.TopologyType.Unknown) {
      return [];
    }

    if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {
      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
    }

    var mode = readPreference.mode;

    if (mode === read_preference_1.ReadPreference.PRIMARY) {
      return servers.filter(primaryFilter);
    }

    if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
      var result = servers.filter(primaryFilter);

      if (result.length) {
        return result;
      }
    }

    var filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
    var selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));

    if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
      return servers.filter(primaryFilter);
    }

    return selectedServers;
  };
}

exports.readPreferenceServerSelector = readPreferenceServerSelector;

/***/ }),

/***/ 9654:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SrvPoller = exports.SrvPollingEvent = void 0;

var dns = __webpack_require__(9523);

var timers_1 = __webpack_require__(9512);

var error_1 = __webpack_require__(9271);

var logger_1 = __webpack_require__(295);

var mongo_types_1 = __webpack_require__(3738);

var utils_1 = __webpack_require__(4356);
/**
 * Determines whether a provided address matches the provided parent domain in order
 * to avoid certain attack vectors.
 *
 * @param srvAddress - The address to check against a domain
 * @param parentDomain - The domain to check the provided address against
 * @returns Whether the provided address matches the parent domain
 */


function matchesParentDomain(srvAddress, parentDomain) {
  var regex = /^.*?\./;
  var srv = ".".concat(srvAddress.replace(regex, ''));
  var parent = ".".concat(parentDomain.replace(regex, ''));
  return srv.endsWith(parent);
}
/**
 * @internal
 * @category Event
 */


var SrvPollingEvent = /*#__PURE__*/function () {
  function SrvPollingEvent(srvRecords) {
    _classCallCheck(this, SrvPollingEvent);

    this.srvRecords = srvRecords;
  }

  _createClass(SrvPollingEvent, [{
    key: "hostnames",
    value: function hostnames() {
      return new Set(this.srvRecords.map(function (r) {
        return utils_1.HostAddress.fromSrvRecord(r).toString();
      }));
    }
  }]);

  return SrvPollingEvent;
}();

exports.SrvPollingEvent = SrvPollingEvent;
/** @internal */

var SrvPoller = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(SrvPoller, _mongo_types_1$TypedE);

  var _super = _createSuper(SrvPoller);

  function SrvPoller(options) {
    var _this;

    _classCallCheck(this, SrvPoller);

    var _a, _b, _c;

    _this = _super.call(this);

    if (!options || !options.srvHost) {
      throw new error_1.MongoRuntimeError('Options for SrvPoller must exist and include srvHost');
    }

    _this.srvHost = options.srvHost;
    _this.srvMaxHosts = (_a = options.srvMaxHosts) !== null && _a !== void 0 ? _a : 0;
    _this.srvServiceName = (_b = options.srvServiceName) !== null && _b !== void 0 ? _b : 'mongodb';
    _this.rescanSrvIntervalMS = 60000;
    _this.heartbeatFrequencyMS = (_c = options.heartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 10000;
    _this.logger = new logger_1.Logger('srvPoller', options);
    _this.haMode = false;
    _this.generation = 0;
    _this._timeout = undefined;
    return _this;
  }

  _createClass(SrvPoller, [{
    key: "srvAddress",
    get: function get() {
      return "_".concat(this.srvServiceName, "._tcp.").concat(this.srvHost);
    }
  }, {
    key: "intervalMS",
    get: function get() {
      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
    }
  }, {
    key: "start",
    value: function start() {
      if (!this._timeout) {
        this.schedule();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
        this.generation += 1;
        this._timeout = undefined;
      }
    }
  }, {
    key: "schedule",
    value: function schedule() {
      var _this2 = this;

      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
      }

      this._timeout = (0, timers_1.setTimeout)(function () {
        return _this2._poll();
      }, this.intervalMS);
    }
  }, {
    key: "success",
    value: function success(srvRecords) {
      this.haMode = false;
      this.schedule();
      this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
    }
  }, {
    key: "failure",
    value: function failure(message, obj) {
      this.logger.warn(message, obj);
      this.haMode = true;
      this.schedule();
    }
  }, {
    key: "parentDomainMismatch",
    value: function parentDomainMismatch(srvRecord) {
      this.logger.warn("parent domain mismatch on SRV record (".concat(srvRecord.name, ":").concat(srvRecord.port, ")"), srvRecord);
    }
  }, {
    key: "_poll",
    value: function _poll() {
      var _this3 = this;

      var generation = this.generation;
      dns.resolveSrv(this.srvAddress, function (err, srvRecords) {
        if (generation !== _this3.generation) {
          return;
        }

        if (err) {
          _this3.failure('DNS error', err);

          return;
        }

        var finalAddresses = [];

        var _iterator = _createForOfIteratorHelper(srvRecords),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var record = _step.value;

            if (matchesParentDomain(record.name, _this3.srvHost)) {
              finalAddresses.push(record);
            } else {
              _this3.parentDomainMismatch(record);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (!finalAddresses.length) {
          _this3.failure('No valid addresses found at host');

          return;
        }

        _this3.success(finalAddresses);
      });
    }
  }]);

  return SrvPoller;
}(mongo_types_1.TypedEventEmitter);

exports.SrvPoller = SrvPoller;
/** @event */

SrvPoller.SRV_RECORD_DISCOVERY = 'srvRecordDiscovery';

/***/ }),

/***/ 4228:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _ref;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ServerCapabilities = exports.Topology = void 0;

var Denque = __webpack_require__(2279);

var timers_1 = __webpack_require__(9512);

var util_1 = __webpack_require__(3837);

var bson_1 = __webpack_require__(53);

var connection_string_1 = __webpack_require__(6964);

var constants_1 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var mongo_types_1 = __webpack_require__(3738);

var read_preference_1 = __webpack_require__(3985);

var utils_1 = __webpack_require__(4356);

var common_1 = __webpack_require__(4118);

var events_1 = __webpack_require__(9874);

var server_1 = __webpack_require__(4310);

var server_description_1 = __webpack_require__(1071);

var server_selection_1 = __webpack_require__(2557);

var srv_polling_1 = __webpack_require__(9654);

var topology_description_1 = __webpack_require__(4201); // Global state


var globalTopologyCounter = 0;
var stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, common_1.STATE_CONNECTING]), _defineProperty(_ref, common_1.STATE_CONNECTING, [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CONNECTED, [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _ref));
/** @internal */

var kCancelled = Symbol('cancelled');
/** @internal */

var kWaitQueue = Symbol('waitQueue');
/**
 * A container of server instances representing a connection to a MongoDB topology.
 * @internal
 */

var Topology = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(Topology, _mongo_types_1$TypedE);

  var _super = _createSuper(Topology);

  /**
   * @param seedlist - a list of HostAddress instances to connect to
   */
  function Topology(seeds, options) {
    var _this;

    _classCallCheck(this, Topology);

    var _a;

    _this = _super.call(this); // Legacy CSFLE support

    _this.bson = Object.create(null);
    _this.bson.serialize = bson_1.serialize;
    _this.bson.deserialize = bson_1.deserialize; // Options should only be undefined in tests, MongoClient will always have defined options

    options = options !== null && options !== void 0 ? options : _objectSpread(_objectSpread({
      hosts: [utils_1.HostAddress.fromString('localhost:27017')]
    }, Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries())), Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries()));

    if (typeof seeds === 'string') {
      seeds = [utils_1.HostAddress.fromString(seeds)];
    } else if (!Array.isArray(seeds)) {
      seeds = [seeds];
    }

    var seedlist = [];

    var _iterator = _createForOfIteratorHelper(seeds),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var seed = _step.value;

        if (typeof seed === 'string') {
          seedlist.push(utils_1.HostAddress.fromString(seed));
        } else if (seed instanceof utils_1.HostAddress) {
          seedlist.push(seed);
        } else {
          // FIXME(NODE-3483): May need to be a MongoParseError
          throw new error_1.MongoRuntimeError("Topology cannot be constructed from ".concat(JSON.stringify(seed)));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var topologyType = topologyTypeFromOptions(options);
    var topologyId = globalTopologyCounter++;
    var selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
    var serverDescriptions = new Map();

    var _iterator2 = _createForOfIteratorHelper(selectedHosts),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var hostAddress = _step2.value;
        serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    _this[kWaitQueue] = new Denque();
    _this.s = {
      // the id of this topology
      id: topologyId,
      // passed in options
      options: options,
      // initial seedlist of servers to connect to
      seedlist: seedlist,
      // initial state
      state: common_1.STATE_CLOSED,
      // the topology description
      description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),
      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
      heartbeatFrequencyMS: options.heartbeatFrequencyMS,
      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
      // a map of server instances to normalized addresses
      servers: new Map(),
      credentials: options === null || options === void 0 ? void 0 : options.credentials,
      clusterTime: undefined,
      // timer management
      connectionTimers: new Set(),
      detectShardedTopology: function detectShardedTopology(ev) {
        return _this.detectShardedTopology(ev);
      },
      detectSrvRecords: function detectSrvRecords(ev) {
        return _this.detectSrvRecords(ev);
      }
    };

    if (options.srvHost && !options.loadBalanced) {
      _this.s.srvPoller = (_a = options.srvPoller) !== null && _a !== void 0 ? _a : new srv_polling_1.SrvPoller({
        heartbeatFrequencyMS: _this.s.heartbeatFrequencyMS,
        srvHost: options.srvHost,
        srvMaxHosts: options.srvMaxHosts,
        srvServiceName: options.srvServiceName
      });

      _this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this.s.detectShardedTopology);
    }

    return _this;
  }

  _createClass(Topology, [{
    key: "detectShardedTopology",
    value: function detectShardedTopology(event) {
      var _a, _b, _c;

      var previousType = event.previousDescription.type;
      var newType = event.newDescription.type;
      var transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
      var srvListeners = (_a = this.s.srvPoller) === null || _a === void 0 ? void 0 : _a.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
      var listeningToSrvPolling = !!(srvListeners === null || srvListeners === void 0 ? void 0 : srvListeners.includes(this.s.detectSrvRecords));

      if (transitionToSharded && !listeningToSrvPolling) {
        (_b = this.s.srvPoller) === null || _b === void 0 ? void 0 : _b.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        (_c = this.s.srvPoller) === null || _c === void 0 ? void 0 : _c.start();
      }
    }
  }, {
    key: "detectSrvRecords",
    value: function detectSrvRecords(ev) {
      var previousTopologyDescription = this.s.description;
      this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);

      if (this.s.description === previousTopologyDescription) {
        // Nothing changed, so return
        return;
      }

      updateServers(this);
      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
    }
    /**
     * @returns A `TopologyDescription` for this topology
     */

  }, {
    key: "description",
    get: function get() {
      return this.s.description;
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      return this.s.options.loadBalanced;
    }
  }, {
    key: "capabilities",
    get: function get() {
      return new ServerCapabilities(this.lastHello());
    }
    /** Initiate server connect */

  }, {
    key: "connect",
    value: function connect(options, callback) {
      var _this2 = this;

      var _a;

      if (typeof options === 'function') callback = options, options = {};
      options = options !== null && options !== void 0 ? options : {};

      if (this.s.state === common_1.STATE_CONNECTED) {
        if (typeof callback === 'function') {
          callback();
        }

        return;
      }

      stateTransition(this, common_1.STATE_CONNECTING); // emit SDAM monitoring events

      this.emit(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id)); // emit an event for the topology change

      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), // initial is always Unknown
      this.s.description)); // connect all known servers, then attempt server selection to connect

      var serverDescriptions = Array.from(this.s.description.servers.values());
      this.s.servers = new Map(serverDescriptions.map(function (serverDescription) {
        return [serverDescription.address, createAndConnectServer(_this2, serverDescription)];
      })); // In load balancer mode we need to fake a server description getting
      // emitted from the monitor, since the monitor doesn't exist.

      if (this.s.options.loadBalanced) {
        var _iterator3 = _createForOfIteratorHelper(serverDescriptions),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var description = _step3.value;
            var newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {
              loadBalanced: this.s.options.loadBalanced
            });
            this.serverUpdateHandler(newDescription);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }

      var exitWithError = function exitWithError(error) {
        return callback ? callback(error) : _this2.emit(Topology.ERROR, error);
      };

      var readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;
      this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), options, function (err, server) {
        if (err) {
          return _this2.close({
            force: false
          }, function () {
            return exitWithError(err);
          });
        } // TODO: NODE-2471


        var skipPingOnConnect = _this2.s.options[Symbol["for"]('@@mdb.skipPingOnConnect')] === true;

        if (!skipPingOnConnect && server && _this2.s.credentials) {
          server.command((0, utils_1.ns)('admin.$cmd'), {
            ping: 1
          }, {}, function (err) {
            if (err) {
              return exitWithError(err);
            }

            stateTransition(_this2, common_1.STATE_CONNECTED);

            _this2.emit(Topology.OPEN, _this2);

            _this2.emit(Topology.CONNECT, _this2);

            callback === null || callback === void 0 ? void 0 : callback(undefined, _this2);
          });
          return;
        }

        stateTransition(_this2, common_1.STATE_CONNECTED);

        _this2.emit(Topology.OPEN, _this2);

        _this2.emit(Topology.CONNECT, _this2);

        callback === null || callback === void 0 ? void 0 : callback(undefined, _this2);
      });
    }
    /** Close this topology */

  }, {
    key: "close",
    value: function close(options, callback) {
      var _this3 = this;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (typeof options === 'boolean') {
        options = {
          force: options
        };
      }

      options = options !== null && options !== void 0 ? options : {};

      if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
        return callback === null || callback === void 0 ? void 0 : callback();
      }

      var destroyedServers = Array.from(this.s.servers.values(), function (server) {
        return (0, util_1.promisify)(destroyServer)(server, _this3, options);
      });
      Promise.all(destroyedServers).then(function () {
        _this3.s.servers.clear();

        stateTransition(_this3, common_1.STATE_CLOSING);
        drainWaitQueue(_this3[kWaitQueue], new error_1.MongoTopologyClosedError());
        (0, common_1.drainTimerQueue)(_this3.s.connectionTimers);

        if (_this3.s.srvPoller) {
          _this3.s.srvPoller.stop();

          _this3.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, _this3.s.detectSrvRecords);
        }

        _this3.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this3.s.detectShardedTopology);

        stateTransition(_this3, common_1.STATE_CLOSED); // emit an event for close

        _this3.emit(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(_this3.s.id));
      })["finally"](function () {
        return callback === null || callback === void 0 ? void 0 : callback();
      });
    }
    /**
     * Selects a server according to the selection predicate provided
     *
     * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window
     * @param options - Optional settings related to server selection
     * @param callback - The callback used to indicate success or failure
     * @returns An instance of a `Server` meeting the criteria of the predicate provided
     */

  }, {
    key: "selectServer",
    value: function selectServer(selector, options, callback) {
      var _this4 = this;

      var serverSelector;

      if (typeof selector !== 'function') {
        if (typeof selector === 'string') {
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
        } else {
          var readPreference;

          if (selector instanceof read_preference_1.ReadPreference) {
            readPreference = selector;
          } else {
            read_preference_1.ReadPreference.translate(options);
            readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
          }

          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
        }
      } else {
        serverSelector = selector;
      }

      options = Object.assign({}, {
        serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS
      }, options);
      var isSharded = this.description.type === common_1.TopologyType.Sharded;
      var session = options.session;
      var transaction = session && session.transaction;

      if (isSharded && transaction && transaction.server) {
        callback(undefined, transaction.server);
        return;
      }

      var waitQueueMember = {
        serverSelector: serverSelector,
        transaction: transaction,
        callback: callback
      };
      var serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;

      if (serverSelectionTimeoutMS) {
        waitQueueMember.timer = (0, timers_1.setTimeout)(function () {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = undefined;
          var timeoutError = new error_1.MongoServerSelectionError("Server selection timed out after ".concat(serverSelectionTimeoutMS, " ms"), _this4.description);
          waitQueueMember.callback(timeoutError);
        }, serverSelectionTimeoutMS);
      }

      this[kWaitQueue].push(waitQueueMember);
      processWaitQueue(this);
    } // Sessions related methods

    /**
     * @returns Whether the topology should initiate selection to determine session support
     */

  }, {
    key: "shouldCheckForSessionSupport",
    value: function shouldCheckForSessionSupport() {
      if (this.description.type === common_1.TopologyType.Single) {
        return !this.description.hasKnownServers;
      }

      return !this.description.hasDataBearingServers;
    }
    /**
     * @returns Whether sessions are supported on the current topology
     */

  }, {
    key: "hasSessionSupport",
    value: function hasSessionSupport() {
      return this.loadBalanced || this.description.logicalSessionTimeoutMinutes != null;
    }
    /**
     * Update the internal TopologyDescription with a ServerDescription
     *
     * @param serverDescription - The server to update in the internal list of server descriptions
     */

  }, {
    key: "serverUpdateHandler",
    value: function serverUpdateHandler(serverDescription) {
      if (!this.s.description.hasServer(serverDescription.address)) {
        return;
      } // ignore this server update if its from an outdated topologyVersion


      if (isStaleServerDescription(this.s.description, serverDescription)) {
        return;
      } // these will be used for monitoring events later


      var previousTopologyDescription = this.s.description;
      var previousServerDescription = this.s.description.servers.get(serverDescription.address);

      if (!previousServerDescription) {
        return;
      } // Driver Sessions Spec: "Whenever a driver receives a cluster time from
      // a server it MUST compare it to the current highest seen cluster time
      // for the deployment. If the new cluster time is higher than the
      // highest seen cluster time it MUST become the new highest seen cluster
      // time. Two cluster times are compared using only the BsonTimestamp
      // value of the clusterTime embedded field."


      var clusterTime = serverDescription.$clusterTime;

      if (clusterTime) {
        (0, common_1._advanceClusterTime)(this, clusterTime);
      } // If we already know all the information contained in this updated description, then
      // we don't need to emit SDAM events, but still need to update the description, in order
      // to keep client-tracked attributes like last update time and round trip time up to date


      var equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription); // first update the TopologyDescription

      this.s.description = this.s.description.update(serverDescription);

      if (this.s.description.compatibilityError) {
        this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
        return;
      } // emit monitoring events for this change


      if (!equalDescriptions) {
        var newDescription = this.s.description.servers.get(serverDescription.address);

        if (newDescription) {
          this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
        }
      } // update server list from updated descriptions


      updateServers(this, serverDescription); // attempt to resolve any outstanding server selection attempts

      if (this[kWaitQueue].length > 0) {
        processWaitQueue(this);
      }

      if (!equalDescriptions) {
        this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
    }
  }, {
    key: "auth",
    value: function auth(credentials, callback) {
      if (typeof credentials === 'function') callback = credentials, credentials = undefined;
      if (typeof callback === 'function') callback(undefined, true);
    }
  }, {
    key: "clientMetadata",
    get: function get() {
      return this.s.options.metadata;
    }
  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.s.state === common_1.STATE_CONNECTED;
    }
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return this.s.state === common_1.STATE_CLOSED;
    }
    /**
     * @deprecated This function is deprecated and will be removed in the next major version.
     */

  }, {
    key: "unref",
    value: function unref() {
      (0, utils_1.emitWarning)('`unref` is a noop and will be removed in the next major version');
    } // NOTE: There are many places in code where we explicitly check the last hello
    //       to do feature support detection. This should be done any other way, but for
    //       now we will just return the first hello seen, which should suffice.

  }, {
    key: "lastHello",
    value: function lastHello() {
      var serverDescriptions = Array.from(this.description.servers.values());
      if (serverDescriptions.length === 0) return {};
      var sd = serverDescriptions.filter(function (sd) {
        return sd.type !== common_1.ServerType.Unknown;
      })[0];
      var result = sd || {
        maxWireVersion: this.description.commonWireVersion
      };
      return result;
    }
  }, {
    key: "commonWireVersion",
    get: function get() {
      return this.description.commonWireVersion;
    }
  }, {
    key: "logicalSessionTimeoutMinutes",
    get: function get() {
      return this.description.logicalSessionTimeoutMinutes;
    }
  }, {
    key: "clusterTime",
    get: function get() {
      return this.s.clusterTime;
    },
    set: function set(clusterTime) {
      this.s.clusterTime = clusterTime;
    }
  }]);

  return Topology;
}(mongo_types_1.TypedEventEmitter);

exports.Topology = Topology;
/** @event */

Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
/** @event */

Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
/** @event */

Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
/** @event */

Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
/** @event */

Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
/** @event */

Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
/** @event */

Topology.ERROR = constants_1.ERROR;
/** @event */

Topology.OPEN = constants_1.OPEN;
/** @event */

Topology.CONNECT = constants_1.CONNECT;
/** @event */

Topology.CLOSE = constants_1.CLOSE;
/** @event */

Topology.TIMEOUT = constants_1.TIMEOUT;
/** Destroys a server, and removes all event listeners from the instance */

function destroyServer(server, topology, options, callback) {
  options = options !== null && options !== void 0 ? options : {};

  var _iterator4 = _createForOfIteratorHelper(constants_1.LOCAL_SERVER_EVENTS),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var event = _step4.value;
      server.removeAllListeners(event);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  server.destroy(options, function () {
    topology.emit(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));

    var _iterator5 = _createForOfIteratorHelper(constants_1.SERVER_RELAY_EVENTS),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var event = _step5.value;
        server.removeAllListeners(event);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    if (typeof callback === 'function') {
      callback();
    }
  });
}
/** Predicts the TopologyType from options */


function topologyTypeFromOptions(options) {
  if (options === null || options === void 0 ? void 0 : options.directConnection) {
    return common_1.TopologyType.Single;
  }

  if (options === null || options === void 0 ? void 0 : options.replicaSet) {
    return common_1.TopologyType.ReplicaSetNoPrimary;
  }

  if (options === null || options === void 0 ? void 0 : options.loadBalanced) {
    return common_1.TopologyType.LoadBalanced;
  }

  return common_1.TopologyType.Unknown;
}
/**
 * Creates new server instances and attempts to connect them
 *
 * @param topology - The topology that this server belongs to
 * @param serverDescription - The description for the server to initialize and connect to
 */


function createAndConnectServer(topology, serverDescription) {
  topology.emit(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
  var server = new server_1.Server(topology, serverDescription, topology.s.options);

  var _iterator6 = _createForOfIteratorHelper(constants_1.SERVER_RELAY_EVENTS),
      _step6;

  try {
    var _loop = function _loop() {
      var event = _step6.value;
      server.on(event, function (e) {
        return topology.emit(event, e);
      });
    };

    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  server.on(server_1.Server.DESCRIPTION_RECEIVED, function (description) {
    return topology.serverUpdateHandler(description);
  });
  server.connect();
  return server;
}
/**
 * @param topology - Topology to update.
 * @param incomingServerDescription - New server description.
 */


function updateServers(topology, incomingServerDescription) {
  // update the internal server's description
  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
    var server = topology.s.servers.get(incomingServerDescription.address);

    if (server) {
      server.s.description = incomingServerDescription;
    }
  } // add new servers for all descriptions we currently don't know about locally


  var _iterator7 = _createForOfIteratorHelper(topology.description.servers.values()),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var serverDescription = _step7.value;

      if (!topology.s.servers.has(serverDescription.address)) {
        var _server = createAndConnectServer(topology, serverDescription);

        topology.s.servers.set(serverDescription.address, _server);
      }
    } // for all servers no longer known, remove their descriptions and destroy their instances

  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  var _iterator8 = _createForOfIteratorHelper(topology.s.servers),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var entry = _step8.value;
      var serverAddress = entry[0];

      if (topology.description.hasServer(serverAddress)) {
        continue;
      }

      if (!topology.s.servers.has(serverAddress)) {
        continue;
      }

      var _server2 = topology.s.servers.get(serverAddress);

      topology.s.servers["delete"](serverAddress); // prepare server for garbage collection

      if (_server2) {
        destroyServer(_server2, topology);
      }
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
}

function drainWaitQueue(queue, err) {
  while (queue.length) {
    var waitQueueMember = queue.shift();

    if (!waitQueueMember) {
      continue;
    }

    if (waitQueueMember.timer) {
      (0, timers_1.clearTimeout)(waitQueueMember.timer);
    }

    if (!waitQueueMember[kCancelled]) {
      waitQueueMember.callback(err);
    }
  }
}

function processWaitQueue(topology) {
  if (topology.s.state === common_1.STATE_CLOSED) {
    drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError());
    return;
  }

  var isSharded = topology.description.type === common_1.TopologyType.Sharded;
  var serverDescriptions = Array.from(topology.description.servers.values());
  var membersToProcess = topology[kWaitQueue].length;

  for (var i = 0; i < membersToProcess; ++i) {
    var waitQueueMember = topology[kWaitQueue].shift();

    if (!waitQueueMember) {
      continue;
    }

    if (waitQueueMember[kCancelled]) {
      continue;
    }

    var selectedDescriptions = void 0;

    try {
      var serverSelector = waitQueueMember.serverSelector;
      selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
    } catch (e) {
      if (waitQueueMember.timer) {
        (0, timers_1.clearTimeout)(waitQueueMember.timer);
      }

      waitQueueMember.callback(e);
      continue;
    }

    var selectedServer = void 0;

    if (selectedDescriptions.length === 0) {
      topology[kWaitQueue].push(waitQueueMember);
      continue;
    } else if (selectedDescriptions.length === 1) {
      selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
    } else {
      // don't shuffle the array if there are only two elements
      var descriptions = selectedDescriptions.length === 2 ? selectedDescriptions : (0, utils_1.shuffle)(selectedDescriptions, 2);
      var server1 = topology.s.servers.get(descriptions[0].address);
      var server2 = topology.s.servers.get(descriptions[1].address);
      selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;
    }

    if (!selectedServer) {
      waitQueueMember.callback(new error_1.MongoServerSelectionError('server selection returned a server description but the server was not found in the topology', topology.description));
      return;
    }

    var transaction = waitQueueMember.transaction;

    if (isSharded && transaction && transaction.isActive && selectedServer) {
      transaction.pinServer(selectedServer);
    }

    if (waitQueueMember.timer) {
      (0, timers_1.clearTimeout)(waitQueueMember.timer);
    }

    waitQueueMember.callback(undefined, selectedServer);
  }

  if (topology[kWaitQueue].length > 0) {
    // ensure all server monitors attempt monitoring soon
    var _iterator9 = _createForOfIteratorHelper(topology.s.servers),
        _step9;

    try {
      var _loop2 = function _loop2() {
        var _step9$value = _slicedToArray(_step9.value, 2),
            server = _step9$value[1];

        process.nextTick(function scheduleServerCheck() {
          return server.requestCheck();
        });
      };

      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        _loop2();
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
  }
}

function isStaleServerDescription(topologyDescription, incomingServerDescription) {
  var currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
  var currentTopologyVersion = currentServerDescription === null || currentServerDescription === void 0 ? void 0 : currentServerDescription.topologyVersion;
  return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
}
/** @public */


var ServerCapabilities = /*#__PURE__*/function () {
  function ServerCapabilities(hello) {
    _classCallCheck(this, ServerCapabilities);

    this.minWireVersion = hello.minWireVersion || 0;
    this.maxWireVersion = hello.maxWireVersion || 0;
  }

  _createClass(ServerCapabilities, [{
    key: "hasAggregationCursor",
    get: function get() {
      return this.maxWireVersion >= 1;
    }
  }, {
    key: "hasWriteCommands",
    get: function get() {
      return this.maxWireVersion >= 2;
    }
  }, {
    key: "hasTextSearch",
    get: function get() {
      return this.minWireVersion >= 0;
    }
  }, {
    key: "hasAuthCommands",
    get: function get() {
      return this.maxWireVersion >= 1;
    }
  }, {
    key: "hasListCollectionsCommand",
    get: function get() {
      return this.maxWireVersion >= 3;
    }
  }, {
    key: "hasListIndexesCommand",
    get: function get() {
      return this.maxWireVersion >= 3;
    }
  }, {
    key: "supportsSnapshotReads",
    get: function get() {
      return this.maxWireVersion >= 13;
    }
  }, {
    key: "commandsTakeWriteConcern",
    get: function get() {
      return this.maxWireVersion >= 5;
    }
  }, {
    key: "commandsTakeCollation",
    get: function get() {
      return this.maxWireVersion >= 5;
    }
  }]);

  return ServerCapabilities;
}();

exports.ServerCapabilities = ServerCapabilities;

/***/ }),

/***/ 4201:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TopologyDescription = void 0;

var WIRE_CONSTANTS = __webpack_require__(8871);

var error_1 = __webpack_require__(9271);

var utils_1 = __webpack_require__(4356);

var common_1 = __webpack_require__(4118);

var server_description_1 = __webpack_require__(1071); // constants related to compatibility checks


var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
var MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
var MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
var NON_PRIMARY_RS_MEMBERS = new Set([common_1.ServerType.RSSecondary, common_1.ServerType.RSArbiter, common_1.ServerType.RSOther]);
/**
 * Representation of a deployment of servers
 * @public
 */

var TopologyDescription = /*#__PURE__*/function () {
  /**
   * Create a TopologyDescription
   */
  function TopologyDescription(topologyType) {
    var serverDescriptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var maxSetVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var maxElectionId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var commonWireVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

    _classCallCheck(this, TopologyDescription);

    var _a, _b;

    options = options !== null && options !== void 0 ? options : {};
    this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;
    this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();
    this.stale = false;
    this.compatible = true;
    this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;
    this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 15;
    this.setName = setName !== null && setName !== void 0 ? setName : null;
    this.maxElectionId = maxElectionId !== null && maxElectionId !== void 0 ? maxElectionId : null;
    this.maxSetVersion = maxSetVersion !== null && maxSetVersion !== void 0 ? maxSetVersion : null;
    this.commonWireVersion = commonWireVersion !== null && commonWireVersion !== void 0 ? commonWireVersion : 0; // determine server compatibility

    var _iterator = _createForOfIteratorHelper(this.servers.values()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var serverDescription = _step.value;

        // Load balancer mode is always compatible.
        if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {
          continue;
        }

        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = "Server at ".concat(serverDescription.address, " requires wire version ").concat(serverDescription.minWireVersion, ", but this version of the driver only supports up to ").concat(MAX_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(MAX_SUPPORTED_SERVER_VERSION, ")");
        }

        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = "Server at ".concat(serverDescription.address, " reports wire version ").concat(serverDescription.maxWireVersion, ", but this version of the driver requires at least ").concat(MIN_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(MIN_SUPPORTED_SERVER_VERSION, ").");
          break;
        }
      } // Whenever a client updates the TopologyDescription from a hello response, it MUST set
      // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes
      // value among ServerDescriptions of all data-bearing server types. If any have a null
      // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be
      // set to null.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.logicalSessionTimeoutMinutes = null;

    var _iterator2 = _createForOfIteratorHelper(this.servers),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
            server = _step2$value[1];

        if (server.isReadable) {
          if (server.logicalSessionTimeoutMinutes == null) {
            // If any of the servers have a null logicalSessionsTimeout, then the whole topology does
            this.logicalSessionTimeoutMinutes = null;
            break;
          }

          if (this.logicalSessionTimeoutMinutes == null) {
            // First server with a non null logicalSessionsTimeout
            this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
            continue;
          } // Always select the smaller of the:
          // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout


          this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  /**
   * Returns a new TopologyDescription based on the SrvPollingEvent
   * @internal
   */


  _createClass(TopologyDescription, [{
    key: "updateFromSrvPollingEvent",
    value: function updateFromSrvPollingEvent(ev) {
      var srvMaxHosts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      /** The SRV addresses defines the set of addresses we should be using */
      var incomingHostnames = ev.hostnames();
      var currentHostnames = new Set(this.servers.keys());
      var hostnamesToAdd = new Set(incomingHostnames);
      var hostnamesToRemove = new Set();

      var _iterator3 = _createForOfIteratorHelper(currentHostnames),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var hostname = _step3.value;
          // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames
          hostnamesToAdd["delete"](hostname);

          if (!incomingHostnames.has(hostname)) {
            // If the SRV Records no longer include this hostname
            // we have to stop using it
            hostnamesToRemove.add(hostname);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
        // No new hosts to add and none to remove
        return this;
      }

      var serverDescriptions = new Map(this.servers);

      var _iterator4 = _createForOfIteratorHelper(hostnamesToRemove),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var removedHost = _step4.value;
          serverDescriptions["delete"](removedHost);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      if (hostnamesToAdd.size > 0) {
        if (srvMaxHosts === 0) {
          // Add all!
          var _iterator5 = _createForOfIteratorHelper(hostnamesToAdd),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var hostToAdd = _step5.value;
              serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        } else if (serverDescriptions.size < srvMaxHosts) {
          // Add only the amount needed to get us back to srvMaxHosts
          var selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);

          var _iterator6 = _createForOfIteratorHelper(selectedHosts),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var selectedHostToAdd = _step6.value;
              serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
      }

      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, {
        heartbeatFrequencyMS: this.heartbeatFrequencyMS,
        localThresholdMS: this.localThresholdMS
      });
    }
    /**
     * Returns a copy of this description updated with a given ServerDescription
     * @internal
     */

  }, {
    key: "update",
    value: function update(serverDescription) {
      var address = serverDescription.address; // potentially mutated values

      var topologyType = this.type,
          setName = this.setName,
          maxSetVersion = this.maxSetVersion,
          maxElectionId = this.maxElectionId,
          commonWireVersion = this.commonWireVersion;
      var serverType = serverDescription.type;
      var serverDescriptions = new Map(this.servers); // update common wire version

      if (serverDescription.maxWireVersion !== 0) {
        if (commonWireVersion == null) {
          commonWireVersion = serverDescription.maxWireVersion;
        } else {
          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
        }
      }

      if (typeof serverDescription.setName === 'string' && typeof setName === 'string' && serverDescription.setName !== setName) {
        if (topologyType === common_1.TopologyType.Single) {
          // "Single" Topology with setName mismatch is direct connection usage, mark unknown do not remove
          serverDescription = new server_description_1.ServerDescription(address);
        } else {
          serverDescriptions["delete"](address);
        }
      } // update the actual server description


      serverDescriptions.set(address, serverDescription);

      if (topologyType === common_1.TopologyType.Single) {
        // once we are defined as single, that never changes
        return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {
          heartbeatFrequencyMS: this.heartbeatFrequencyMS,
          localThresholdMS: this.localThresholdMS
        });
      }

      if (topologyType === common_1.TopologyType.Unknown) {
        if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
          serverDescriptions["delete"](address);
        } else {
          topologyType = topologyTypeForServerType(serverType);
        }
      }

      if (topologyType === common_1.TopologyType.Sharded) {
        if (!MONGOS_OR_UNKNOWN.has(serverType)) {
          serverDescriptions["delete"](address);
        }
      }

      if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions["delete"](address);
        }

        if (serverType === common_1.ServerType.RSPrimary) {
          var result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          var _result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);

          topologyType = _result[0];
          setName = _result[1];
        }
      }

      if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions["delete"](address);
          topologyType = checkHasPrimary(serverDescriptions);
        } else if (serverType === common_1.ServerType.RSPrimary) {
          var _result2 = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);

          topologyType = _result2[0];
          setName = _result2[1];
          maxSetVersion = _result2[2];
          maxElectionId = _result2[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
        } else {
          topologyType = checkHasPrimary(serverDescriptions);
        }
      }

      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {
        heartbeatFrequencyMS: this.heartbeatFrequencyMS,
        localThresholdMS: this.localThresholdMS
      });
    }
  }, {
    key: "error",
    get: function get() {
      var descriptionsWithError = Array.from(this.servers.values()).filter(function (sd) {
        return sd.error;
      });

      if (descriptionsWithError.length > 0) {
        return descriptionsWithError[0].error;
      }

      return null;
    }
    /**
     * Determines if the topology description has any known servers
     */

  }, {
    key: "hasKnownServers",
    get: function get() {
      return Array.from(this.servers.values()).some(function (sd) {
        return sd.type !== common_1.ServerType.Unknown;
      });
    }
    /**
     * Determines if this topology description has a data-bearing server available.
     */

  }, {
    key: "hasDataBearingServers",
    get: function get() {
      return Array.from(this.servers.values()).some(function (sd) {
        return sd.isDataBearing;
      });
    }
    /**
     * Determines if the topology has a definition for the provided address
     * @internal
     */

  }, {
    key: "hasServer",
    value: function hasServer(address) {
      return this.servers.has(address);
    }
  }]);

  return TopologyDescription;
}();

exports.TopologyDescription = TopologyDescription;

function topologyTypeForServerType(serverType) {
  switch (serverType) {
    case common_1.ServerType.Standalone:
      return common_1.TopologyType.Single;

    case common_1.ServerType.Mongos:
      return common_1.TopologyType.Sharded;

    case common_1.ServerType.RSPrimary:
      return common_1.TopologyType.ReplicaSetWithPrimary;

    case common_1.ServerType.RSOther:
    case common_1.ServerType.RSSecondary:
      return common_1.TopologyType.ReplicaSetNoPrimary;

    default:
      return common_1.TopologyType.Unknown;
  }
}

function updateRsFromPrimary(serverDescriptions, serverDescription) {
  var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var maxSetVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var maxElectionId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  setName = setName || serverDescription.setName;

  if (setName !== serverDescription.setName) {
    serverDescriptions["delete"](serverDescription.address);
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
  }

  var electionId = serverDescription.electionId ? serverDescription.electionId : null;

  if (serverDescription.setVersion && electionId) {
    if (maxSetVersion && maxElectionId) {
      if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
        // this primary is stale, we must remove it
        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
    }

    maxElectionId = serverDescription.electionId;
  }

  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
    maxSetVersion = serverDescription.setVersion;
  } // We've heard from the primary. Is it the same primary as before?


  var _iterator7 = _createForOfIteratorHelper(serverDescriptions),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _step7$value = _slicedToArray(_step7.value, 2),
          address = _step7$value[0],
          server = _step7$value[1];

      if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
        // Reset old primary's type to Unknown.
        serverDescriptions.set(address, new server_description_1.ServerDescription(server.address)); // There can only be one primary

        break;
      }
    } // Discover new hosts from this primary's response.

  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  serverDescription.allHosts.forEach(function (address) {
    if (!serverDescriptions.has(address)) {
      serverDescriptions.set(address, new server_description_1.ServerDescription(address));
    }
  }); // Remove hosts not in the response.

  var currentAddresses = Array.from(serverDescriptions.keys());
  var responseAddresses = serverDescription.allHosts;
  currentAddresses.filter(function (addr) {
    return responseAddresses.indexOf(addr) === -1;
  }).forEach(function (address) {
    serverDescriptions["delete"](address);
  });
  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
}

function updateRsWithPrimaryFromMember(serverDescriptions, serverDescription) {
  var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (setName == null) {
    // TODO(NODE-3483): should be an appropriate runtime error
    throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
  }

  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
    serverDescriptions["delete"](serverDescription.address);
  }

  return checkHasPrimary(serverDescriptions);
}

function updateRsNoPrimaryFromMember(serverDescriptions, serverDescription) {
  var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
  setName = setName !== null && setName !== void 0 ? setName : serverDescription.setName;

  if (setName !== serverDescription.setName) {
    serverDescriptions["delete"](serverDescription.address);
    return [topologyType, setName];
  }

  serverDescription.allHosts.forEach(function (address) {
    if (!serverDescriptions.has(address)) {
      serverDescriptions.set(address, new server_description_1.ServerDescription(address));
    }
  });

  if (serverDescription.me && serverDescription.address !== serverDescription.me) {
    serverDescriptions["delete"](serverDescription.address);
  }

  return [topologyType, setName];
}

function checkHasPrimary(serverDescriptions) {
  var _iterator8 = _createForOfIteratorHelper(serverDescriptions.values()),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var serverDescription = _step8.value;

      if (serverDescription.type === common_1.ServerType.RSPrimary) {
        return common_1.TopologyType.ReplicaSetWithPrimary;
      }
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  return common_1.TopologyType.ReplicaSetNoPrimary;
}

/***/ }),

/***/ 4408:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _a;

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;

var bson_1 = __webpack_require__(53);

var metrics_1 = __webpack_require__(8274);

var shared_1 = __webpack_require__(4242);

var constants_1 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var mongo_types_1 = __webpack_require__(3738);

var execute_operation_1 = __webpack_require__(7887);

var run_command_1 = __webpack_require__(5367);

var promise_provider_1 = __webpack_require__(8912);

var read_concern_1 = __webpack_require__(2027);

var read_preference_1 = __webpack_require__(3985);

var common_1 = __webpack_require__(4118);

var transactions_1 = __webpack_require__(3271);

var utils_1 = __webpack_require__(4356);

var minWireVersionForShardedTransactions = 8;
/** @internal */

var kServerSession = Symbol('serverSession');
/** @internal */

var kSnapshotTime = Symbol('snapshotTime');
/** @internal */

var kSnapshotEnabled = Symbol('snapshotEnabled');
/** @internal */

var kPinnedConnection = Symbol('pinnedConnection');
/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */

var kTxnNumberIncrement = Symbol('txnNumberIncrement');
/**
 * A class representing a client session on the server
 *
 * NOTE: not meant to be instantiated directly.
 * @public
 */

var ClientSession = /*#__PURE__*/function (_mongo_types_1$TypedE) {
  _inherits(ClientSession, _mongo_types_1$TypedE);

  var _super = _createSuper(ClientSession);

  /**
   * Create a client session.
   * @internal
   * @param client - The current client
   * @param sessionPool - The server session pool (Internal Class)
   * @param options - Optional settings
   * @param clientOptions - Optional settings provided when creating a MongoClient
   */
  function ClientSession(client, sessionPool, options, clientOptions) {
    var _this;

    _classCallCheck(this, ClientSession);

    _this = _super.call(this);
    /** @internal */

    _this[_a] = false;

    if (client == null) {
      // TODO(NODE-3483)
      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');
    }

    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
      // TODO(NODE-3483)
      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');
    }

    options = options !== null && options !== void 0 ? options : {};

    if (options.snapshot === true) {
      _this[kSnapshotEnabled] = true;

      if (options.causalConsistency === true) {
        throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
      }
    }

    _this.client = client;
    _this.sessionPool = sessionPool;
    _this.hasEnded = false;
    _this.clientOptions = clientOptions;
    _this.explicit = !!options.explicit;
    _this[kServerSession] = _this.explicit ? _this.sessionPool.acquire() : null;
    _this[kTxnNumberIncrement] = 0;
    _this.supports = {
      causalConsistency: options.snapshot !== true && options.causalConsistency !== false
    };
    _this.clusterTime = options.initialClusterTime;
    _this.operationTime = undefined;
    _this.owner = options.owner;
    _this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
    _this.transaction = new transactions_1.Transaction();
    return _this;
  }
  /** The server id associated with this session */


  _createClass(ClientSession, [{
    key: "id",
    get: function get() {
      var _b;

      return (_b = this[kServerSession]) === null || _b === void 0 ? void 0 : _b.id;
    }
  }, {
    key: "serverSession",
    get: function get() {
      var serverSession = this[kServerSession];

      if (serverSession == null) {
        if (this.explicit) {
          throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');
        }

        if (this.hasEnded) {
          throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');
        }

        serverSession = this.sessionPool.acquire();
        this[kServerSession] = serverSession;
      }

      return serverSession;
    }
    /** Whether or not this session is configured for snapshot reads */

  }, {
    key: "snapshotEnabled",
    get: function get() {
      return this[kSnapshotEnabled];
    }
  }, {
    key: "loadBalanced",
    get: function get() {
      var _b;

      return ((_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.description.type) === common_1.TopologyType.LoadBalanced;
    }
    /** @internal */

  }, {
    key: "pinnedConnection",
    get: function get() {
      return this[kPinnedConnection];
    }
    /** @internal */

  }, {
    key: "pin",
    value: function pin(conn) {
      if (this[kPinnedConnection]) {
        throw TypeError('Cannot pin multiple connections to the same session');
      }

      this[kPinnedConnection] = conn;
      conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
    }
    /** @internal */

  }, {
    key: "unpin",
    value: function unpin(options) {
      if (this.loadBalanced) {
        return maybeClearPinnedConnection(this, options);
      }

      this.transaction.unpinServer();
    }
  }, {
    key: "isPinned",
    get: function get() {
      return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;
    }
  }, {
    key: "endSession",
    value: function endSession(options, callback) {
      var _this2 = this;

      if (typeof options === 'function') callback = options, options = {};

      var finalOptions = _objectSpread({
        force: true
      }, options);

      return (0, utils_1.maybePromise)(callback, function (done) {
        if (_this2.hasEnded) {
          maybeClearPinnedConnection(_this2, finalOptions);
          return done();
        }

        var completeEndSession = function completeEndSession() {
          maybeClearPinnedConnection(_this2, finalOptions);
          var serverSession = _this2[kServerSession];

          if (serverSession != null) {
            // release the server session back to the pool
            _this2.sessionPool.release(serverSession); // Make sure a new serverSession never makes it onto this ClientSession


            Object.defineProperty(_this2, kServerSession, {
              value: ServerSession.clone(serverSession),
              writable: false
            });
          } // mark the session as ended, and emit a signal


          _this2.hasEnded = true;

          _this2.emit('ended', _this2); // spec indicates that we should ignore all errors for `endSessions`


          done();
        };

        if (_this2.inTransaction()) {
          // If we've reached endSession and the transaction is still active
          // by default we abort it
          _this2.abortTransaction(function (err) {
            if (err) return done(err);
            completeEndSession();
          });

          return;
        }

        completeEndSession();
      });
    }
    /**
     * Advances the operationTime for a ClientSession.
     *
     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
     */

  }, {
    key: "advanceOperationTime",
    value: function advanceOperationTime(operationTime) {
      if (this.operationTime == null) {
        this.operationTime = operationTime;
        return;
      }

      if (operationTime.greaterThan(this.operationTime)) {
        this.operationTime = operationTime;
      }
    }
    /**
     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession
     *
     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature
     */

  }, {
    key: "advanceClusterTime",
    value: function advanceClusterTime(clusterTime) {
      var _b, _c;

      if (!clusterTime || _typeof(clusterTime) !== 'object') {
        throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');
      }

      if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {
        throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
      }

      if (!clusterTime.signature || ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'number' && ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long' // apparently we decode the key to number?
      ) {
        throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
      }

      (0, common_1._advanceClusterTime)(this, clusterTime);
    }
    /**
     * Used to determine if this session equals another
     *
     * @param session - The session to compare to
     */

  }, {
    key: "equals",
    value: function equals(session) {
      if (!(session instanceof ClientSession)) {
        return false;
      }

      if (this.id == null || session.id == null) {
        return false;
      }

      return this.id.id.buffer.equals(session.id.id.buffer);
    }
    /**
     * Increment the transaction number on the internal ServerSession
     *
     * @privateRemarks
     * This helper increments a value stored on the client session that will be
     * added to the serverSession's txnNumber upon applying it to a command.
     * This is because the serverSession is lazily acquired after a connection is obtained
     */

  }, {
    key: "incrementTransactionNumber",
    value: function incrementTransactionNumber() {
      this[kTxnNumberIncrement] += 1;
    }
    /** @returns whether this session is currently in a transaction or not */

  }, {
    key: "inTransaction",
    value: function inTransaction() {
      return this.transaction.isActive;
    }
    /**
     * Starts a new transaction with the given options.
     *
     * @param options - Options for the transaction
     */

  }, {
    key: "startTransaction",
    value: function startTransaction(options) {
      var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;

      if (this[kSnapshotEnabled]) {
        throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');
      }

      if (this.inTransaction()) {
        throw new error_1.MongoTransactionError('Transaction already in progress');
      }

      if (this.isPinned && this.transaction.isCommitted) {
        this.unpin();
      }

      var topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);

      if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
        throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');
      } // increment txnNumber


      this.incrementTransactionNumber(); // create transaction state

      this.transaction = new transactions_1.Transaction({
        readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,
        writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,
        readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,
        maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS
      });
      this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
    }
  }, {
    key: "commitTransaction",
    value: function commitTransaction(callback) {
      var _this3 = this;

      return (0, utils_1.maybePromise)(callback, function (cb) {
        return endTransaction(_this3, 'commitTransaction', cb);
      });
    }
  }, {
    key: "abortTransaction",
    value: function abortTransaction(callback) {
      var _this4 = this;

      return (0, utils_1.maybePromise)(callback, function (cb) {
        return endTransaction(_this4, 'abortTransaction', cb);
      });
    }
    /**
     * This is here to ensure that ClientSession is never serialized to BSON.
     */

  }, {
    key: "toBSON",
    value: function toBSON() {
      throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');
    }
    /**
     * Runs a provided callback within a transaction, retrying either the commitTransaction operation
     * or entire transaction as needed (and when the error permits) to better ensure that
     * the transaction can complete successfully.
     *
     * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.
     * Any callbacks that do not return a Promise will result in undefined behavior.
     *
     * @remarks
     * This function:
     * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)
     * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`
     * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback
     *
     * Checkout a descriptive example here:
     * @see https://www.mongodb.com/developer/quickstart/node-transactions/
     *
     * @param fn - callback to run within a transaction
     * @param options - optional settings for the transaction
     * @returns A raw command response or undefined
     */

  }, {
    key: "withTransaction",
    value: function withTransaction(fn, options) {
      var startTime = (0, utils_1.now)();
      return attemptTransaction(this, startTime, fn, options);
    }
  }]);

  return ClientSession;
}(mongo_types_1.TypedEventEmitter);

exports.ClientSession = ClientSession;
_a = kSnapshotEnabled;
var MAX_WITH_TRANSACTION_TIMEOUT = 120000;
var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);

function hasNotTimedOut(startTime, max) {
  return (0, utils_1.calculateDurationInMs)(startTime) < max;
}

function isUnknownTransactionCommitResult(err) {
  var isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;
}

function maybeClearPinnedConnection(session, options) {
  // unpin a connection if it has been pinned
  var conn = session[kPinnedConnection];
  var error = options === null || options === void 0 ? void 0 : options.error;

  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
    return;
  }

  var topology = session.client.topology; // NOTE: the spec talks about what to do on a network error only, but the tests seem to
  //       to validate that we don't unpin on _all_ errors?

  if (conn && topology != null) {
    var servers = Array.from(topology.s.servers.values());
    var loadBalancer = servers[0];

    if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {
      loadBalancer.s.pool.checkIn(conn);
      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);

      if (options === null || options === void 0 ? void 0 : options.forceClear) {
        loadBalancer.s.pool.clear(conn.serviceId);
      }
    }

    session[kPinnedConnection] = undefined;
  }
}

exports.maybeClearPinnedConnection = maybeClearPinnedConnection;

function isMaxTimeMSExpiredError(err) {
  if (err == null || !(err instanceof error_1.MongoServerError)) {
    return false;
  }

  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
}

function attemptTransactionCommit(session, startTime, fn, options) {
  return session.commitTransaction()["catch"](function (err) {
    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
      if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {
        return attemptTransactionCommit(session, startTime, fn, options);
      }

      if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        return attemptTransaction(session, startTime, fn, options);
      }
    }

    throw err;
  });
}

var USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);

function userExplicitlyEndedTransaction(session) {
  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
}

function attemptTransaction(session, startTime, fn, options) {
  var Promise = promise_provider_1.PromiseProvider.get();
  session.startTransaction(options);
  var promise;

  try {
    promise = fn(session);
  } catch (err) {
    promise = Promise.reject(err);
  }

  if (!(0, utils_1.isPromiseLike)(promise)) {
    session.abortTransaction()["catch"](function () {
      return null;
    });
    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');
  }

  return promise.then(function () {
    if (userExplicitlyEndedTransaction(session)) {
      return;
    }

    return attemptTransactionCommit(session, startTime, fn, options);
  }, function (err) {
    function maybeRetryOrThrow(err) {
      if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
        return attemptTransaction(session, startTime, fn, options);
      }

      if (isMaxTimeMSExpiredError(err)) {
        err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
      }

      throw err;
    }

    if (session.inTransaction()) {
      return session.abortTransaction().then(function () {
        return maybeRetryOrThrow(err);
      });
    }

    return maybeRetryOrThrow(err);
  });
}

function endTransaction(session, commandName, callback) {
  // handle any initial problematic cases
  var txnState = session.transaction.state;

  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {
    callback(new error_1.MongoTransactionError('No transaction started'));
    return;
  }

  if (commandName === 'commitTransaction') {
    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
      // the transaction was never started, we can safely exit here
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
      callback();
      return;
    }

    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));
      return;
    }
  } else {
    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {
      // the transaction was never started, we can safely exit here
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
      callback();
      return;
    }

    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));
      return;
    }

    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));
      return;
    }
  } // construct and send the command


  var command = _defineProperty({}, commandName, 1); // apply a writeConcern if specified


  var writeConcern;

  if (session.transaction.options.writeConcern) {
    writeConcern = Object.assign({}, session.transaction.options.writeConcern);
  } else if (session.clientOptions && session.clientOptions.writeConcern) {
    writeConcern = {
      w: session.clientOptions.writeConcern.w
    };
  }

  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {
    writeConcern = Object.assign({
      wtimeout: 10000
    }, writeConcern, {
      w: 'majority'
    });
  }

  if (writeConcern) {
    Object.assign(command, {
      writeConcern: writeConcern
    });
  }

  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {
    Object.assign(command, {
      maxTimeMS: session.transaction.options.maxTimeMS
    });
  }

  function commandHandler(error, result) {
    if (commandName !== 'commitTransaction') {
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);

      if (session.loadBalanced) {
        maybeClearPinnedConnection(session, {
          force: false
        });
      } // The spec indicates that we should ignore all errors on `abortTransaction`


      return callback();
    }

    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);

    if (error instanceof error_1.MongoError) {
      if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {
        if (isUnknownTransactionCommitResult(error)) {
          error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult); // per txns spec, must unpin session in this case

          session.unpin({
            error: error
          });
        }
      } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        session.unpin({
          error: error
        });
      }
    }

    callback(error, result);
  }

  if (session.transaction.recoveryToken) {
    command.recoveryToken = session.transaction.recoveryToken;
  } // send the command


  (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {
    session: session,
    readPreference: read_preference_1.ReadPreference.primary,
    bypassPinningCheck: true
  }), function (error, result) {
    if (command.abortTransaction) {
      // always unpin on abort regardless of command outcome
      session.unpin();
    }

    if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {
      // SPEC-1185: apply majority write concern when retrying commitTransaction
      if (command.commitTransaction) {
        // per txns spec, must unpin session in this case
        session.unpin({
          force: true
        });
        command.writeConcern = Object.assign({
          wtimeout: 10000
        }, command.writeConcern, {
          w: 'majority'
        });
      }

      return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {
        session: session,
        readPreference: read_preference_1.ReadPreference.primary,
        bypassPinningCheck: true
      }), commandHandler);
    }

    commandHandler(error, result);
  });
}
/**
 * Reflects the existence of a session on the server. Can be reused by the session pool.
 * WARNING: not meant to be instantiated directly. For internal use only.
 * @public
 */


var ServerSession = /*#__PURE__*/function () {
  /** @internal */
  function ServerSession() {
    _classCallCheck(this, ServerSession);

    this.id = {
      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)
    };
    this.lastUse = (0, utils_1.now)();
    this.txnNumber = 0;
    this.isDirty = false;
  }
  /**
   * Determines if the server session has timed out.
   *
   * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
   */


  _createClass(ServerSession, [{
    key: "hasTimedOut",
    value: function hasTimedOut(sessionTimeoutMinutes) {
      // Take the difference of the lastUse timestamp and now, which will result in a value in
      // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`
      var idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);
      return idleTimeMinutes > sessionTimeoutMinutes - 1;
    }
    /**
     * @internal
     * Cloning meant to keep a readable reference to the server session data
     * after ClientSession has ended
     */

  }], [{
    key: "clone",
    value: function clone(serverSession) {
      var arrayBuffer = new ArrayBuffer(16);
      var idBytes = Buffer.from(arrayBuffer);
      idBytes.set(serverSession.id.id.buffer);
      var id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type); // Manual prototype construction to avoid modifying the constructor of this class

      return Object.setPrototypeOf({
        id: {
          id: id
        },
        lastUse: serverSession.lastUse,
        txnNumber: serverSession.txnNumber,
        isDirty: serverSession.isDirty
      }, ServerSession.prototype);
    }
  }]);

  return ServerSession;
}();

exports.ServerSession = ServerSession;
/**
 * Maintains a pool of Server Sessions.
 * For internal use only
 * @internal
 */

var ServerSessionPool = /*#__PURE__*/function () {
  function ServerSessionPool(client) {
    _classCallCheck(this, ServerSessionPool);

    if (client == null) {
      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');
    }

    this.client = client;
    this.sessions = [];
  }
  /**
   * Acquire a Server Session from the pool.
   * Iterates through each session in the pool, removing any stale sessions
   * along the way. The first non-stale session found is removed from the
   * pool and returned. If no non-stale session is found, a new ServerSession is created.
   */


  _createClass(ServerSessionPool, [{
    key: "acquire",
    value: function acquire() {
      var _b, _c, _d;

      var sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;
      var session = null; // Try to obtain from session pool

      while (this.sessions.length > 0) {
        var potentialSession = this.sessions.shift();

        if (potentialSession != null && (!!((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
          session = potentialSession;
          break;
        }
      } // If nothing valid came from the pool make a new one


      if (session == null) {
        session = new ServerSession();
      }

      return session;
    }
    /**
     * Release a session to the session pool
     * Adds the session back to the session pool if the session has not timed out yet.
     * This method also removes any stale sessions from the pool.
     *
     * @param session - The session to release to the pool
     */

  }, {
    key: "release",
    value: function release(session) {
      var _b, _c, _d;

      var sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;

      if (((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) && !sessionTimeoutMinutes) {
        this.sessions.unshift(session);
      }

      if (!sessionTimeoutMinutes) {
        return;
      }

      while (this.sessions.length) {
        var pooledSession = this.sessions[this.sessions.length - 1];

        if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
          this.sessions.pop();
        } else {
          break;
        }
      }

      if (!session.hasTimedOut(sessionTimeoutMinutes)) {
        if (session.isDirty) {
          return;
        } // otherwise, readd this session to the session pool


        this.sessions.unshift(session);
      }
    }
  }]);

  return ServerSessionPool;
}();

exports.ServerSessionPool = ServerSessionPool;
/**
 * Optionally decorate a command with sessions specific keys
 *
 * @param session - the session tracking transaction state
 * @param command - the command to decorate
 * @param options - Optional settings passed to calling operation
 *
 * @internal
 */

function applySession(session, command, options) {
  var _b, _c;

  if (session.hasEnded) {
    return new error_1.MongoExpiredSessionError();
  } // May acquire serverSession here


  var serverSession = session.serverSession;

  if (serverSession == null) {
    return new error_1.MongoRuntimeError('Unable to acquire server session');
  }

  if (((_b = options.writeConcern) === null || _b === void 0 ? void 0 : _b.w) === 0) {
    if (session && session.explicit) {
      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)
      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');
    }

    return;
  } // mark the last use of this session, and apply the `lsid`


  serverSession.lastUse = (0, utils_1.now)();
  command.lsid = serverSession.id;
  var inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
  var isRetryableWrite = !!options.willRetryWrite;

  if (isRetryableWrite || inTxnOrTxnCommand) {
    serverSession.txnNumber += session[kTxnNumberIncrement];
    session[kTxnNumberIncrement] = 0; // TODO(NODE-2674): Preserve int64 sent from MongoDB

    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
  }

  if (!inTxnOrTxnCommand) {
    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
    }

    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command, options)) {
      command.readConcern = command.readConcern || {};
      Object.assign(command.readConcern, {
        afterClusterTime: session.operationTime
      });
    } else if (session[kSnapshotEnabled]) {
      command.readConcern = command.readConcern || {
        level: read_concern_1.ReadConcernLevel.snapshot
      };

      if (session[kSnapshotTime] != null) {
        Object.assign(command.readConcern, {
          atClusterTime: session[kSnapshotTime]
        });
      }
    }

    return;
  } // now attempt to apply transaction-specific sessions data
  // `autocommit` must always be false to differentiate from retryable writes


  command.autocommit = false;

  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
    command.startTransaction = true;
    var readConcern = session.transaction.options.readConcern || ((_c = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _c === void 0 ? void 0 : _c.readConcern);

    if (readConcern) {
      command.readConcern = readConcern;
    }

    if (session.supports.causalConsistency && session.operationTime) {
      command.readConcern = command.readConcern || {};
      Object.assign(command.readConcern, {
        afterClusterTime: session.operationTime
      });
    }
  }

  return;
}

exports.applySession = applySession;

function updateSessionFromResponse(session, document) {
  var _b;

  if (document.$clusterTime) {
    (0, common_1._advanceClusterTime)(session, document.$clusterTime);
  }

  if (document.operationTime && session && session.supports.causalConsistency) {
    session.advanceOperationTime(document.operationTime);
  }

  if (document.recoveryToken && session && session.inTransaction()) {
    session.transaction._recoveryToken = document.recoveryToken;
  }

  if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {
    // find and aggregate commands return atClusterTime on the cursor
    // distinct includes it in the response body
    var atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;

    if (atClusterTime) {
      session[kSnapshotTime] = atClusterTime;
    }
  }
}

exports.updateSessionFromResponse = updateSessionFromResponse;

/***/ }),

/***/ 7462:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.formatSort = void 0;

var error_1 = __webpack_require__(9271);
/** @internal */


function prepareDirection() {
  var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var value = "".concat(direction).toLowerCase();
  if (isMeta(direction)) return direction;

  switch (value) {
    case 'ascending':
    case 'asc':
    case '1':
      return 1;

    case 'descending':
    case 'desc':
    case '-1':
      return -1;

    default:
      throw new error_1.MongoInvalidArgumentError("Invalid sort direction: ".concat(JSON.stringify(direction)));
  }
}
/** @internal */


function isMeta(t) {
  return _typeof(t) === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';
}
/** @internal */


function isPair(t) {
  if (Array.isArray(t) && t.length === 2) {
    try {
      prepareDirection(t[1]);
      return true;
    } catch (e) {
      return false;
    }
  }

  return false;
}

function isDeep(t) {
  return Array.isArray(t) && Array.isArray(t[0]);
}

function isMap(t) {
  return t instanceof Map && t.size > 0;
}
/** @internal */


function pairToMap(v) {
  return new Map([["".concat(v[0]), prepareDirection([v[1]])]]);
}
/** @internal */


function deepToMap(t) {
  var sortEntries = t.map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        v = _ref2[1];

    return ["".concat(k), prepareDirection(v)];
  });
  return new Map(sortEntries);
}
/** @internal */


function stringsToMap(t) {
  var sortEntries = t.map(function (key) {
    return ["".concat(key), 1];
  });
  return new Map(sortEntries);
}
/** @internal */


function objectToMap(t) {
  var sortEntries = Object.entries(t).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        k = _ref4[0],
        v = _ref4[1];

    return ["".concat(k), prepareDirection(v)];
  });
  return new Map(sortEntries);
}
/** @internal */


function mapToMap(t) {
  var sortEntries = Array.from(t).map(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        k = _ref6[0],
        v = _ref6[1];

    return ["".concat(k), prepareDirection(v)];
  });
  return new Map(sortEntries);
}
/** converts a Sort type into a type that is valid for the server (SortForCmd) */


function formatSort(sort, direction) {
  if (sort == null) return undefined;
  if (typeof sort === 'string') return new Map([[sort, prepareDirection(direction)]]);

  if (_typeof(sort) !== 'object') {
    throw new error_1.MongoInvalidArgumentError("Invalid sort format: ".concat(JSON.stringify(sort), " Sort must be a valid object"));
  }

  if (!Array.isArray(sort)) {
    return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;
  }

  if (!sort.length) return undefined;
  if (isDeep(sort)) return deepToMap(sort);
  if (isPair(sort)) return pairToMap(sort);
  return stringsToMap(sort);
}

exports.formatSort = formatSort;

/***/ }),

/***/ 3271:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _stateMachine;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isTransactionCommand = exports.Transaction = exports.TxnState = void 0;

var error_1 = __webpack_require__(9271);

var read_concern_1 = __webpack_require__(2027);

var read_preference_1 = __webpack_require__(3985);

var write_concern_1 = __webpack_require__(1473);
/** @internal */


exports.TxnState = Object.freeze({
  NO_TRANSACTION: 'NO_TRANSACTION',
  STARTING_TRANSACTION: 'STARTING_TRANSACTION',
  TRANSACTION_IN_PROGRESS: 'TRANSACTION_IN_PROGRESS',
  TRANSACTION_COMMITTED: 'TRANSACTION_COMMITTED',
  TRANSACTION_COMMITTED_EMPTY: 'TRANSACTION_COMMITTED_EMPTY',
  TRANSACTION_ABORTED: 'TRANSACTION_ABORTED'
});
var stateMachine = (_stateMachine = {}, _defineProperty(_stateMachine, exports.TxnState.NO_TRANSACTION, [exports.TxnState.NO_TRANSACTION, exports.TxnState.STARTING_TRANSACTION]), _defineProperty(_stateMachine, exports.TxnState.STARTING_TRANSACTION, [exports.TxnState.TRANSACTION_IN_PROGRESS, exports.TxnState.TRANSACTION_COMMITTED, exports.TxnState.TRANSACTION_COMMITTED_EMPTY, exports.TxnState.TRANSACTION_ABORTED]), _defineProperty(_stateMachine, exports.TxnState.TRANSACTION_IN_PROGRESS, [exports.TxnState.TRANSACTION_IN_PROGRESS, exports.TxnState.TRANSACTION_COMMITTED, exports.TxnState.TRANSACTION_ABORTED]), _defineProperty(_stateMachine, exports.TxnState.TRANSACTION_COMMITTED, [exports.TxnState.TRANSACTION_COMMITTED, exports.TxnState.TRANSACTION_COMMITTED_EMPTY, exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION]), _defineProperty(_stateMachine, exports.TxnState.TRANSACTION_ABORTED, [exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION]), _defineProperty(_stateMachine, exports.TxnState.TRANSACTION_COMMITTED_EMPTY, [exports.TxnState.TRANSACTION_COMMITTED_EMPTY, exports.TxnState.NO_TRANSACTION]), _stateMachine);
var ACTIVE_STATES = new Set([exports.TxnState.STARTING_TRANSACTION, exports.TxnState.TRANSACTION_IN_PROGRESS]);
var COMMITTED_STATES = new Set([exports.TxnState.TRANSACTION_COMMITTED, exports.TxnState.TRANSACTION_COMMITTED_EMPTY, exports.TxnState.TRANSACTION_ABORTED]);
/**
 * @public
 * A class maintaining state related to a server transaction. Internal Only
 */

var Transaction = /*#__PURE__*/function () {
  /** Create a transaction @internal */
  function Transaction(options) {
    _classCallCheck(this, Transaction);

    options = options !== null && options !== void 0 ? options : {};
    this.state = exports.TxnState.NO_TRANSACTION;
    this.options = {};
    var writeConcern = write_concern_1.WriteConcern.fromOptions(options);

    if (writeConcern) {
      if (writeConcern.w === 0) {
        throw new error_1.MongoTransactionError('Transactions do not support unacknowledged write concern');
      }

      this.options.writeConcern = writeConcern;
    }

    if (options.readConcern) {
      this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
    }

    if (options.readPreference) {
      this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
    }

    if (options.maxCommitTimeMS) {
      this.options.maxTimeMS = options.maxCommitTimeMS;
    } // TODO: This isn't technically necessary


    this._pinnedServer = undefined;
    this._recoveryToken = undefined;
  }
  /** @internal */


  _createClass(Transaction, [{
    key: "server",
    get: function get() {
      return this._pinnedServer;
    }
  }, {
    key: "recoveryToken",
    get: function get() {
      return this._recoveryToken;
    }
  }, {
    key: "isPinned",
    get: function get() {
      return !!this.server;
    }
    /** @returns Whether the transaction has started */

  }, {
    key: "isStarting",
    get: function get() {
      return this.state === exports.TxnState.STARTING_TRANSACTION;
    }
    /**
     * @returns Whether this session is presently in a transaction
     */

  }, {
    key: "isActive",
    get: function get() {
      return ACTIVE_STATES.has(this.state);
    }
  }, {
    key: "isCommitted",
    get: function get() {
      return COMMITTED_STATES.has(this.state);
    }
    /**
     * Transition the transaction in the state machine
     * @internal
     * @param nextState - The new state to transition to
     */

  }, {
    key: "transition",
    value: function transition(nextState) {
      var nextStates = stateMachine[this.state];

      if (nextStates && nextStates.includes(nextState)) {
        this.state = nextState;

        if (this.state === exports.TxnState.NO_TRANSACTION || this.state === exports.TxnState.STARTING_TRANSACTION || this.state === exports.TxnState.TRANSACTION_ABORTED) {
          this.unpinServer();
        }

        return;
      }

      throw new error_1.MongoRuntimeError("Attempted illegal state transition from [".concat(this.state, "] to [").concat(nextState, "]"));
    }
    /** @internal */

  }, {
    key: "pinServer",
    value: function pinServer(server) {
      if (this.isActive) {
        this._pinnedServer = server;
      }
    }
    /** @internal */

  }, {
    key: "unpinServer",
    value: function unpinServer() {
      this._pinnedServer = undefined;
    }
  }]);

  return Transaction;
}();

exports.Transaction = Transaction;

function isTransactionCommand(command) {
  return !!(command.commitTransaction || command.abortTransaction);
}

exports.isTransactionCommand = isTransactionCommand;

/***/ }),

/***/ 4356:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

var _marked = /*#__PURE__*/_regeneratorRuntime().mark(makeCounter);

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.commandSupportsReadConcern = exports.shuffle = exports.parsePackageVersion = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.checkCollectionName = exports.MAX_JS_INT = void 0;
exports.compareObjectId = exports.getMongoDBClientEncryption = void 0;

var crypto = __webpack_require__(6113);

var os = __webpack_require__(2037);

var timers_1 = __webpack_require__(9512);

var url_1 = __webpack_require__(7310);

var bson_1 = __webpack_require__(53);

var constants_1 = __webpack_require__(8871);

var constants_2 = __webpack_require__(1254);

var error_1 = __webpack_require__(9271);

var promise_provider_1 = __webpack_require__(8912);

var read_concern_1 = __webpack_require__(2027);

var read_preference_1 = __webpack_require__(3985);

var common_1 = __webpack_require__(4118);

var write_concern_1 = __webpack_require__(1473);

exports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;
/**
 * Throws if collectionName is not a valid mongodb collection namespace.
 * @internal
 */

function checkCollectionName(collectionName) {
  if ('string' !== typeof collectionName) {
    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');
  }

  if (!collectionName || collectionName.indexOf('..') !== -1) {
    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');
  }

  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
    // TODO(NODE-3483): Use MongoNamespace static method
    throw new error_1.MongoInvalidArgumentError("Collection names must not contain '$'");
  }

  if (collectionName.match(/^\.|\.$/) != null) {
    // TODO(NODE-3483): Use MongoNamespace static method
    throw new error_1.MongoInvalidArgumentError("Collection names must not start or end with '.'");
  } // Validate that we are not passing 0x00 in the collection name


  if (collectionName.indexOf('\x00') !== -1) {
    // TODO(NODE-3483): Use MongoNamespace static method
    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');
  }
}

exports.checkCollectionName = checkCollectionName;
/**
 * Ensure Hint field is in a shape we expect:
 * - object of index names mapping to 1 or -1
 * - just an index name
 * @internal
 */

function normalizeHintField(hint) {
  var finalHint = undefined;

  if (typeof hint === 'string') {
    finalHint = hint;
  } else if (Array.isArray(hint)) {
    finalHint = {};
    hint.forEach(function (param) {
      finalHint[param] = 1;
    });
  } else if (hint != null && _typeof(hint) === 'object') {
    finalHint = {};

    for (var name in hint) {
      finalHint[name] = hint[name];
    }
  }

  return finalHint;
}

exports.normalizeHintField = normalizeHintField;

var TO_STRING = function TO_STRING(object) {
  return Object.prototype.toString.call(object);
};
/**
 * Checks if arg is an Object:
 * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`
 * @internal
 */


function isObject(arg) {
  return '[object Object]' === TO_STRING(arg);
}

exports.isObject = isObject;
/** @internal */

function mergeOptions(target, source) {
  return _objectSpread(_objectSpread({}, target), source);
}

exports.mergeOptions = mergeOptions;
/** @internal */

function filterOptions(options, names) {
  var filterOptions = {};

  for (var name in options) {
    if (names.includes(name)) {
      filterOptions[name] = options[name];
    }
  } // Filtered options


  return filterOptions;
}

exports.filterOptions = filterOptions;
/**
 * Applies retryWrites: true to a command if retryWrites is set on the command's database.
 * @internal
 *
 * @param target - The target command to which we will apply retryWrites.
 * @param db - The database from which we can inherit a retryWrites value.
 */

function applyRetryableWrites(target, db) {
  var _a;

  if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {
    target.retryWrites = true;
  }

  return target;
}

exports.applyRetryableWrites = applyRetryableWrites;
/**
 * Applies a write concern to a command based on well defined inheritance rules, optionally
 * detecting support for the write concern in the first place.
 * @internal
 *
 * @param target - the target command we will be applying the write concern to
 * @param sources - sources where we can inherit default write concerns from
 * @param options - optional settings passed into a command for write concern overrides
 */

function applyWriteConcern(target, sources, options) {
  options = options !== null && options !== void 0 ? options : {};
  var db = sources.db;
  var coll = sources.collection;

  if (options.session && options.session.inTransaction()) {
    // writeConcern is not allowed within a multi-statement transaction
    if (target.writeConcern) {
      delete target.writeConcern;
    }

    return target;
  }

  var writeConcern = write_concern_1.WriteConcern.fromOptions(options);

  if (writeConcern) {
    return Object.assign(target, {
      writeConcern: writeConcern
    });
  }

  if (coll && coll.writeConcern) {
    return Object.assign(target, {
      writeConcern: Object.assign({}, coll.writeConcern)
    });
  }

  if (db && db.writeConcern) {
    return Object.assign(target, {
      writeConcern: Object.assign({}, db.writeConcern)
    });
  }

  return target;
}

exports.applyWriteConcern = applyWriteConcern;
/**
 * Checks if a given value is a Promise
 *
 * @typeParam T - The result type of maybePromise
 * @param maybePromise - An object that could be a promise
 * @returns true if the provided value is a Promise
 */

function isPromiseLike(maybePromise) {
  return !!maybePromise && typeof maybePromise.then === 'function';
}

exports.isPromiseLike = isPromiseLike;
/**
 * Applies collation to a given command.
 * @internal
 *
 * @param command - the command on which to apply collation
 * @param target - target of command
 * @param options - options containing collation settings
 */

function decorateWithCollation(command, target, options) {
  var capabilities = getTopology(target).capabilities;

  if (options.collation && _typeof(options.collation) === 'object') {
    if (capabilities && capabilities.commandsTakeCollation) {
      command.collation = options.collation;
    } else {
      throw new error_1.MongoCompatibilityError("Current topology does not support collation");
    }
  }
}

exports.decorateWithCollation = decorateWithCollation;
/**
 * Applies a read concern to a given command.
 * @internal
 *
 * @param command - the command on which to apply the read concern
 * @param coll - the parent collection of the operation calling this method
 */

function decorateWithReadConcern(command, coll, options) {
  if (options && options.session && options.session.inTransaction()) {
    return;
  }

  var readConcern = Object.assign({}, command.readConcern || {});

  if (coll.s.readConcern) {
    Object.assign(readConcern, coll.s.readConcern);
  }

  if (Object.keys(readConcern).length > 0) {
    Object.assign(command, {
      readConcern: readConcern
    });
  }
}

exports.decorateWithReadConcern = decorateWithReadConcern;
/**
 * Applies an explain to a given command.
 * @internal
 *
 * @param command - the command on which to apply the explain
 * @param options - the options containing the explain verbosity
 */

function decorateWithExplain(command, explain) {
  if (command.explain) {
    return command;
  }

  return {
    explain: command,
    verbosity: explain.verbosity
  };
}

exports.decorateWithExplain = decorateWithExplain;
/**
 * A helper function to get the topology from a given provider. Throws
 * if the topology cannot be found.
 * @throws MongoNotConnectedError
 * @internal
 */

function getTopology(provider) {
  // MongoClient or ClientSession or AbstractCursor
  if ('topology' in provider && provider.topology) {
    return provider.topology;
  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {
    return provider.s.client.topology;
  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {
    return provider.s.db.s.client.topology;
  }

  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');
}

exports.getTopology = getTopology;
/**
 * Default message handler for generating deprecation warnings.
 * @internal
 *
 * @param name - function name
 * @param option - option name
 * @returns warning message
 */

function defaultMsgHandler(name, option) {
  return "".concat(name, " option [").concat(option, "] is deprecated and will be removed in a later version.");
}

exports.defaultMsgHandler = defaultMsgHandler;
/**
 * Deprecates a given function's options.
 * @internal
 *
 * @param this - the bound class if this is a method
 * @param config - configuration for deprecation
 * @param fn - the target function of deprecation
 * @returns modified function that warns once per deprecated option, and executes original function
 */

function deprecateOptions(config, fn) {
  if (process.noDeprecation === true) {
    return fn;
  }

  var msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
  var optionsWarned = new Set();

  function deprecated() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var options = args[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit

    if (!isObject(options) || Object.keys(options).length === 0) {
      return fn.bind(this).apply(void 0, args); // call the function, no change
    } // interrupt the function call with a warning


    var _iterator = _createForOfIteratorHelper(config.deprecatedOptions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var deprecatedOption = _step.value;

        if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {
          optionsWarned.add(deprecatedOption);
          var msg = msgHandler(config.name, deprecatedOption);
          emitWarning(msg);

          if (this && 'getLogger' in this) {
            var logger = this.getLogger();

            if (logger) {
              logger.warn(msg);
            }
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return fn.bind(this).apply(void 0, args);
  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80
  // The wrapper will keep the same prototype as fn to maintain prototype chain


  Object.setPrototypeOf(deprecated, fn);

  if (fn.prototype) {
    // Setting this (rather than using Object.setPrototype, as above) ensures
    // that calling the unwrapped constructor gives an instanceof the wrapped
    // constructor.
    deprecated.prototype = fn.prototype;
  }

  return deprecated;
}

exports.deprecateOptions = deprecateOptions;
/** @internal */

function ns(ns) {
  return MongoDBNamespace.fromString(ns);
}

exports.ns = ns;
/** @public */

var MongoDBNamespace = /*#__PURE__*/function () {
  /**
   * Create a namespace object
   *
   * @param db - database name
   * @param collection - collection name
   */
  function MongoDBNamespace(db, collection) {
    _classCallCheck(this, MongoDBNamespace);

    this.db = db;
    this.collection = collection === '' ? undefined : collection;
  }

  _createClass(MongoDBNamespace, [{
    key: "toString",
    value: function toString() {
      return this.collection ? "".concat(this.db, ".").concat(this.collection) : this.db;
    }
  }, {
    key: "withCollection",
    value: function withCollection(collection) {
      return new MongoDBNamespace(this.db, collection);
    }
  }], [{
    key: "fromString",
    value: function fromString(namespace) {
      if (typeof namespace !== 'string' || namespace === '') {
        // TODO(NODE-3483): Replace with MongoNamespaceError
        throw new error_1.MongoRuntimeError("Cannot parse namespace from \"".concat(namespace, "\""));
      }

      var _namespace$split = namespace.split('.'),
          _namespace$split2 = _toArray(_namespace$split),
          db = _namespace$split2[0],
          collectionParts = _namespace$split2.slice(1);

      var collection = collectionParts.join('.');
      return new MongoDBNamespace(db, collection === '' ? undefined : collection);
    }
  }]);

  return MongoDBNamespace;
}();

exports.MongoDBNamespace = MongoDBNamespace;
/** @internal */

function makeCounter() {
  var seed,
      count,
      newCount,
      _args = arguments;
  return _regeneratorRuntime().wrap(function makeCounter$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          seed = _args.length > 0 && _args[0] !== undefined ? _args[0] : 0;
          count = seed;

        case 2:
          if (false) {}

          newCount = count;
          count += 1;
          _context.next = 7;
          return newCount;

        case 7:
          _context.next = 2;
          break;

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

exports.makeCounter = makeCounter;
/**
 * Helper function for either accepting a callback, or returning a promise
 * @internal
 *
 * @param callback - The last function argument in exposed method, controls if a Promise is returned
 * @param wrapper - A function that wraps the callback
 * @returns Returns void if a callback is supplied, else returns a Promise.
 */

function maybePromise(callback, wrapper) {
  var Promise = promise_provider_1.PromiseProvider.get();
  var result;

  if (typeof callback !== 'function') {
    result = new Promise(function (resolve, reject) {
      callback = function callback(err, res) {
        if (err) return reject(err);
        resolve(res);
      };
    });
  }

  wrapper(function (err, res) {
    if (err != null) {
      try {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        callback(err);
      } catch (error) {
        process.nextTick(function () {
          throw error;
        });
      }

      return;
    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


    callback(err, res);
  });
  return result;
}

exports.maybePromise = maybePromise;
/** @internal */

function databaseNamespace(ns) {
  return ns.split('.')[0];
}

exports.databaseNamespace = databaseNamespace;
/**
 * Synchronously Generate a UUIDv4
 * @internal
 */

function uuidV4() {
  var result = crypto.randomBytes(16);
  result[6] = result[6] & 0x0f | 0x40;
  result[8] = result[8] & 0x3f | 0x80;
  return result;
}

exports.uuidV4 = uuidV4;
/**
 * A helper function for determining `maxWireVersion` between legacy and new topology instances
 * @internal
 */

function maxWireVersion(topologyOrServer) {
  if (topologyOrServer) {
    if (topologyOrServer.loadBalanced) {
      // Since we do not have a monitor, we assume the load balanced server is always
      // pointed at the latest mongodb version. There is a risk that for on-prem
      // deployments that don't upgrade immediately that this could alert to the
      // application that a feature is avaiable that is actually not.
      return constants_1.MAX_SUPPORTED_WIRE_VERSION;
    }

    if (topologyOrServer.hello) {
      return topologyOrServer.hello.maxWireVersion;
    }

    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {
      var lastHello = topologyOrServer.lastHello();

      if (lastHello) {
        return lastHello.maxWireVersion;
      }
    }

    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {
      return topologyOrServer.description.maxWireVersion;
    }
  }

  return 0;
}

exports.maxWireVersion = maxWireVersion;
/**
 * Checks that collation is supported by server.
 * @internal
 *
 * @param server - to check against
 * @param cmd - object where collation may be specified
 */

function collationNotSupported(server, cmd) {
  return cmd && cmd.collation && maxWireVersion(server) < 5;
}

exports.collationNotSupported = collationNotSupported;
/**
 * Applies the function `eachFn` to each item in `arr`, in parallel.
 * @internal
 *
 * @param arr - An array of items to asynchronously iterate over
 * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.
 * @param callback - The callback called after every item has been iterated
 */

function eachAsync(arr, eachFn, callback) {
  arr = arr || [];
  var idx = 0;
  var awaiting = 0;

  for (idx = 0; idx < arr.length; ++idx) {
    awaiting++;
    eachFn(arr[idx], eachCallback);
  }

  if (awaiting === 0) {
    callback();
    return;
  }

  function eachCallback(err) {
    awaiting--;

    if (err) {
      callback(err);
      return;
    }

    if (idx === arr.length && awaiting <= 0) {
      callback();
    }
  }
}

exports.eachAsync = eachAsync;
/** @internal */

function eachAsyncSeries(arr, eachFn, callback) {
  arr = arr || [];
  var idx = 0;
  var awaiting = arr.length;

  if (awaiting === 0) {
    callback();
    return;
  }

  function eachCallback(err) {
    idx++;
    awaiting--;

    if (err) {
      callback(err);
      return;
    }

    if (idx === arr.length && awaiting <= 0) {
      callback();
      return;
    }

    eachFn(arr[idx], eachCallback);
  }

  eachFn(arr[idx], eachCallback);
}

exports.eachAsyncSeries = eachAsyncSeries;
/** @internal */

function arrayStrictEqual(arr, arr2) {
  if (!Array.isArray(arr) || !Array.isArray(arr2)) {
    return false;
  }

  return arr.length === arr2.length && arr.every(function (elt, idx) {
    return elt === arr2[idx];
  });
}

exports.arrayStrictEqual = arrayStrictEqual;
/** @internal */

function errorStrictEqual(lhs, rhs) {
  if (lhs === rhs) {
    return true;
  }

  if (!lhs || !rhs) {
    return lhs === rhs;
  }

  if (lhs == null && rhs != null || lhs != null && rhs == null) {
    return false;
  }

  if (lhs.constructor.name !== rhs.constructor.name) {
    return false;
  }

  if (lhs.message !== rhs.message) {
    return false;
  }

  return true;
}

exports.errorStrictEqual = errorStrictEqual;
/** @internal */

function makeStateMachine(stateTable) {
  return function stateTransition(target, newState) {
    var legalStates = stateTable[target.s.state];

    if (legalStates && legalStates.indexOf(newState) < 0) {
      throw new error_1.MongoRuntimeError("illegal state transition from [".concat(target.s.state, "] => [").concat(newState, "], allowed: [").concat(legalStates, "]"));
    }

    target.emit('stateChanged', target.s.state, newState);
    target.s.state = newState;
  };
}

exports.makeStateMachine = makeStateMachine; // eslint-disable-next-line @typescript-eslint/no-var-requires

var NODE_DRIVER_VERSION = (__webpack_require__(1693)/* .version */ .i8);

function makeClientMetadata(options) {
  options = options !== null && options !== void 0 ? options : {};
  var metadata = {
    driver: {
      name: 'nodejs',
      version: NODE_DRIVER_VERSION
    },
    os: {
      type: os.type(),
      name: process.platform,
      architecture: process.arch,
      version: os.release()
    },
    platform: "Node.js ".concat(process.version, ", ").concat(os.endianness(), " (unified)")
  }; // support optionally provided wrapping driver info

  if (options.driverInfo) {
    if (options.driverInfo.name) {
      metadata.driver.name = "".concat(metadata.driver.name, "|").concat(options.driverInfo.name);
    }

    if (options.driverInfo.version) {
      metadata.version = "".concat(metadata.driver.version, "|").concat(options.driverInfo.version);
    }

    if (options.driverInfo.platform) {
      metadata.platform = "".concat(metadata.platform, "|").concat(options.driverInfo.platform);
    }
  }

  if (options.appName) {
    // MongoDB requires the appName not exceed a byte length of 128
    var buffer = Buffer.from(options.appName);
    metadata.application = {
      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName
    };
  }

  return metadata;
}

exports.makeClientMetadata = makeClientMetadata;
/** @internal */

function now() {
  var hrtime = process.hrtime();
  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);
}

exports.now = now;
/** @internal */

function calculateDurationInMs(started) {
  if (typeof started !== 'number') {
    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');
  }

  var elapsed = now() - started;
  return elapsed < 0 ? 0 : elapsed;
}

exports.calculateDurationInMs = calculateDurationInMs;
/**
 * Creates an interval timer which is able to be woken up sooner than
 * the interval. The timer will also debounce multiple calls to wake
 * ensuring that the function is only ever called once within a minimum
 * interval window.
 * @internal
 *
 * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter
 */

function makeInterruptibleAsyncInterval(fn, options) {
  var timerId;
  var lastCallTime;
  var cannotBeExpedited = false;
  var stopped = false;
  options = options !== null && options !== void 0 ? options : {};
  var interval = options.interval || 1000;
  var minInterval = options.minInterval || 500;
  var immediate = typeof options.immediate === 'boolean' ? options.immediate : false;
  var clock = typeof options.clock === 'function' ? options.clock : now;

  function wake() {
    var currentTime = clock();
    var nextScheduledCallTime = lastCallTime + interval;
    var timeUntilNextCall = nextScheduledCallTime - currentTime; // For the streaming protocol: there is nothing obviously stopping this
    // interval from being woken up again while we are waiting "infinitely"
    // for `fn` to be called again`. Since the function effectively
    // never completes, the `timeUntilNextCall` will continue to grow
    // negatively unbounded, so it will never trigger a reschedule here.
    // This is possible in virtualized environments like AWS Lambda where our
    // clock is unreliable. In these cases the timer is "running" but never
    // actually completes, so we want to execute immediately and then attempt
    // to reschedule.

    if (timeUntilNextCall < 0) {
      executeAndReschedule();
      return;
    } // debounce multiple calls to wake within the `minInterval`


    if (cannotBeExpedited) {
      return;
    } // reschedule a call as soon as possible, ensuring the call never happens
    // faster than the `minInterval`


    if (timeUntilNextCall > minInterval) {
      reschedule(minInterval);
      cannotBeExpedited = true;
    }
  }

  function stop() {
    stopped = true;

    if (timerId) {
      (0, timers_1.clearTimeout)(timerId);
      timerId = undefined;
    }

    lastCallTime = 0;
    cannotBeExpedited = false;
  }

  function reschedule(ms) {
    if (stopped) return;

    if (timerId) {
      (0, timers_1.clearTimeout)(timerId);
    }

    timerId = (0, timers_1.setTimeout)(executeAndReschedule, ms || interval);
  }

  function executeAndReschedule() {
    cannotBeExpedited = false;
    lastCallTime = clock();
    fn(function (err) {
      if (err) throw err;
      reschedule(interval);
    });
  }

  if (immediate) {
    executeAndReschedule();
  } else {
    lastCallTime = clock();
    reschedule(undefined);
  }

  return {
    wake: wake,
    stop: stop
  };
}

exports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;
/** @internal */

function hasAtomicOperators(doc) {
  if (Array.isArray(doc)) {
    var _iterator2 = _createForOfIteratorHelper(doc),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var document = _step2.value;

        if (hasAtomicOperators(document)) {
          return true;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return false;
  }

  var keys = Object.keys(doc);
  return keys.length > 0 && keys[0][0] === '$';
}

exports.hasAtomicOperators = hasAtomicOperators;
/**
 * Merge inherited properties from parent into options, prioritizing values from options,
 * then values from parent.
 * @internal
 */

function resolveOptions(parent, options) {
  var _a, _b, _c;

  var result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent)); // Users cannot pass a readConcern/writeConcern to operations in a transaction

  var session = options === null || options === void 0 ? void 0 : options.session;

  if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {
    var readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;

    if (readConcern) {
      result.readConcern = readConcern;
    }

    var writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;

    if (writeConcern) {
      result.writeConcern = writeConcern;
    }
  }

  var readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;

  if (readPreference) {
    result.readPreference = readPreference;
  }

  return result;
}

exports.resolveOptions = resolveOptions;

function isSuperset(set, subset) {
  set = Array.isArray(set) ? new Set(set) : set;
  subset = Array.isArray(subset) ? new Set(subset) : subset;

  var _iterator3 = _createForOfIteratorHelper(subset),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var elem = _step3.value;

      if (!set.has(elem)) {
        return false;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return true;
}

exports.isSuperset = isSuperset;
/**
 * Checks if the document is a Hello request
 * @internal
 */

function isHello(doc) {
  return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
}

exports.isHello = isHello;
/** Returns the items that are uniquely in setA */

function setDifference(setA, setB) {
  var difference = new Set(setA);

  var _iterator4 = _createForOfIteratorHelper(setB),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var elem = _step4.value;
      difference["delete"](elem);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return difference;
}

exports.setDifference = setDifference;

var HAS_OWN = function HAS_OWN(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
};

function isRecord(value) {
  var requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  if (!isObject(value)) {
    return false;
  }

  var ctor = value.constructor;

  if (ctor && ctor.prototype) {
    if (!isObject(ctor.prototype)) {
      return false;
    } // Check to see if some method exists from the Object exists


    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {
      return false;
    }
  }

  if (requiredKeys) {
    var keys = Object.keys(value);
    return isSuperset(keys, requiredKeys);
  }

  return true;
}

exports.isRecord = isRecord;
/**
 * Make a deep copy of an object
 *
 * NOTE: This is not meant to be the perfect implementation of a deep copy,
 * but instead something that is good enough for the purposes of
 * command monitoring.
 */

function deepCopy(value) {
  if (value == null) {
    return value;
  } else if (Array.isArray(value)) {
    return value.map(function (item) {
      return deepCopy(item);
    });
  } else if (isRecord(value)) {
    var res = {};

    for (var key in value) {
      res[key] = deepCopy(value[key]);
    }

    return res;
  }

  var ctor = value.constructor;

  if (ctor) {
    switch (ctor.name.toLowerCase()) {
      case 'date':
        return new ctor(Number(value));

      case 'map':
        return new Map(value);

      case 'set':
        return new Set(value);

      case 'buffer':
        return Buffer.from(value);
    }
  }

  return value;
}

exports.deepCopy = deepCopy;
/** @internal */

var kBuffers = Symbol('buffers');
/** @internal */

var kLength = Symbol('length');
/**
 * A pool of Buffers which allow you to read them as if they were one
 * @internal
 */

var BufferPool = /*#__PURE__*/function () {
  function BufferPool() {
    _classCallCheck(this, BufferPool);

    this[kBuffers] = [];
    this[kLength] = 0;
  }

  _createClass(BufferPool, [{
    key: "length",
    get: function get() {
      return this[kLength];
    }
    /** Adds a buffer to the internal buffer pool list */

  }, {
    key: "append",
    value: function append(buffer) {
      this[kBuffers].push(buffer);
      this[kLength] += buffer.length;
    }
    /** Returns the requested number of bytes without consuming them */

  }, {
    key: "peek",
    value: function peek(size) {
      return this.read(size, false);
    }
    /** Reads the requested number of bytes, optionally consuming them */

  }, {
    key: "read",
    value: function read(size) {
      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (typeof size !== 'number' || size < 0) {
        throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
      }

      if (size > this[kLength]) {
        return Buffer.alloc(0);
      }

      var result; // read the whole buffer

      if (size === this.length) {
        result = Buffer.concat(this[kBuffers]);

        if (consume) {
          this[kBuffers] = [];
          this[kLength] = 0;
        }
      } // size is within first buffer, no need to concat
      else if (size <= this[kBuffers][0].length) {
        result = this[kBuffers][0].slice(0, size);

        if (consume) {
          this[kBuffers][0] = this[kBuffers][0].slice(size);
          this[kLength] -= size;
        }
      } // size is beyond first buffer, need to track and copy
      else {
        result = Buffer.allocUnsafe(size);
        var idx;
        var offset = 0;
        var bytesToCopy = size;

        for (idx = 0; idx < this[kBuffers].length; ++idx) {
          var bytesCopied = void 0;

          if (bytesToCopy > this[kBuffers][idx].length) {
            bytesCopied = this[kBuffers][idx].copy(result, offset, 0);
            offset += bytesCopied;
          } else {
            bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);

            if (consume) {
              this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);
            }

            offset += bytesCopied;
            break;
          }

          bytesToCopy -= bytesCopied;
        } // compact the internal buffer array


        if (consume) {
          this[kBuffers] = this[kBuffers].slice(idx);
          this[kLength] -= size;
        }
      }

      return result;
    }
  }]);

  return BufferPool;
}();

exports.BufferPool = BufferPool;
/** @public */

var HostAddress = /*#__PURE__*/function (_Symbol$for) {
  function HostAddress(hostString) {
    _classCallCheck(this, HostAddress);

    var escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts

    var _url_1$URL = new url_1.URL("mongodb://".concat(escapedHost)),
        hostname = _url_1$URL.hostname,
        port = _url_1$URL.port;

    if (escapedHost.endsWith('.sock')) {
      // heuristically determine if we're working with a domain socket
      this.socketPath = decodeURIComponent(escapedHost);
    } else if (typeof hostname === 'string') {
      this.isIPv6 = false;
      var normalized = decodeURIComponent(hostname).toLowerCase();

      if (normalized.startsWith('[') && normalized.endsWith(']')) {
        this.isIPv6 = true;
        normalized = normalized.substring(1, hostname.length - 1);
      }

      this.host = normalized.toLowerCase();

      if (typeof port === 'number') {
        this.port = port;
      } else if (typeof port === 'string' && port !== '') {
        this.port = Number.parseInt(port, 10);
      } else {
        this.port = 27017;
      }

      if (this.port === 0) {
        throw new error_1.MongoParseError('Invalid port (zero) with hostname');
      }
    } else {
      throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');
    }

    Object.freeze(this);
  }

  _createClass(HostAddress, [{
    key: _Symbol$for,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new HostAddress('".concat(this.toString(true), "')");
    }
    /**
     * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings
     */

  }, {
    key: "toString",
    value: function toString() {
      var ipv6Brackets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (typeof this.host === 'string') {
        if (this.isIPv6 && ipv6Brackets) {
          return "[".concat(this.host, "]:").concat(this.port);
        }

        return "".concat(this.host, ":").concat(this.port);
      }

      return "".concat(this.socketPath);
    }
  }], [{
    key: "fromString",
    value: function fromString(s) {
      return new HostAddress(s);
    }
  }, {
    key: "fromHostPort",
    value: function fromHostPort(host, port) {
      if (host.includes(':')) {
        host = "[".concat(host, "]"); // IPv6 address
      }

      return HostAddress.fromString("".concat(host, ":").concat(port));
    }
  }, {
    key: "fromSrvRecord",
    value: function fromSrvRecord(_ref) {
      var name = _ref.name,
          port = _ref.port;
      return HostAddress.fromHostPort(name, port);
    }
  }]);

  return HostAddress;
}(Symbol["for"]('nodejs.util.inspect.custom'));

exports.HostAddress = HostAddress;
exports.DEFAULT_PK_FACTORY = {
  // We prefer not to rely on ObjectId having a createPk method
  createPk: function createPk() {
    return new bson_1.ObjectId();
  }
};
/**
 * When the driver used emitWarning the code will be equal to this.
 * @public
 *
 * @example
 * ```js
 * process.on('warning', (warning) => {
 *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')
 * })
 * ```
 */

exports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';
/** @internal */

function emitWarning(message) {
  return process.emitWarning(message, {
    code: exports.MONGODB_WARNING_CODE
  });
}

exports.emitWarning = emitWarning;
var emittedWarnings = new Set();
/**
 * Will emit a warning once for the duration of the application.
 * Uses the message to identify if it has already been emitted
 * so using string interpolation can cause multiple emits
 * @internal
 */

function emitWarningOnce(message) {
  if (!emittedWarnings.has(message)) {
    emittedWarnings.add(message);
    return emitWarning(message);
  }
}

exports.emitWarningOnce = emitWarningOnce;
/**
 * Takes a JS object and joins the values into a string separated by ', '
 */

function enumToString(en) {
  return Object.values(en).join(', ');
}

exports.enumToString = enumToString;
/**
 * Determine if a server supports retryable writes.
 *
 * @internal
 */

function supportsRetryableWrites(server) {
  if (!server) {
    return false;
  }

  if (server.loadBalanced) {
    // Loadbalanced topologies will always support retry writes
    return true;
  }

  if (server.description.logicalSessionTimeoutMinutes != null) {
    // that supports sessions
    if (server.description.type !== common_1.ServerType.Standalone) {
      // and that is not a standalone
      return true;
    }
  }

  return false;
}

exports.supportsRetryableWrites = supportsRetryableWrites;

function parsePackageVersion(_ref2) {
  var version = _ref2.version;

  var _version$split$map = version.split('.').map(function (n) {
    return Number.parseInt(n, 10);
  }),
      _version$split$map2 = _slicedToArray(_version$split$map, 3),
      major = _version$split$map2[0],
      minor = _version$split$map2[1],
      patch = _version$split$map2[2];

  return {
    major: major,
    minor: minor,
    patch: patch
  };
}

exports.parsePackageVersion = parsePackageVersion;
/**
 * FisherYates Shuffle
 *
 * Reference: https://bost.ocks.org/mike/shuffle/
 * @param sequence - items to be shuffled
 * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.
 */

function shuffle(sequence) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var items = Array.from(sequence); // shallow copy in order to never shuffle the input

  if (limit > items.length) {
    throw new error_1.MongoRuntimeError('Limit must be less than the number of items');
  }

  var remainingItemsToShuffle = items.length;
  var lowerBound = limit % items.length === 0 ? 1 : items.length - limit;

  while (remainingItemsToShuffle > lowerBound) {
    // Pick a remaining element
    var randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
    remainingItemsToShuffle -= 1; // And swap it with the current element

    var swapHold = items[remainingItemsToShuffle];
    items[remainingItemsToShuffle] = items[randomIndex];
    items[randomIndex] = swapHold;
  }

  return limit % items.length === 0 ? items : items.slice(lowerBound);
}

exports.shuffle = shuffle; // TODO: this should be codified in command construction
// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern

function commandSupportsReadConcern(command, options) {
  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
    return true;
  }

  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {
    return true;
  }

  return false;
}

exports.commandSupportsReadConcern = commandSupportsReadConcern;
/** A utility function to get the instance of mongodb-client-encryption, if it exists. */

function getMongoDBClientEncryption() {
  var mongodbClientEncryption = null; // NOTE(NODE-4254): This is to get around the circular dependency between
  // mongodb-client-encryption and the driver in the test scenarios.

  if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' && process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {
    try {
      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block
      // Cannot be moved to helper utility function, bundlers search and replace the actual require call
      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed
      mongodbClientEncryption = __webpack_require__(5616)(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);
    } catch (_unused) {// ignore
    }
  } else {
    try {
      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block
      // Cannot be moved to helper utility function, bundlers search and replace the actual require call
      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed
      mongodbClientEncryption = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'mongodb-client-encryption'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
    } catch (_unused2) {// ignore
    }
  }

  return mongodbClientEncryption;
}

exports.getMongoDBClientEncryption = getMongoDBClientEncryption;
/**
 * Compare objectIds. `null` is always less
 * - `+1 = oid1 is greater than oid2`
 * - `-1 = oid1 is less than oid2`
 * - `+0 = oid1 is equal oid2`
 */

function compareObjectId(oid1, oid2) {
  if (oid1 == null && oid2 == null) {
    return 0;
  }

  if (oid1 == null) {
    return -1;
  }

  if (oid2 == null) {
    return 1;
  }

  return oid1.id.compare(oid2.id);
}

exports.compareObjectId = compareObjectId;

/***/ }),

/***/ 1473:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WriteConcern = exports.WRITE_CONCERN_KEYS = void 0;
exports.WRITE_CONCERN_KEYS = ['w', 'wtimeout', 'j', 'journal', 'fsync'];
/**
 * A MongoDB WriteConcern, which describes the level of acknowledgement
 * requested from MongoDB for write operations.
 * @public
 *
 * @see https://docs.mongodb.com/manual/reference/write-concern/
 */

var WriteConcern = /*#__PURE__*/function () {
  /**
   * Constructs a WriteConcern from the write concern properties.
   * @param w - request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags.
   * @param wtimeout - specify a time limit to prevent write operations from blocking indefinitely
   * @param j - request acknowledgment that the write operation has been written to the on-disk journal
   * @param fsync - equivalent to the j option
   */
  function WriteConcern(w, wtimeout, j, fsync) {
    _classCallCheck(this, WriteConcern);

    if (w != null) {
      if (!Number.isNaN(Number(w))) {
        this.w = Number(w);
      } else {
        this.w = w;
      }
    }

    if (wtimeout != null) {
      this.wtimeout = wtimeout;
    }

    if (j != null) {
      this.j = j;
    }

    if (fsync != null) {
      this.fsync = fsync;
    }
  }
  /** Construct a WriteConcern given an options object. */


  _createClass(WriteConcern, null, [{
    key: "fromOptions",
    value: function fromOptions(options, inherit) {
      if (options == null) return undefined;
      inherit = inherit !== null && inherit !== void 0 ? inherit : {};
      var opts;

      if (typeof options === 'string' || typeof options === 'number') {
        opts = {
          w: options
        };
      } else if (options instanceof WriteConcern) {
        opts = options;
      } else {
        opts = options.writeConcern;
      }

      var parentOpts = inherit instanceof WriteConcern ? inherit : inherit.writeConcern;

      var _parentOpts$opts = _objectSpread(_objectSpread({}, parentOpts), opts),
          _parentOpts$opts$w = _parentOpts$opts.w,
          w = _parentOpts$opts$w === void 0 ? undefined : _parentOpts$opts$w,
          _parentOpts$opts$wtim = _parentOpts$opts.wtimeout,
          wtimeout = _parentOpts$opts$wtim === void 0 ? undefined : _parentOpts$opts$wtim,
          _parentOpts$opts$j = _parentOpts$opts.j,
          j = _parentOpts$opts$j === void 0 ? undefined : _parentOpts$opts$j,
          _parentOpts$opts$fsyn = _parentOpts$opts.fsync,
          fsync = _parentOpts$opts$fsyn === void 0 ? undefined : _parentOpts$opts$fsyn,
          _parentOpts$opts$jour = _parentOpts$opts.journal,
          journal = _parentOpts$opts$jour === void 0 ? undefined : _parentOpts$opts$jour,
          _parentOpts$opts$wtim2 = _parentOpts$opts.wtimeoutMS,
          wtimeoutMS = _parentOpts$opts$wtim2 === void 0 ? undefined : _parentOpts$opts$wtim2;

      if (w != null || wtimeout != null || wtimeoutMS != null || j != null || journal != null || fsync != null) {
        return new WriteConcern(w, wtimeout !== null && wtimeout !== void 0 ? wtimeout : wtimeoutMS, j !== null && j !== void 0 ? j : journal, fsync);
      }

      return undefined;
    }
  }]);

  return WriteConcern;
}();

exports.WriteConcern = WriteConcern;

/***/ }),

/***/ 5616:
/***/ (function(module) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 5616;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 8054:
/***/ (function(module) {

"use strict";
module.exports = require("bson");

/***/ }),

/***/ 2279:
/***/ (function(module) {

"use strict";
module.exports = require("denque");

/***/ }),

/***/ 1239:
/***/ (function(module) {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 5588:
/***/ (function(module) {

"use strict";
module.exports = require("mongodb-connection-string-url");

/***/ }),

/***/ 2066:
/***/ (function(module) {

"use strict";
module.exports = require("saslprep");

/***/ }),

/***/ 1048:
/***/ (function(module) {

"use strict";
module.exports = require("socks");

/***/ }),

/***/ 6113:
/***/ (function(module) {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 9523:
/***/ (function(module) {

"use strict";
module.exports = require("dns");

/***/ }),

/***/ 7147:
/***/ (function(module) {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ (function(module) {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 1808:
/***/ (function(module) {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ (function(module) {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 2781:
/***/ (function(module) {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 9512:
/***/ (function(module) {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ 4404:
/***/ (function(module) {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 7310:
/***/ (function(module) {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ (function(module) {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9796:
/***/ (function(module) {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 1693:
/***/ (function(module) {

"use strict";
module.exports = {"i8":"4.9.0"};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4515);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }



function main() {
  return _main.apply(this, arguments);
}

function _main() {
  _main = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var uri, client;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            uri = "mongodb://127.0.0.1:27017";
            client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri);
            _context.prev = 2;
            _context.next = 5;
            return client.connect();

          case 5:
            _context.next = 7;
            return findOneListingByName(client, "Lovely Loft");

          case 7:
            _context.next = 12;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);
            console.error(_context.t0);

          case 12:
            _context.prev = 12;
            setTimeout(function () {
              client.close();
            }, 1500);
            return _context.finish(12);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 9, 12, 15]]);
  }));
  return _main.apply(this, arguments);
}

main()["catch"](console.error);

function findOneListingByName(_x, _x2) {
  return _findOneListingByName.apply(this, arguments);
}

function _findOneListingByName() {
  _findOneListingByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(client, nameOfListing) {
    var result;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return client.db("sample_airbnb").collection("listingsAndReviews").findOne({
              name: nameOfListing
            });

          case 2:
            result = _context2.sent;

            if (result) {
              console.log(result);
            } else {
              console.log("no listing found");
            }

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _findOneListingByName.apply(this, arguments);
}
}();
/******/ })()
;